Definition syntax tree at 18.12.2024 0:32:09

Parsing C:\RemoteTasks.Workspace\Sessions\VisualizeArchModel_0e0c2003-f35b-4b5d-8809-d8b7f9771ae4\workdir\In\myArch.target.pdsl

 DefSyntaxTree at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [64];\n        storage AR_S [64];\n        storage ALR_S [64];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [64];\n        storage BP_S [64];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [64];\n        storage OUT_S [64];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1, reg2) plain2;\n        mnemonic NEQ for neq(reg1, reg2) plain2;\n        mnemonic GR for gr(reg1, reg2) plain2;\n        mnemonic LE for le(reg1, reg2) plain2;\n        mnemonic GREQ for greq(reg1, reg2) plain2;\n        mnemonic LEEQ for leeq(reg1, reg2) plain2;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(reg1, reg2, value) plain3;\n        mnemonic JNEQ for jneq(reg1, reg2, value) plain3;\n        mnemonic JGR for jgr(reg1, reg2, value) plain3;\n        mnemonic JLE for jle(reg1, reg2, value) plain3;\n        mnemonic JGREQ for jgreq(reg1, reg2, value) plain3;\n        mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3;\n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n}
  └─ ArchitectureAspectSyntaxNode at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [64];\n        storage AR_S [64];\n        storage ALR_S [64];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [64];\n        storage BP_S [64];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [64];\n        storage OUT_S [64];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1, reg2) plain2;\n        mnemonic NEQ for neq(reg1, reg2) plain2;\n        mnemonic GR for gr(reg1, reg2) plain2;\n        mnemonic LE for le(reg1, reg2) plain2;\n        mnemonic GREQ for greq(reg1, reg2) plain2;\n        mnemonic LEEQ for leeq(reg1, reg2) plain2;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(reg1, reg2, value) plain3;\n        mnemonic JNEQ for jneq(reg1, reg2, value) plain3;\n        mnemonic JGR for jgr(reg1, reg2, value) plain3;\n        mnemonic JLE for jle(reg1, reg2, value) plain3;\n        mnemonic JGREQ for jgreq(reg1, reg2, value) plain3;\n        mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3;\n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n}
      ├─ ArchRegistersSyntaxNode at [L3, C5]: registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [64];\n        storage AR_S [64];\n        storage ALR_S [64];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [64];\n        storage BP_S [64];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [64];\n        storage OUT_S [64];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];
      │   ├─ ArchRegsStorageItemSyntaxNode at [L5, C9]: storage R0_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R0_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L6, C9]: storage R1_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L7, C9]: storage R2_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L8, C9]: storage R3_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R3_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L9, C9]: storage R4_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R4_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L10, C9]: storage R5_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R5_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L11, C9]: storage R6_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R6_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L12, C9]: storage R7_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R7_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L15, C9]: view R0 = R0_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L15, C19]: R0_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L16, C9]: view R1 = R1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L16, C19]: R1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L17, C9]: view R2 = R2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L17, C19]: R2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L18, C9]: view R3 = R3_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L18, C19]: R3_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L19, C9]: view R4 = R4_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L19, C19]: R4_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L20, C9]: view R5 = R5_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L20, C19]: R5_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L21, C9]: view R6 = R6_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L21, C19]: R6_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L22, C9]: view R7 = R7_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L22, C19]: R7_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L25, C9]: view ER0 = R0_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L25, C20]: R0_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: ER0
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L26, C9]: view ER1 = R1_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L26, C20]: R1_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: ER1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L27, C9]: view ER2 = R2_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L27, C20]: R2_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: ER2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L28, C9]: view ER3 = R3_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L28, C20]: R3_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: ER3
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L29, C9]: view ER4 = R4_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L29, C20]: R4_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: ER4
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L30, C9]: view ER5 = R5_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L30, C20]: R5_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: ER5
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L31, C9]: view ER6 = R6_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L31, C20]: R6_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: ER6
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L32, C9]: view ER7 = R7_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L32, C20]: R7_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: ER7
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L35, C9]: view R0H = R0_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L35, C20]: R0_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L36, C9]: view R1H = R1_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L36, C20]: R1_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L37, C9]: view R2H = R2_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L37, C20]: R2_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L38, C9]: view R3H = R3_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L38, C20]: R3_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L39, C9]: view R4H = R4_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L39, C20]: R4_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L40, C9]: view R5H = R5_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L40, C20]: R5_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L41, C9]: view R6H = R6_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L41, C20]: R6_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L42, C9]: view R7H = R7_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L42, C20]: R7_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L45, C9]: view R0L = R0_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L45, C20]: R0_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L46, C9]: view R1L = R1_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L46, C20]: R1_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L47, C9]: view R2L = R2_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L47, C20]: R2_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L48, C9]: view R3L = R3_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L48, C20]: R3_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L49, C9]: view R4L = R4_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L49, C20]: R4_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L50, C9]: view R5L = R5_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L50, C20]: R5_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L51, C9]: view R6L = R6_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L51, C20]: R6_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L52, C9]: view R7L = R7_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L52, C20]: R7_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7L
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L55, C9]: storage IP_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: IP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L56, C9]: storage AR_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: AR_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L57, C9]: storage ALR_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: ALR_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L58, C9]: view IP = IP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L58, C19]: IP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IP_S
      │   │   │ 
      │   │   └─ Name: IP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L59, C9]: view AR = AR_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L59, C19]: AR_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: AR_S
      │   │   │ 
      │   │   └─ Name: AR
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L60, C9]: view ALR = ALR_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L60, C20]: ALR_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: ALR_S
      │   │   │ 
      │   │   └─ Name: ALR
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L63, C9]: storage SP_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: SP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L64, C9]: storage BP_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L65, C9]: storage BR1_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L66, C9]: storage BR2_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L67, C9]: storage RT_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: RT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L68, C9]: view SP = SP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L68, C19]: SP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: SP_S
      │   │   │ 
      │   │   └─ Name: SP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L69, C9]: view BP = BP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L69, C19]: BP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BP_S
      │   │   │ 
      │   │   └─ Name: BP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L70, C9]: view BR1 = BR1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L70, C20]: BR1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR1_S
      │   │   │ 
      │   │   └─ Name: BR1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L71, C9]: view BR2 = BR2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L71, C20]: BR2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR2_S
      │   │   │ 
      │   │   └─ Name: BR2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L72, C9]: view RT = RT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L72, C19]: RT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: RT_S
      │   │   │ 
      │   │   └─ Name: RT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L75, C9]: storage IN_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: IN_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L76, C9]: storage OUT_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: OUT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L77, C9]: view IN = IN_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L77, C19]: IN_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IN_S
      │   │   │ 
      │   │   └─ Name: IN
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L78, C9]: view OUT = OUT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L78, C20]: OUT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: OUT_S
      │   │   │ 
      │   │   └─ Name: OUT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L81, C9]: storage FLAGS_S [4]
      │   │   ├─ Size: 4
      │   │   └─ Name: FLAGS_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L82, C9]: view N = FLAGS_S[0]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L82, C18]: FLAGS_S[0]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 1
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: N
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L83, C9]: view Z = FLAGS_S[1]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L83, C18]: FLAGS_S[1]
      │   │   │   ├─ FromIndex: 1
      │   │   │   ├─ ToIndex: 2
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: Z
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L84, C9]: view V = FLAGS_S[2]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L84, C18]: FLAGS_S[2]
      │   │   │   ├─ FromIndex: 2
      │   │   │   ├─ ToIndex: 3
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: V
      │   │ 
      │   └─ ArchRegsViewItemSyntaxNode at [L85, C9]: view C = FLAGS_S[3]
      │       ├─ IsHidden: False
      │       ├─ ArchRegsViewWindowSyntaxNode at [L85, C18]: FLAGS_S[3]
      │       │   ├─ FromIndex: 3
      │       │   ├─ ToIndex: 4
      │       │   └─ Name: FLAGS_S
      │       │ 
      │       └─ Name: C
      │     
      ├─ ArchMemorySyntaxNode at [L88, C5]: memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L89, C9]: range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: codeM
      │   │ 
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L95, C9]: range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: constantsM
      │   │ 
      │   └─ ArchMemoryRangeItemSyntaxNode at [L101, C9]: range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │       ├─ AddressFrom: 0
      │       ├─ AddressTo: 4294967295
      │       ├─ CellSize: 8
      │       ├─ Endianess: Little
      │       ├─ Granularity: 0
      │       └─ Name: dataM
      │     
      ├─ ArchInstructionsSyntaxNode at [L107, C5]: instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};
      │   ├─ ArchFieldEncodingSyntaxNode at [L108, C9]: encode imm32 field = immediate[32]
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L108, C30]: immediate[32]
      │   │   │   ├─ Length: 32
      │   │   │   └─ Kind: Default
      │   │   │ 
      │   │   └─ Name: imm32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L109, C9]: encode off32 field = immediate[32] offset
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L109, C30]: immediate[32] offset
      │   │   │   ├─ Length: 32
      │   │   │   └─ Kind: Offset
      │   │   │ 
      │   │   └─ Name: off32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L111, C9]: encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    }
      │   │   ├─ ArchFieldEncRegisterDescrSyntaxNode at [L111, C28]: register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    }
      │   │   └─ Name: reg
      │   │ 
      │   ├─ ArchFieldsGroupEncodingSyntaxNode at [L132, C9]: encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        }
      │   │   └─ Name: size
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L139, C5]: instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L139, C23]: {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L139, C24]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L139, C105]: {\n	}
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L139, C105]: {\n	}
      │   │   │ 
      │   │   └─ Name: nop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L143, C5]: instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L143, C23]: {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L143, C24]: 0000 0001
      │   │   │   │   └─ BitsStr: 0000 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L143, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L143, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L143, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L143, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L143, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L143, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L144, C9]: when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L144, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L144, C23]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L145, C13]: let res = reg1 + reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L145, C23]: reg1 + reg2
      │   │   │       │   │   │       ├─ Operator: Sum
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L145, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L145, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L146, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L146, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L147, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L147, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L147, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L147, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L147, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L147, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L148, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L148, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L148, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L148, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L148, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L148, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L148, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L148, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L148, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L149, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L149, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L149, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L149, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L149, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L149, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L149, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L149, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L149, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L150, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L150, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L150, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L150, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L150, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L150, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L150, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L150, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L150, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L150, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L150, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L150, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L150, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L150, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L150, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L150, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L150, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L150, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L151, C16]: when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L151, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L151, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L152, C13]: let res = reg1 + reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L152, C23]: reg1 + reg2
      │   │   │       │       │   │       ├─ Operator: Sum
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L152, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L152, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L153, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L153, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L154, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L154, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L154, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L154, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L154, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L154, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L155, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L155, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L155, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L155, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L155, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L155, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L155, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L155, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L155, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L156, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L156, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L156, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L156, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L156, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L156, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L156, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L156, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L156, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L157, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L157, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L157, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L157, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L157, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L157, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L157, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L157, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L157, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L157, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L157, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L157, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L157, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L157, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L157, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L157, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L157, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L157, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L158, C16]: when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L158, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L158, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L159, C13]: let res = reg1 + reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L159, C23]: reg1 + reg2
      │   │   │       │           │   │       ├─ Operator: Sum
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L159, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L159, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L160, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L160, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L161, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L161, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L161, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L161, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L161, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L161, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L162, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L162, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L162, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L162, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L162, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L162, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L162, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L162, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L162, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L163, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L163, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L163, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L163, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L163, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L163, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L163, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L163, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L163, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L164, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L164, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L164, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L164, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L164, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L164, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L164, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L164, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L164, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L164, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L164, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L164, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L164, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L164, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L164, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L164, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L164, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L164, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L165, C16]: when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L165, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L165, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L166, C13]: let res = reg1 + reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L166, C23]: reg1 + reg2
      │   │   │       │               │   │       ├─ Operator: Sum
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L166, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L166, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L167, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L167, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L168, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L168, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L168, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L168, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L168, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L168, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L169, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L169, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L169, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L169, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L169, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L169, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L169, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L169, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L169, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L170, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L170, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L170, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L170, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L170, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L170, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L170, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L170, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L170, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L171, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L171, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L171, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L171, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L171, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L171, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L171, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L171, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L171, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L171, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L171, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L171, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L171, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L171, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L171, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L171, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L171, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L171, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L174, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L174, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L174, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L174, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L174, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L174, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L175, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L175, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L175, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L175, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ElseBranchOrNull: <NULL>
      │   │   │       │ 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L178, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L178, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L178, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L178, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L178, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L178, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: add
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L181, C5]: instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L181, C30]: {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C31]: 0000 0010
      │   │   │   │   └─ BitsStr: 0000 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C42]: 10
      │   │   │   │   └─ BitsStr: 10
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L181, C46]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C57]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L181, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L181, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L181, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L182, C9]: to = value;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L182, C9]: to = value
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L182, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L182, C14]: value
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L184, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L184, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L184, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L184, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L184, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L184, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-imm32
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L187, C5]: instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L187, C24]: {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C25]: 0000 0011
      │   │   │   │   └─ BitsStr: 0000 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L187, C36]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L187, C51]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L187, C62]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C74]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L187, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L187, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L188, C9]: when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L188, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L188, C23]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L189, C13]: let res = dataM:8[ptr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L189, C23]: dataM:8[ptr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L189, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L189, C31]: ptr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L190, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L190, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L190, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L190, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L190, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L190, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L191, C16]: when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L191, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L191, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L192, C13]: let res = dataM:8[ptr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L192, C23]: dataM:8[ptr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L192, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L192, C31]: ptr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L193, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L193, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L193, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L193, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L193, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L193, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L194, C16]: when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L194, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L194, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L195, C13]: let res = dataM:8[ptr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L195, C23]: dataM:8[ptr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L195, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L195, C31]: ptr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L196, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L196, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L196, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L196, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L196, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L196, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L197, C16]: when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L197, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L197, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L198, C13]: let res = dataM:8[ptr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L198, C23]: dataM:8[ptr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L198, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L198, C31]: ptr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L199, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L199, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L199, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L199, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L199, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L199, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L201, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L201, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L201, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L201, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L201, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L201, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L204, C5]: instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L204, C25]: {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L204, C26]: 0000 0100
      │   │   │   │   └─ BitsStr: 0000 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L204, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L204, C52]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L204, C65]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L204, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L204, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L204, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L205, C9]: when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L205, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L205, C23]: {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L206, C13]: dataM:8[ptr] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L206, C13]: dataM:8[ptr] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L206, C13]: dataM:8[ptr]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L206, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnPlaceExprSyntaxNode at [L206, C21]: ptr
      │   │   │       │   │           │ 
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L206, C28]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L206, C28]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L206, C35]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L207, C16]: when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L207, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L207, C31]: {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L208, C13]: dataM:8[ptr] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L208, C13]: dataM:8[ptr] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L208, C13]: dataM:8[ptr]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L208, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnPlaceExprSyntaxNode at [L208, C21]: ptr
      │   │   │       │       │           │ 
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L208, C28]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L208, C28]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L208, C35]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L209, C16]: when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L209, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L209, C31]: {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L210, C13]: dataM:8[ptr] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L210, C13]: dataM:8[ptr] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L210, C13]: dataM:8[ptr]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L210, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnPlaceExprSyntaxNode at [L210, C21]: ptr
      │   │   │       │           │           │ 
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L210, C28]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L210, C28]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L210, C35]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L211, C16]: when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L211, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L211, C31]: {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L212, C13]: dataM:8[ptr] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L212, C13]: dataM:8[ptr] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L212, C13]: dataM:8[ptr]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L212, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnPlaceExprSyntaxNode at [L212, C21]: ptr
      │   │   │       │               │           │ 
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L212, C28]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L212, C28]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L212, C35]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L214, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L214, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L214, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L214, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L214, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L214, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L217, C5]: instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L217, C23]: {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C24]: 0000 0101
      │   │   │   │   └─ BitsStr: 0000 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L217, C39]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C52]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C60]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L217, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L217, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L218, C9]: OUT = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L218, C9]: OUT = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L218, C9]: OUT
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L218, C15]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L219, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L219, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L219, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L219, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L219, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L219, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: out
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L222, C5]: instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L222, C22]: {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C23]: 0000 0110
      │   │   │   │   └─ BitsStr: 0000 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L222, C46]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C57]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L222, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L222, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L223, C9]: to = IN;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L223, C9]: to = IN
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L223, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L223, C14]: IN
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L224, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L224, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L224, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L224, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L224, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L224, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: in
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L227, C5]: instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L227, C28]: {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L227, C29]: 0000 0111
      │   │   │   │   └─ BitsStr: 0000 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L227, C40]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L227, C55]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L227, C66]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L227, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L227, C92]: off32 as offsetValue
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L227, C114]: {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L227, C114]: {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L228, C9]: when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L228, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L228, C23]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L229, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L229, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L229, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L229, C31]: ptr + offsetValue
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L229, C31]: ptr
      │   │   │       │   │   │           └─ ArchInsnPlaceExprSyntaxNode at [L229, C37]: offsetValue
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L230, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L230, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L230, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L230, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L230, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L230, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L231, C16]: when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L231, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L231, C31]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L232, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L232, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L232, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L232, C31]: ptr + offsetValue
      │   │   │       │       │   │           ├─ Operator: Sum
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L232, C31]: ptr
      │   │   │       │       │   │           └─ ArchInsnPlaceExprSyntaxNode at [L232, C37]: offsetValue
      │   │   │       │       │   │         
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L233, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L233, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L233, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L233, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L233, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L233, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L234, C16]: when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L234, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L234, C31]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L235, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L235, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L235, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L235, C31]: ptr + offsetValue
      │   │   │       │           │   │           ├─ Operator: Sum
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L235, C31]: ptr
      │   │   │       │           │   │           └─ ArchInsnPlaceExprSyntaxNode at [L235, C37]: offsetValue
      │   │   │       │           │   │         
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L236, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L236, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L236, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L236, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L236, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L236, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L237, C16]: when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L237, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L237, C31]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L238, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L238, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L238, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L238, C31]: ptr + offsetValue
      │   │   │       │               │   │           ├─ Operator: Sum
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L238, C31]: ptr
      │   │   │       │               │   │           └─ ArchInsnPlaceExprSyntaxNode at [L238, C37]: offsetValue
      │   │   │       │               │   │         
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L239, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L239, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L239, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L239, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L239, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L239, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L241, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L241, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L241, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L241, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L241, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L241, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L244, C5]: instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L244, C29]: {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L244, C30]: 0000 1000
      │   │   │   │   └─ BitsStr: 0000 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L244, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L244, C56]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L244, C69]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L244, C81]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L244, C95]: off32 as offsetValue
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L244, C117]: {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L244, C117]: {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L245, C9]: when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L245, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L245, C23]: {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L246, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L246, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L246, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L246, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L246, C21]: ptr + offsetValue
      │   │   │       │   │           │       ├─ Operator: Sum
      │   │   │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L246, C21]: ptr
      │   │   │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L246, C27]: offsetValue
      │   │   │       │   │           │     
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L246, C42]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L246, C42]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L246, C49]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L247, C16]: when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L247, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L247, C31]: {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L248, C13]: dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L248, C13]: dataM:8[ptr + offsetValue] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L248, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L248, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnBinaryExprSyntaxNode at [L248, C21]: ptr + offsetValue
      │   │   │       │       │           │       ├─ Operator: Sum
      │   │   │       │       │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L248, C21]: ptr
      │   │   │       │       │           │       └─ ArchInsnPlaceExprSyntaxNode at [L248, C27]: offsetValue
      │   │   │       │       │           │     
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L248, C42]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L248, C42]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L248, C49]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L249, C16]: when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L249, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L249, C31]: {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L250, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L250, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L250, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L250, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnBinaryExprSyntaxNode at [L250, C21]: ptr + offsetValue
      │   │   │       │           │           │       ├─ Operator: Sum
      │   │   │       │           │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L250, C21]: ptr
      │   │   │       │           │           │       └─ ArchInsnPlaceExprSyntaxNode at [L250, C27]: offsetValue
      │   │   │       │           │           │     
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L250, C42]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L250, C42]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L250, C49]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L251, C16]: when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L251, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L251, C31]: {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L252, C13]: dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L252, C13]: dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L252, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L252, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnBinaryExprSyntaxNode at [L252, C21]: ptr + offsetValue
      │   │   │       │               │           │       ├─ Operator: Sum
      │   │   │       │               │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L252, C21]: ptr
      │   │   │       │               │           │       └─ ArchInsnPlaceExprSyntaxNode at [L252, C27]: offsetValue
      │   │   │       │               │           │     
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L252, C42]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L252, C42]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L252, C49]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L254, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L254, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L254, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L254, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L254, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L254, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L257, C5]: instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L257, C24]: {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L257, C25]: 0000 1001
      │   │   │   │   └─ BitsStr: 0000 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L257, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L257, C40]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L257, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L257, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L257, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L257, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L258, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L258, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L258, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L258, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L258, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L258, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L259, C9]: dataM:8[SP] = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L259, C9]: dataM:8[SP] = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L259, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L259, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L259, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L259, C23]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L260, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L260, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L260, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L260, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L260, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L260, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: push
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L263, C5]: instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L263, C23]: {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L263, C24]: 0000 1010
      │   │   │   │   └─ BitsStr: 0000 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L263, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L263, C39]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L263, C50]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L263, C58]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L263, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L263, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L264, C9]: to = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L264, C9]: to = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L264, C9]: to
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L264, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L264, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L264, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L265, C9]: SP = SP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L265, C9]: SP = SP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L265, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L265, C14]: SP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L265, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L265, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L266, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L266, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L266, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L266, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L266, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L266, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: pop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L269, C5]: instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L269, C23]: {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L269, C24]: 0000 1011
      │   │   │   │   └─ BitsStr: 0000 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L269, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L269, C39]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L269, C50]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L269, C63]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L269, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L269, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L270, C9]: to = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L270, C9]: to = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L270, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L270, C14]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L271, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L271, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L271, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L271, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L271, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L271, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L276, C5]: instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L276, C29]: {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L276, C30]: 0000 1100
      │   │   │   │   └─ BitsStr: 0000 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L276, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L276, C56]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L276, C67]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L276, C80]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L276, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L276, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L277, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L277, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L277, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L278, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L278, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L278, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L278, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L278, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L278, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L279, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L279, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L279, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L280, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L280, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L280, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L280, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L280, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L280, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L281, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L281, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L281, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L282, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L282, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L282, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L282, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L282, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L282, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L283, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L283, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L283, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L284, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L284, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L284, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L284, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L284, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L284, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L286, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L286, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L286, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L286, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L286, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L286, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-trunc
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L291, C5]: instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L291, C26]: {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L291, C27]: 0000 1101
      │   │   │   │   └─ BitsStr: 0000 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L291, C38]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L291, C53]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L291, C64]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L291, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L291, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L291, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L292, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L292, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L292, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L293, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L293, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L293, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L293, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L293, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L293, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L294, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L294, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L294, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L295, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L295, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L295, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L295, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L295, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L295, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L296, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L296, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L296, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L297, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L297, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L297, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L297, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L297, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L297, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L298, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L298, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L298, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L299, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L299, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L299, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L299, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L299, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L299, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L301, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L301, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L301, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L301, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L301, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L301, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-zx
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L304, C5]: instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L304, C31]: {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L304, C32]: 0000 1110
      │   │   │   │   └─ BitsStr: 0000 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L304, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L304, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L304, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L304, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L304, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L304, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L305, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L305, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L305, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L305, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L305, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L305, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L305, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L306, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L306, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L306, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L306, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L307, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L307, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L307, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L307, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L307, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L307, C35]: {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L308, C13]: let ext_mask = 0x000000000000ff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L308, C28]: 0x000000000000ff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x000000000000ff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L309, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L309, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L309, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L309, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L309, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L309, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L310, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L311, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L311, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L311, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L311, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L313, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L313, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L313, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L313, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L313, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L313, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-w
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L316, C5]: instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L316, C31]: {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L316, C32]: 0000 1111
      │   │   │   │   └─ BitsStr: 0000 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L316, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L316, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L316, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L316, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L316, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L316, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L317, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L317, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L317, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L317, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L317, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L317, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L317, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L318, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L318, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L318, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L318, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L319, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L319, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L319, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L319, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L319, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L319, C35]: {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L320, C13]: let ext_mask = 0x00000000ffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L320, C28]: 0x00000000ffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L321, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L321, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L321, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L321, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L321, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L321, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L322, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L323, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L323, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L323, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L323, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L325, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L325, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L325, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L325, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L325, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L325, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L328, C5]: instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L328, C31]: {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L328, C32]: 0001 0000
      │   │   │   │   └─ BitsStr: 0001 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L328, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L328, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L328, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L328, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L328, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L328, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L329, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L329, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L329, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L329, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L329, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L329, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L329, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L330, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L330, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L330, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L330, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L331, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L331, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L331, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L331, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L331, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L331, C35]: {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L332, C13]: let ext_mask = 0xffffffffffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L332, C28]: 0xffffffffffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L333, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L333, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L333, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L333, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L333, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L333, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L334, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L335, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L335, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L335, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L335, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L337, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L337, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L337, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L337, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L337, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L337, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L340, C5]: instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L340, C31]: {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L340, C32]: 0001 0001
      │   │   │   │   └─ BitsStr: 0001 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L340, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L340, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L340, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L340, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L340, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L340, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L341, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L341, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L341, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L341, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L341, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L341, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L341, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L342, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L342, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L342, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L342, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L343, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L343, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L343, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L343, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L343, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L343, C35]: {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L344, C13]: let ext_mask = 0x00000000ffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L344, C28]: 0x00000000ffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L345, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L345, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L345, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L345, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L345, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L345, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L346, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L347, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L347, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L347, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L347, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L349, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L349, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L349, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L349, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L349, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L349, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L352, C5]: instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L352, C31]: {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L352, C32]: 0001 0010
      │   │   │   │   └─ BitsStr: 0001 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L352, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L352, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L352, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L352, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L352, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L352, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L353, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L353, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L353, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L353, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L353, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L353, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L353, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L354, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L354, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L354, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L354, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L355, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L355, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L355, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L355, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L355, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L355, C35]: {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L356, C13]: let ext_mask = 0xffffffffffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L356, C28]: 0xffffffffffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L357, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L357, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L357, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L357, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L357, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L357, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L358, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L359, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L359, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L359, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L359, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L361, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L361, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L361, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L361, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L361, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L361, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L365, C5]: instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L365, C31]: {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L365, C32]: 0001 0011
      │   │   │   │   └─ BitsStr: 0001 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L365, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L365, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L365, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L365, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L365, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L365, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L366, C9]: let sign_bit = (from >> 31) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L366, C24]: (from >> 31) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L366, C24]: (from >> 31)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L366, C25]: from >> 31
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L366, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L366, C33]: 31
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 31
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L366, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L367, C9]: let from_masked = from & 0xffffffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L367, C27]: from & 0xffffffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L367, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L367, C34]: 0xffffffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffffffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L368, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L368, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L368, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L368, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L368, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L368, C35]: {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L369, C13]: let ext_mask = 0xffffffff00000000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L369, C28]: 0xffffffff00000000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffff00000000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L370, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L370, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L370, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L370, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L370, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L370, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L371, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L372, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L372, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L372, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L372, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L374, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L374, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L374, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L374, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L374, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L374, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-d-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L377, C5]: instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L377, C23]: {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L377, C24]: 0001 0100
      │   │   │   │   └─ BitsStr: 0001 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L377, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L377, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L377, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L377, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L377, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L377, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L378, C9]: when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L378, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L378, C23]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L379, C13]: let res = reg1 - reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L379, C23]: reg1 - reg2
      │   │   │       │   │   │       ├─ Operator: Sub
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L379, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L379, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L380, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L380, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L381, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L381, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L381, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L381, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L381, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L381, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L382, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L382, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L382, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L382, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L382, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L382, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L382, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L382, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L382, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L383, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L383, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L383, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L383, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L383, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L383, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L383, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L383, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L383, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L384, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L384, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L384, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L384, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L384, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L384, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L384, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L384, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L384, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L384, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L384, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L384, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L384, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L384, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L384, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L384, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L384, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L384, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L385, C16]: when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L385, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L385, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L386, C13]: let res = reg1 - reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L386, C23]: reg1 - reg2
      │   │   │       │       │   │       ├─ Operator: Sub
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L386, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L386, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L387, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L387, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L388, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L388, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L388, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L388, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L388, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L388, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L389, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L389, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L389, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L389, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L389, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L389, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L389, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L389, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L389, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L390, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L390, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L390, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L390, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L390, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L390, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L390, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L390, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L390, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L391, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L391, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L391, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L391, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L391, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L391, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L391, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L391, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L391, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L391, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L391, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L391, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L391, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L391, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L391, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L391, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L391, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L391, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L392, C16]: when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L392, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L392, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L393, C13]: let res = reg1 - reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L393, C23]: reg1 - reg2
      │   │   │       │           │   │       ├─ Operator: Sub
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L393, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L393, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L394, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L394, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L395, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L395, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L395, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L395, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L395, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L395, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L396, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L396, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L396, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L396, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L396, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L396, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L396, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L396, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L396, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L397, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L397, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L397, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L397, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L397, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L397, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L397, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L397, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L397, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L398, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L398, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L398, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L398, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L398, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L398, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L398, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L398, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L398, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L398, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L398, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L398, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L398, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L398, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L398, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L398, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L398, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L398, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L399, C16]: when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L399, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L399, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L400, C13]: let res = reg1 - reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L400, C23]: reg1 - reg2
      │   │   │       │               │   │       ├─ Operator: Sub
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L400, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L400, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L401, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L401, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L402, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L402, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L402, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L402, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L402, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L402, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L403, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L403, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L403, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L403, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L403, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L403, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L403, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L403, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L403, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L404, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L404, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L404, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L404, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L404, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L404, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L404, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L404, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L404, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L405, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L405, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L405, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L405, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L405, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L405, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L405, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L405, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L405, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L405, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L405, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L405, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L405, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L405, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L405, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L405, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L405, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L405, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L408, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L408, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L408, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L408, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L408, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L408, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L409, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L409, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L409, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L409, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L410, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L411, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L411, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L411, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L411, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L414, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L414, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L414, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L414, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L414, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L414, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: sub
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L417, C5]: instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L417, C23]: {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L417, C24]: 0001 0101
      │   │   │   │   └─ BitsStr: 0001 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L417, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L417, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L417, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L417, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L417, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L417, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L418, C9]: when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L418, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L418, C23]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L419, C13]: let res = reg1 * reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L419, C23]: reg1 * reg2
      │   │   │       │   │   │       ├─ Operator: Mul
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L419, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L419, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L420, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L420, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L420, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L420, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L420, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L420, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L421, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L421, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L421, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L421, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L421, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L421, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L421, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L421, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L421, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L422, C16]: when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L422, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L422, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L423, C13]: let res = reg1 * reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L423, C23]: reg1 * reg2
      │   │   │       │       │   │       ├─ Operator: Mul
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L423, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L423, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L424, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L424, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L424, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L424, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L424, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L424, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L425, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L425, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L425, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L425, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L425, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L425, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L425, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L425, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L425, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L426, C16]: when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L426, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L426, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L427, C13]: let res = reg1 * reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L427, C23]: reg1 * reg2
      │   │   │       │           │   │       ├─ Operator: Mul
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L427, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L427, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L428, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L428, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L428, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L428, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L428, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L428, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L429, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L429, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L429, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L429, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L429, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L429, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L429, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L429, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L429, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L430, C16]: when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L430, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L430, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L431, C13]: let res = reg1 * reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L431, C23]: reg1 * reg2
      │   │   │       │               │   │       ├─ Operator: Mul
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L431, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L431, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L432, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L432, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L432, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L432, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L432, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L432, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L433, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L433, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L433, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L433, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L433, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L433, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L433, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L433, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L433, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L436, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L436, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L436, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L436, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L436, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L436, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L437, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L437, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L437, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L437, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L438, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L439, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L439, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L439, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L439, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L442, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L442, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L442, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L442, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L442, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L442, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mul
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L445, C5]: instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L445, C23]: {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L445, C24]: 0001 0110
      │   │   │   │   └─ BitsStr: 0001 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L445, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L445, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L445, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L445, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L445, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L445, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L446, C9]: when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L446, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L446, C23]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L447, C13]: let res = reg1 / reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L447, C23]: reg1 / reg2
      │   │   │       │   │   │       ├─ Operator: Div
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L447, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L447, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L448, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L448, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L448, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L448, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L448, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L448, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L449, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L449, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L449, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L449, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L449, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L449, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L449, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L449, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L449, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L450, C16]: when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L450, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L450, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L451, C13]: let res = reg1 / reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L451, C23]: reg1 / reg2
      │   │   │       │       │   │       ├─ Operator: Div
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L451, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L451, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L452, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L452, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L452, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L452, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L452, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L452, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L453, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L453, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L453, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L453, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L453, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L453, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L453, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L453, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L453, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L454, C16]: when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L454, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L454, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L455, C13]: let res = reg1 / reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L455, C23]: reg1 / reg2
      │   │   │       │           │   │       ├─ Operator: Div
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L455, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L455, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L456, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L456, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L456, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L456, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L456, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L456, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L457, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L457, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L457, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L457, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L457, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L457, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L457, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L457, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L457, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L458, C16]: when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L458, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L458, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L459, C13]: let res = reg1 / reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L459, C23]: reg1 / reg2
      │   │   │       │               │   │       ├─ Operator: Div
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L459, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L459, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L460, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L460, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L460, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L460, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L460, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L460, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L461, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L461, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L461, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L461, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L461, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L461, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L461, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L461, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L461, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L464, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L464, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L464, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L464, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L464, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L464, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L465, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L465, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L465, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L465, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L466, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L467, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L467, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L467, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L467, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L470, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L470, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L470, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L470, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L470, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L470, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: div
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L473, C5]: instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L473, C23]: {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L473, C24]: 0001 0111
      │   │   │   │   └─ BitsStr: 0001 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L473, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L473, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L473, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L473, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L473, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L473, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L474, C9]: when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L474, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L474, C23]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L475, C13]: let res = reg1 % reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L475, C23]: reg1 % reg2
      │   │   │       │   │   │       ├─ Operator: Mod
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L475, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L475, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L476, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L476, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L476, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L476, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L476, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L476, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L477, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L477, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L477, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L477, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L477, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L477, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L477, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L477, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L477, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L478, C16]: when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L478, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L478, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L479, C13]: let res = reg1 % reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L479, C23]: reg1 % reg2
      │   │   │       │       │   │       ├─ Operator: Mod
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L479, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L479, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L480, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L480, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L480, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L480, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L480, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L480, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L481, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L481, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L481, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L481, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L481, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L481, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L481, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L481, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L481, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L482, C16]: when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L482, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L482, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L483, C13]: let res = reg1 % reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L483, C23]: reg1 % reg2
      │   │   │       │           │   │       ├─ Operator: Mod
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L483, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L483, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L484, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L484, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L484, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L484, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L484, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L484, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L485, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L485, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L485, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L485, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L485, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L485, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L485, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L485, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L485, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L486, C16]: when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L486, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L486, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L487, C13]: let res = reg1 % reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L487, C23]: reg1 % reg2
      │   │   │       │               │   │       ├─ Operator: Mod
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L487, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L487, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L488, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L488, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L488, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L488, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L488, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L488, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L489, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L489, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L489, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L489, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L489, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L489, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L489, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L489, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L489, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L492, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L492, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L492, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L492, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L492, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L492, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L493, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L493, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L493, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L493, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L494, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L495, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L495, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L495, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L495, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L498, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L498, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L498, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L498, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L498, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L498, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mod
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L501, C5]: instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L501, C23]: {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L501, C24]: 0001 1000
      │   │   │   │   └─ BitsStr: 0001 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L501, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L501, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L501, C63]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L501, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L501, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L501, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L502, C9]: when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L502, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L502, C23]: {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L503, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L503, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L504, C13]: if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L504, C16]: (reg1 == 0x80)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L504, C17]: reg1 == 0x80
      │   │   │       │   │   │   │       ├─ Operator: Equal
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L504, C17]: reg1
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L504, C25]: 0x80
      │   │   │       │   │   │   │           ├─ Kind: Hex
      │   │   │       │   │   │   │           └─ ValueString: 0x80
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L504, C36]: {\n                V = 1;\n            }
      │   │   │       │   │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L505, C17]: V = 1;
      │   │   │       │   │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L505, C17]: V = 1
      │   │   │       │   │   │   │           ├─ Operator: Assign
      │   │   │       │   │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L505, C17]: V
      │   │   │       │   │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L505, C21]: 1
      │   │   │       │   │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │   │               └─ ValueString: 1
      │   │   │       │   │   │   │             
      │   │   │       │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L506, C20]: {\n                V = 0;\n            }
      │   │   │       │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L507, C17]: V = 0;
      │   │   │       │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L507, C17]: V = 0
      │   │   │       │   │   │               ├─ Operator: Assign
      │   │   │       │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L507, C17]: V
      │   │   │       │   │   │               └─ ArchInsnLiteralExprSyntaxNode at [L507, C21]: 0
      │   │   │       │   │   │                   ├─ Kind: Dec
      │   │   │       │   │   │                   └─ ValueString: 0
      │   │   │       │   │   │                 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L509, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L509, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L509, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L509, C20]: ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L509, C20]: ((~res) + 1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L509, C21]: (~res) + 1
      │   │   │       │   │   │           │       ├─ Operator: Sum
      │   │   │       │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L509, C21]: (~res)
      │   │   │       │   │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L509, C22]: ~res
      │   │   │       │   │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L509, C23]: res
      │   │   │       │   │   │           │       │       └─ IsPrefix: True
      │   │   │       │   │   │           │       │     
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L509, C30]: 1
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 1
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L509, C35]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L510, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L510, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L510, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L510, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L510, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L510, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L510, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L510, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L510, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L511, C16]: when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L511, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L511, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L512, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L512, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L513, C13]: if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │       │   │   ├─ ArchInsnBracesExprSyntaxNode at [L513, C16]: (reg1 == 0x8000)
      │   │   │       │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L513, C17]: reg1 == 0x8000
      │   │   │       │       │   │   │       ├─ Operator: Equal
      │   │   │       │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L513, C17]: reg1
      │   │   │       │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L513, C25]: 0x8000
      │   │   │       │       │   │   │           ├─ Kind: Hex
      │   │   │       │       │   │   │           └─ ValueString: 0x8000
      │   │   │       │       │   │   │         
      │   │   │       │       │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L513, C38]: {\n                V = 1;\n            }
      │   │   │       │       │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L514, C17]: V = 1;
      │   │   │       │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L514, C17]: V = 1
      │   │   │       │       │   │   │           ├─ Operator: Assign
      │   │   │       │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L514, C17]: V
      │   │   │       │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L514, C21]: 1
      │   │   │       │       │   │   │               ├─ Kind: Dec
      │   │   │       │       │   │   │               └─ ValueString: 1
      │   │   │       │       │   │   │             
      │   │   │       │       │   │   └─ ArchInsnBlockStmtSyntaxNode at [L515, C20]: {\n                V = 0;\n            }
      │   │   │       │       │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L516, C17]: V = 0;
      │   │   │       │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L516, C17]: V = 0
      │   │   │       │       │   │               ├─ Operator: Assign
      │   │   │       │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L516, C17]: V
      │   │   │       │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L516, C21]: 0
      │   │   │       │       │   │                   ├─ Kind: Dec
      │   │   │       │       │   │                   └─ ValueString: 0
      │   │   │       │       │   │                 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L518, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L518, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L518, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L518, C20]: ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L518, C20]: ((~res) + 1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L518, C21]: (~res) + 1
      │   │   │       │       │   │           │       ├─ Operator: Sum
      │   │   │       │       │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L518, C21]: (~res)
      │   │   │       │       │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L518, C22]: ~res
      │   │   │       │       │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │       │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L518, C23]: res
      │   │   │       │       │   │           │       │       └─ IsPrefix: True
      │   │   │       │       │   │           │       │     
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L518, C30]: 1
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 1
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L518, C35]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L519, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L519, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L519, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L519, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L519, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L519, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L519, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L519, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L519, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L520, C16]: when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L520, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L520, C31]: {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L521, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L521, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L522, C13]: if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │           │   │   ├─ ArchInsnBracesExprSyntaxNode at [L522, C16]: (reg1 == 0x80000000)
      │   │   │       │           │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L522, C17]: reg1 == 0x80000000
      │   │   │       │           │   │   │       ├─ Operator: Equal
      │   │   │       │           │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L522, C17]: reg1
      │   │   │       │           │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L522, C25]: 0x80000000
      │   │   │       │           │   │   │           ├─ Kind: Hex
      │   │   │       │           │   │   │           └─ ValueString: 0x80000000
      │   │   │       │           │   │   │         
      │   │   │       │           │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L522, C42]: {\n                V = 1;\n            }
      │   │   │       │           │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L523, C17]: V = 1;
      │   │   │       │           │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L523, C17]: V = 1
      │   │   │       │           │   │   │           ├─ Operator: Assign
      │   │   │       │           │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L523, C17]: V
      │   │   │       │           │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L523, C21]: 1
      │   │   │       │           │   │   │               ├─ Kind: Dec
      │   │   │       │           │   │   │               └─ ValueString: 1
      │   │   │       │           │   │   │             
      │   │   │       │           │   │   └─ ArchInsnBlockStmtSyntaxNode at [L524, C20]: {\n                V = 0;\n            }
      │   │   │       │           │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L525, C17]: V = 0;
      │   │   │       │           │   │           └─ ArchInsnBinaryExprSyntaxNode at [L525, C17]: V = 0
      │   │   │       │           │   │               ├─ Operator: Assign
      │   │   │       │           │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L525, C17]: V
      │   │   │       │           │   │               └─ ArchInsnLiteralExprSyntaxNode at [L525, C21]: 0
      │   │   │       │           │   │                   ├─ Kind: Dec
      │   │   │       │           │   │                   └─ ValueString: 0
      │   │   │       │           │   │                 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L527, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L527, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L527, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L527, C20]: ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L527, C20]: ((~res) + 1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L527, C21]: (~res) + 1
      │   │   │       │           │   │           │       ├─ Operator: Sum
      │   │   │       │           │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L527, C21]: (~res)
      │   │   │       │           │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L527, C22]: ~res
      │   │   │       │           │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │           │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L527, C23]: res
      │   │   │       │           │   │           │       │       └─ IsPrefix: True
      │   │   │       │           │   │           │       │     
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L527, C30]: 1
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 1
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L527, C35]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L528, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L528, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L528, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L528, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L528, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L528, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L528, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L528, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L528, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L529, C16]: when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L529, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L529, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L530, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L530, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L531, C13]: if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │               │   │   ├─ ArchInsnBracesExprSyntaxNode at [L531, C16]: (reg1 == 0x8000000000000000)
      │   │   │       │               │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L531, C17]: reg1 == 0x8000000000000000
      │   │   │       │               │   │   │       ├─ Operator: Equal
      │   │   │       │               │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L531, C17]: reg1
      │   │   │       │               │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L531, C25]: 0x8000000000000000
      │   │   │       │               │   │   │           ├─ Kind: Hex
      │   │   │       │               │   │   │           └─ ValueString: 0x8000000000000000
      │   │   │       │               │   │   │         
      │   │   │       │               │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L531, C50]: {\n                V = 1;\n            }
      │   │   │       │               │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L532, C17]: V = 1;
      │   │   │       │               │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L532, C17]: V = 1
      │   │   │       │               │   │   │           ├─ Operator: Assign
      │   │   │       │               │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L532, C17]: V
      │   │   │       │               │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L532, C21]: 1
      │   │   │       │               │   │   │               ├─ Kind: Dec
      │   │   │       │               │   │   │               └─ ValueString: 1
      │   │   │       │               │   │   │             
      │   │   │       │               │   │   └─ ArchInsnBlockStmtSyntaxNode at [L533, C20]: {\n                V = 0;\n            }
      │   │   │       │               │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L534, C17]: V = 0;
      │   │   │       │               │   │           └─ ArchInsnBinaryExprSyntaxNode at [L534, C17]: V = 0
      │   │   │       │               │   │               ├─ Operator: Assign
      │   │   │       │               │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L534, C17]: V
      │   │   │       │               │   │               └─ ArchInsnLiteralExprSyntaxNode at [L534, C21]: 0
      │   │   │       │               │   │                   ├─ Kind: Dec
      │   │   │       │               │   │                   └─ ValueString: 0
      │   │   │       │               │   │                 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L536, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L536, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L536, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L536, C20]: ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L536, C20]: ((~res) + 1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L536, C21]: (~res) + 1
      │   │   │       │               │   │           │       ├─ Operator: Sum
      │   │   │       │               │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L536, C21]: (~res)
      │   │   │       │               │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L536, C22]: ~res
      │   │   │       │               │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │               │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L536, C23]: res
      │   │   │       │               │   │           │       │       └─ IsPrefix: True
      │   │   │       │               │   │           │       │     
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L536, C30]: 1
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 1
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L536, C35]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L537, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L537, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L537, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L537, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L537, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L537, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L537, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L537, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L537, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L540, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L540, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L540, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L540, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L540, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L540, C31]: {\n            Z = 1;\n            C = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L541, C13]: Z = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L541, C13]: Z = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L541, C13]: Z
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L541, C17]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L542, C13]: C = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L542, C13]: C = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L542, C13]: C
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L542, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L543, C16]: {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L544, C13]: Z = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L544, C13]: Z = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L544, C13]: Z
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L544, C17]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L545, C13]: C = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L545, C13]: C = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L545, C13]: C
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L545, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L548, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L548, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L548, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L548, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L548, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L548, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neg
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L551, C5]: instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L551, C25]: {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L551, C26]: 0001 1001
      │   │   │   │   └─ BitsStr: 0001 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L551, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L551, C52]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L551, C65]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L551, C73]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L551, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L551, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L552, C9]: when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L552, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L552, C23]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L553, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L553, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L554, C13]: reg1 = (~res) & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L554, C13]: reg1 = (~res) & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L554, C13]: reg1
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L554, C20]: (~res) & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L554, C20]: (~res)
      │   │   │       │   │               │   └─ ArchInsnUnaryExprSyntaxNode at [L554, C21]: ~res
      │   │   │       │   │               │       ├─ Operator: BitsInv
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L554, C22]: res
      │   │   │       │   │               │       └─ IsPrefix: True
      │   │   │       │   │               │     
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L554, C29]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L555, C16]: when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L555, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L555, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L556, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L556, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L557, C13]: reg1 = (~res) & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L557, C13]: reg1 = (~res) & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L557, C13]: reg1
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L557, C20]: (~res) & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L557, C20]: (~res)
      │   │   │       │       │               │   └─ ArchInsnUnaryExprSyntaxNode at [L557, C21]: ~res
      │   │   │       │       │               │       ├─ Operator: BitsInv
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L557, C22]: res
      │   │   │       │       │               │       └─ IsPrefix: True
      │   │   │       │       │               │     
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L557, C29]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L558, C16]: when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L558, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L558, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L559, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L559, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L560, C13]: reg1 = (~res) & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L560, C13]: reg1 = (~res) & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L560, C13]: reg1
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L560, C20]: (~res) & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L560, C20]: (~res)
      │   │   │       │           │               │   └─ ArchInsnUnaryExprSyntaxNode at [L560, C21]: ~res
      │   │   │       │           │               │       ├─ Operator: BitsInv
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L560, C22]: res
      │   │   │       │           │               │       └─ IsPrefix: True
      │   │   │       │           │               │     
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L560, C29]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L561, C16]: when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L561, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L561, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L562, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L562, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L563, C13]: reg1 = (~res) & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L563, C13]: reg1 = (~res) & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L563, C13]: reg1
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L563, C20]: (~res) & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L563, C20]: (~res)
      │   │   │       │               │               │   └─ ArchInsnUnaryExprSyntaxNode at [L563, C21]: ~res
      │   │   │       │               │               │       ├─ Operator: BitsInv
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L563, C22]: res
      │   │   │       │               │               │       └─ IsPrefix: True
      │   │   │       │               │               │     
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L563, C29]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L566, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L566, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L566, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L566, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L566, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L566, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: not-i
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L569, C5]: instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L569, C23]: {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L569, C24]: 0001 1010
      │   │   │   │   └─ BitsStr: 0001 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L569, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L569, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L569, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L569, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L569, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L569, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L570, C9]: when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L570, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L570, C23]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L571, C13]: let res = reg1 & reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L571, C23]: reg1 & reg2
      │   │   │       │   │   │       ├─ Operator: BitsAnd
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L571, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L571, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L572, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L572, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L572, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L572, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L572, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L572, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L573, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L573, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L573, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L573, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L573, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L573, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L573, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L573, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L573, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L574, C16]: when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L574, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L574, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L575, C13]: let res = reg1 & reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L575, C23]: reg1 & reg2
      │   │   │       │       │   │       ├─ Operator: BitsAnd
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L575, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L575, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L576, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L576, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L576, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L576, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L576, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L576, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L577, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L577, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L577, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L577, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L577, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L577, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L577, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L577, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L577, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L578, C16]: when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L578, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L578, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L579, C13]: let res = reg1 & reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L579, C23]: reg1 & reg2
      │   │   │       │           │   │       ├─ Operator: BitsAnd
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L579, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L579, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L580, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L580, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L580, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L580, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L580, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L580, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L581, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L581, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L581, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L581, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L581, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L581, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L581, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L581, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L581, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L582, C16]: when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L582, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L582, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L583, C13]: let res = reg1 & reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L583, C23]: reg1 & reg2
      │   │   │       │               │   │       ├─ Operator: BitsAnd
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L583, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L583, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L584, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L584, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L584, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L584, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L584, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L584, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L585, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L585, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L585, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L585, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L585, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L585, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L585, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L585, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L585, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L588, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L588, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L588, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L588, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L588, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L588, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L589, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L589, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L589, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L589, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L590, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L591, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L591, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L591, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L591, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L594, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L594, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L594, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L594, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L594, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L594, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L597, C5]: instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L597, C22]: {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L597, C23]: 0001 1011
      │   │   │   │   └─ BitsStr: 0001 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L597, C34]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L597, C49]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L597, C62]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L597, C75]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L597, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L597, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L598, C9]: when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L598, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L598, C23]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L599, C13]: let res = reg1 | reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L599, C23]: reg1 | reg2
      │   │   │       │   │   │       ├─ Operator: BitsOr
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L599, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L599, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L600, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L600, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L600, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L600, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L600, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L600, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L601, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L601, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L601, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L601, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L601, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L601, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L601, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L601, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L601, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L602, C16]: when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L602, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L602, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L603, C13]: let res = reg1 | reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L603, C23]: reg1 | reg2
      │   │   │       │       │   │       ├─ Operator: BitsOr
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L603, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L603, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L604, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L604, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L604, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L604, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L604, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L604, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L605, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L605, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L605, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L605, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L605, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L605, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L605, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L605, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L605, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L606, C16]: when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L606, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L606, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L607, C13]: let res = reg1 | reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L607, C23]: reg1 | reg2
      │   │   │       │           │   │       ├─ Operator: BitsOr
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L607, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L607, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L608, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L608, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L608, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L608, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L608, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L608, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L609, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L609, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L609, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L609, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L609, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L609, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L609, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L609, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L609, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L610, C16]: when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L610, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L610, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L611, C13]: let res = reg1 | reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L611, C23]: reg1 | reg2
      │   │   │       │               │   │       ├─ Operator: BitsOr
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L611, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L611, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L612, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L612, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L612, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L612, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L612, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L612, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L613, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L613, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L613, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L613, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L613, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L613, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L613, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L613, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L613, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L616, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L616, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L616, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L616, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L616, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L616, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L617, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L617, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L617, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L617, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L618, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L619, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L619, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L619, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L619, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L622, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L622, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L622, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L622, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L622, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L622, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L625, C5]: instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L625, C22]: {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C23]: 0001 1100
      │   │   │   │   └─ BitsStr: 0001 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C46]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C54]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L625, C68]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L625, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L625, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L626, C9]: if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L626, C12]: (Z == 0x1)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L626, C13]: Z == 0x1
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L626, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L626, C18]: 0x1
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x1
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L626, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L627, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L627, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L627, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L627, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L628, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L629, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L629, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L629, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L629, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L629, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L629, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L633, C5]: instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L633, C23]: {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C24]: 0001 1101
      │   │   │   │   └─ BitsStr: 0001 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L633, C69]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L633, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L633, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L634, C9]: if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L634, C12]: (Z == 0x0)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L634, C13]: Z == 0x0
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L634, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L634, C18]: 0x0
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x0
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L634, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L635, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L635, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L635, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L635, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L636, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L637, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L637, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L637, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L637, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L637, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L637, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jnz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L641, C5]: instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L641, C23]: {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C24]: 0001 1110
      │   │   │   │   └─ BitsStr: 0001 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L641, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L641, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L641, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L641, C95]: {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L641, C95]: {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L642, C9]: if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L642, C12]: (reg1 == reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L642, C13]: reg1 == reg2
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L642, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L642, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L642, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L643, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L643, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L643, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L643, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L644, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L645, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L645, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L645, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L645, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L645, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L645, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L649, C5]: instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L649, C24]: {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C25]: 0001 1111
      │   │   │   │   └─ BitsStr: 0001 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L649, C40]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L649, C53]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C66]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L649, C80]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L649, C96]: {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L649, C96]: {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L650, C9]: if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L650, C12]: (reg1 != reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L650, C13]: reg1 != reg2
      │   │   │           │       ├─ Operator: NotEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L650, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L650, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L650, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L651, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L651, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L651, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L651, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L652, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L653, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L653, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L653, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L653, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L653, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L653, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jneq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L657, C5]: instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L657, C23]: {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C24]: 0010 0000
      │   │   │   │   └─ BitsStr: 0010 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L657, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L657, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L657, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L657, C95]: {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L657, C95]: {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L658, C9]: if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L658, C12]: (reg1 > reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L658, C13]: reg1 > reg2
      │   │   │           │       ├─ Operator: Greater
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L658, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L658, C20]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L658, C31]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L659, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L659, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L659, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L659, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L660, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L661, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L661, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L661, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L661, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L661, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L661, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L665, C5]: instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L665, C23]: {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C24]: 0010 0001
      │   │   │   │   └─ BitsStr: 0010 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L665, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L665, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L665, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L665, C95]: {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L665, C95]: {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L666, C9]: if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L666, C12]: (reg1 < reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L666, C13]: reg1 < reg2
      │   │   │           │       ├─ Operator: Less
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L666, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L666, C20]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L666, C31]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L667, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L667, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L667, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L667, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L668, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L669, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L669, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L669, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L669, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L669, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L669, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jle
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L673, C5]: instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L673, C25]: {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C26]: 0010 0010
      │   │   │   │   └─ BitsStr: 0010 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L673, C41]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L673, C54]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C67]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L673, C81]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L673, C97]: {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L673, C97]: {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L674, C9]: if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L674, C12]: (reg1 >= reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L674, C13]: reg1 >= reg2
      │   │   │           │       ├─ Operator: GreaterOrEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L674, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L674, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L674, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L675, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L675, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L675, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L675, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L676, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L677, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L677, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L677, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L677, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L677, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L677, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgreq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L681, C5]: instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L681, C25]: {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C26]: 0010 0011
      │   │   │   │   └─ BitsStr: 0010 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L681, C41]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L681, C54]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C67]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L681, C81]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L681, C97]: {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L681, C97]: {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L682, C9]: if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L682, C12]: (reg1 <= reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L682, C13]: reg1 <= reg2
      │   │   │           │       ├─ Operator: LessOrEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L682, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L682, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L682, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L683, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L683, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L683, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L683, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L684, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L685, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L685, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L685, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L685, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L685, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L685, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jleeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L689, C5]: instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L689, C23]: {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C24]: 0010 0100
      │   │   │   │   └─ BitsStr: 0010 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L689, C69]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L689, C85]: {\n        IP = value;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L689, C85]: {\n        IP = value;\n    }
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L690, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L690, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L690, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L690, C14]: value
      │   │   │             
      │   │   └─ Name: jmp
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L693, C5]: instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L693, C24]: {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L693, C25]: 0010 0101
      │   │   │   │   └─ BitsStr: 0010 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L693, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L693, C40]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L693, C48]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L693, C56]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L693, C70]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L693, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L693, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L694, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L694, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L694, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L694, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L694, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L694, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L695, C9]: dataM:8[SP] = IP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L695, C9]: dataM:8[SP] = IP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L695, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L695, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L695, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L695, C23]: IP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L695, C23]: IP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L695, C28]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L696, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L696, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L696, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L696, C14]: value
      │   │   │             
      │   │   └─ Name: call
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L699, C5]: instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L699, C23]: {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L699, C24]: 0010 0110
      │   │   │   │   └─ BitsStr: 0010 0110
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L699, C35]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L699, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L699, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L700, C9]: IP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L700, C9]: IP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L700, C9]: IP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L700, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L700, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L700, C22]: SP
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L701, C9]: SP = SP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L701, C9]: SP = SP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L701, C9]: SP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L701, C14]: SP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L701, C14]: SP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L701, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: ret
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L704, C5]: instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L704, C25]: {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C26]: 0010 0111
      │   │   │   │   └─ BitsStr: 0010 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L704, C71]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L704, C87]: {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L704, C87]: {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L705, C9]: SP = SP - (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L705, C9]: SP = SP - (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L705, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L705, C14]: SP - (8 * value)
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L705, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L705, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L705, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L705, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L705, C24]: value
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L706, C9]: dataM:8[SP] = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L706, C9]: dataM:8[SP] = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L706, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L706, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L706, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L706, C23]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L707, C9]: BP = SP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L707, C9]: BP = SP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L707, C9]: BP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L707, C14]: SP
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L708, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L708, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L708, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L708, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L708, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L708, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: enter
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L711, C5]: instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L711, C25]: {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L711, C26]: 0010 1000
      │   │   │   │   └─ BitsStr: 0010 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L711, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L711, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L711, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L711, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L711, C71]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L711, C87]: {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L711, C87]: {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L712, C9]: SP = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L712, C9]: SP = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L712, C9]: SP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L712, C14]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L713, C9]: BP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L713, C9]: BP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L713, C9]: BP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L713, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L713, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L713, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L714, C9]: SP = SP + (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L714, C9]: SP = SP + (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L714, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L714, C14]: SP + (8 * value)
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L714, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L714, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L714, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L714, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L714, C24]: value
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L715, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L715, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L715, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L715, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L715, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L715, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leave
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L718, C5]: instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L718, C30]: {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L718, C31]: 0010 1001
      │   │   │   │   └─ BitsStr: 0010 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L718, C42]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L718, C46]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L718, C57]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L718, C69]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L718, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L718, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L719, C9]: let res = constantsM:8[ptr];
      │   │   │       │   ├─ Name: res
      │   │   │       │   └─ ArchInsnIndexerExprSyntaxNode at [L719, C19]: constantsM:8[ptr]
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L719, C19]: constantsM:8
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L719, C32]: ptr
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L720, C9]: to = res & 0xffffffffffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L720, C9]: to = res & 0xffffffffffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L720, C9]: to
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L720, C14]: res & 0xffffffffffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L720, C14]: res
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L720, C20]: 0xffffffffffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L721, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L721, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L721, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L721, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L721, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L721, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-const
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L724, C5]: instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L724, C22]: {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L724, C23]: 0010 1010
      │   │   │   │   └─ BitsStr: 0010 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L724, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L724, C38]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L724, C51]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L724, C64]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L724, C118]: {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L724, C118]: {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L725, C9]: if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L725, C12]: (reg1 == reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L725, C13]: reg1 == reg2
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L725, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L725, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L725, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L726, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L726, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L726, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L726, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L727, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L727, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L727, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L727, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L728, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L729, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L729, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L729, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L729, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L730, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L730, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L730, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L730, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L732, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L732, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L732, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L732, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L732, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L732, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: eq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L735, C5]: instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L735, C23]: {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L735, C24]: 0010 1011
      │   │   │   │   └─ BitsStr: 0010 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L735, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L735, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L735, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L735, C65]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L735, C119]: {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L735, C119]: {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L736, C9]: if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L736, C12]: (reg1 != reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L736, C13]: reg1 != reg2
      │   │   │       │   │       ├─ Operator: NotEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L736, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L736, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L736, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L737, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L737, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L737, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L737, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L738, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L738, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L738, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L738, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L739, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L740, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L740, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L740, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L740, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L741, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L741, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L741, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L741, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L743, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L743, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L743, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L743, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L743, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L743, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L746, C5]: instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L746, C22]: {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L746, C23]: 0010 1100
      │   │   │   │   └─ BitsStr: 0010 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L746, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L746, C38]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L746, C51]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L746, C64]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L746, C118]: {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L746, C118]: {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L747, C9]: if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L747, C12]: (reg1 > reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L747, C13]: reg1 > reg2
      │   │   │       │   │       ├─ Operator: Greater
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L747, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L747, C20]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L747, C31]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L748, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L748, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L748, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L748, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L749, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L749, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L749, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L749, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L750, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L751, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L751, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L751, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L751, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L752, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L752, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L752, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L752, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L754, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L754, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L754, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L754, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L754, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L754, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: gr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L757, C5]: instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L757, C22]: {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L757, C23]: 0010 1101
      │   │   │   │   └─ BitsStr: 0010 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L757, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L757, C38]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L757, C51]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L757, C64]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L757, C118]: {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L757, C118]: {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L758, C9]: if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L758, C12]: (reg1 < reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L758, C13]: reg1 < reg2
      │   │   │       │   │       ├─ Operator: Less
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L758, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L758, C20]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L758, C31]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L759, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L759, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L759, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L759, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L760, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L760, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L760, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L760, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L761, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L762, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L762, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L762, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L762, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L763, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L763, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L763, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L763, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L765, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L765, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L765, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L765, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L765, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L765, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: le
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L768, C5]: instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L768, C24]: {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L768, C25]: 0010 1110
      │   │   │   │   └─ BitsStr: 0010 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L768, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L768, C40]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L768, C53]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L768, C66]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L768, C120]: {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L768, C120]: {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L769, C9]: if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L769, C12]: (reg1 >= reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L769, C13]: reg1 >= reg2
      │   │   │       │   │       ├─ Operator: GreaterOrEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L769, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L769, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L769, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L770, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L770, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L770, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L770, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L771, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L771, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L771, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L771, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L772, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L773, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L773, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L773, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L773, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L774, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L774, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L774, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L774, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L776, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L776, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L776, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L776, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L776, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L776, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: greq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L779, C5]: instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L779, C24]: {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L779, C25]: 0010 1111
      │   │   │   │   └─ BitsStr: 0010 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L779, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L779, C40]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L779, C53]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L779, C66]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L779, C120]: {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L779, C120]: {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L780, C9]: if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L780, C12]: (reg1 <= reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L780, C13]: reg1 <= reg2
      │   │   │       │   │       ├─ Operator: LessOrEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L780, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L780, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L780, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L781, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L781, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L781, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L781, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L782, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L782, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L782, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L782, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L783, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L784, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L784, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L784, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L784, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L785, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L785, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L785, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L785, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L787, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L787, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L787, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L787, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L787, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L787, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L790, C5]: instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L790, C32]: {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L790, C33]: 0011 0000
      │   │   │   │   └─ BitsStr: 0011 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L790, C44]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L790, C48]: reg as toPtr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: toPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L790, C62]: reg as fromPtr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: fromPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L790, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L790, C92]: imm32 as size
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: size
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L790, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L790, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L791, C9]: let i = size;
      │   │   │       │   ├─ Name: i
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L791, C17]: size
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L792, C9]: let dest = toPtr;
      │   │   │       │   ├─ Name: dest
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L792, C20]: toPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L793, C9]: let src = fromPtr;
      │   │   │       │   ├─ Name: src
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L793, C19]: fromPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnWhileLoopStmtSyntaxNode at [L795, C9]: while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L795, C24]: {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L796, C13]: dataM:8[dest] = constantsM:8[src];
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L796, C13]: dataM:8[dest] = constantsM:8[src]
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnIndexerExprSyntaxNode at [L796, C13]: dataM:8[dest]
      │   │   │       │   │   │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L796, C13]: dataM:8
      │   │   │       │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L796, C21]: dest
      │   │   │       │   │   │       │ 
      │   │   │       │   │   │       └─ ArchInsnIndexerExprSyntaxNode at [L796, C29]: constantsM:8[src]
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L796, C29]: constantsM:8
      │   │   │       │   │   │           └─ ArchInsnPlaceExprSyntaxNode at [L796, C42]: src
      │   │   │       │   │   │         
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L797, C13]: dest = dest + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L797, C13]: dest = dest + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L797, C13]: dest
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L797, C20]: dest + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L797, C20]: dest
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L797, C27]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L798, C13]: src = src + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L798, C13]: src = src + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L798, C13]: src
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L798, C19]: src + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L798, C19]: src
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L798, C25]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L799, C13]: i = i - 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L799, C13]: i = i - 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L799, C13]: i
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L799, C17]: i - 1
      │   │   │       │   │               ├─ Operator: Sub
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L799, C17]: i
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L799, C21]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L795, C15]: i > 0
      │   │   │       │       ├─ Operator: Greater
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L795, C15]: i
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L795, C19]: 0
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 0
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L802, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L802, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L802, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L802, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L802, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L802, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: memcpy-const
      │   │ 
      │   └─ ArchInstructionEncodingSyntaxNode at [L805, C5]: instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │       ├─ ArchIstructionFieldsSequenceSyntaxNode at [L805, C23]: {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │       │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L805, C24]: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │       │       └─ BitsStr: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │       │     
      │       ├─ ArchInstructionFunctionSyntaxNode at [L805, C105]: {\n	}
      │       │   └─ ArchInsnBlockStmtSyntaxNode at [L805, C105]: {\n	}
      │       │ 
      │       └─ Name: hlt
      │     
      ├─ ArchMnemonicsSyntaxNode at [L808, C5]: mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1, reg2) plain2;\n        mnemonic NEQ for neq(reg1, reg2) plain2;\n        mnemonic GR for gr(reg1, reg2) plain2;\n        mnemonic LE for le(reg1, reg2) plain2;\n        mnemonic GREQ for greq(reg1, reg2) plain2;\n        mnemonic LEEQ for leeq(reg1, reg2) plain2;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(reg1, reg2, value) plain3;\n        mnemonic JNEQ for jneq(reg1, reg2, value) plain3;\n        mnemonic JGR for jgr(reg1, reg2, value) plain3;\n        mnemonic JLE for jle(reg1, reg2, value) plain3;\n        mnemonic JGREQ for jgreq(reg1, reg2, value) plain3;\n        mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3;\n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L809, C9]: format plain1 is "{1}"
      │   │   ├─ SingleFormatString: "{1}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain1
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L810, C9]: format plain2 is "{1}, {2}"
      │   │   ├─ SingleFormatString: "{1}, {2}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain2
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L811, C9]: format plain3 is "{1}, {2}, {3}"
      │   │   ├─ SingleFormatString: "{1}, {2}, {3}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain3
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L813, C9]: mnemonic HLT for hlt()
      │   │   └─ Name: HLT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L814, C9]: mnemonic NOP for nop()
      │   │   └─ Name: NOP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L815, C9]: mnemonic RET for ret()
      │   │   └─ Name: RET
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L817, C9]: mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: ADD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L821, C9]: mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: SUB
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L825, C9]: mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MUL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L829, C9]: mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: DIV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L833, C9]: mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MOD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L838, C9]: mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: ST
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L846, C9]: mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: LD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L854, C9]: mnemonic LDI32 for load-imm32(to, value) plain2
      │   │   └─ Name: LDI32
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L855, C9]: mnemonic LDC64 for load-const(to, ptr) plain2
      │   │   └─ Name: LDC64
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L857, C9]: mnemonic PUSH for push(from) plain1
      │   │   └─ Name: PUSH
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L858, C9]: mnemonic POP for pop(to) plain1
      │   │   └─ Name: POP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L860, C9]: mnemonic MOV for mov(to, from) plain2
      │   │   └─ Name: MOV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L861, C9]: mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L865, C9]: mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVZX
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L870, C9]: mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3
      │   │   └─ Name: MEMCPYC
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L872, C9]: mnemonic CBW for convert-b-w(to, from) plain2
      │   │   └─ Name: CBW
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L873, C9]: mnemonic CBD for convert-b-d(to, from) plain2
      │   │   └─ Name: CBD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L874, C9]: mnemonic CBQ for convert-b-q(to, from) plain2
      │   │   └─ Name: CBQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L875, C9]: mnemonic CWD for convert-w-d(to, from) plain2
      │   │   └─ Name: CWD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L876, C9]: mnemonic CWQ for convert-w-q(to, from) plain2
      │   │   └─ Name: CWQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L877, C9]: mnemonic CDQ for convert-d-q(to, from) plain2
      │   │   └─ Name: CDQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L879, C9]: mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64
      │   │   └─ Name: NEG
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L883, C9]: mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64
      │   │   └─ Name: NOT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L887, C9]: mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L891, C9]: mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L896, C9]: mnemonic EQ for eq(reg1, reg2) plain2
      │   │   └─ Name: EQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L897, C9]: mnemonic NEQ for neq(reg1, reg2) plain2
      │   │   └─ Name: NEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L898, C9]: mnemonic GR for gr(reg1, reg2) plain2
      │   │   └─ Name: GR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L899, C9]: mnemonic LE for le(reg1, reg2) plain2
      │   │   └─ Name: LE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L900, C9]: mnemonic GREQ for greq(reg1, reg2) plain2
      │   │   └─ Name: GREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L901, C9]: mnemonic LEEQ for leeq(reg1, reg2) plain2
      │   │   └─ Name: LEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L903, C9]: mnemonic JMP for jmp(value) plain1
      │   │   └─ Name: JMP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L904, C9]: mnemonic JZ for jz(value) plain1
      │   │   └─ Name: JZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L905, C9]: mnemonic JNZ for jnz(value) plain1
      │   │   └─ Name: JNZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L906, C9]: mnemonic JEQ for jeq(reg1, reg2, value) plain3
      │   │   └─ Name: JEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L907, C9]: mnemonic JNEQ for jneq(reg1, reg2, value) plain3
      │   │   └─ Name: JNEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L908, C9]: mnemonic JGR for jgr(reg1, reg2, value) plain3
      │   │   └─ Name: JGR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L909, C9]: mnemonic JLE for jle(reg1, reg2, value) plain3
      │   │   └─ Name: JLE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L910, C9]: mnemonic JGREQ for jgreq(reg1, reg2, value) plain3
      │   │   └─ Name: JGREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L911, C9]: mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3
      │   │   └─ Name: JLEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L913, C9]: mnemonic CALL for call(value) plain1
      │   │   └─ Name: CALL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L914, C9]: mnemonic ENTER for enter(value) plain1
      │   │   └─ Name: ENTER
      │   │ 
      │   └─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L915, C9]: mnemonic LEAVE for leave(value) plain1
      │       └─ Name: LEAVE
      │     
      ├─ Kind: Default
      └─ Name: myArch
    


