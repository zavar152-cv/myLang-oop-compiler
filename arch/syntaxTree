Definition syntax tree at 17.12.2024 23:52:13

Parsing C:\RemoteTasks.Workspace\Sessions\VisualizeArchModel_d2684de6-3a81-4241-ac4e-19fab77713db\workdir\In\myArch.target.pdsl

 DefSyntaxTree at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [64];\n        storage AR_S [64];\n        view IP = IP_S;\n        view AR = AR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [64];\n        storage BP_S [64];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [64];\n        storage OUT_S [64];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1, reg2) plain2;\n        mnemonic NEQ for neq(reg1, reg2) plain2;\n        mnemonic GR for gr(reg1, reg2) plain2;\n        mnemonic LE for le(reg1, reg2) plain2;\n        mnemonic GREQ for greq(reg1, reg2) plain2;\n        mnemonic LEEQ for leeq(reg1, reg2) plain2;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(reg1, reg2, value) plain3;\n        mnemonic JNEQ for jneq(reg1, reg2, value) plain3;\n        mnemonic JGR for jgr(reg1, reg2, value) plain3;\n        mnemonic JLE for jle(reg1, reg2, value) plain3;\n        mnemonic JGREQ for jgreq(reg1, reg2, value) plain3;\n        mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3;\n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n}
  └─ ArchitectureAspectSyntaxNode at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [64];\n        storage AR_S [64];\n        view IP = IP_S;\n        view AR = AR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [64];\n        storage BP_S [64];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [64];\n        storage OUT_S [64];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1, reg2) plain2;\n        mnemonic NEQ for neq(reg1, reg2) plain2;\n        mnemonic GR for gr(reg1, reg2) plain2;\n        mnemonic LE for le(reg1, reg2) plain2;\n        mnemonic GREQ for greq(reg1, reg2) plain2;\n        mnemonic LEEQ for leeq(reg1, reg2) plain2;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(reg1, reg2, value) plain3;\n        mnemonic JNEQ for jneq(reg1, reg2, value) plain3;\n        mnemonic JGR for jgr(reg1, reg2, value) plain3;\n        mnemonic JLE for jle(reg1, reg2, value) plain3;\n        mnemonic JGREQ for jgreq(reg1, reg2, value) plain3;\n        mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3;\n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n}
      ├─ ArchRegistersSyntaxNode at [L3, C5]: registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [64];\n        storage AR_S [64];\n        view IP = IP_S;\n        view AR = AR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [64];\n        storage BP_S [64];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [64];\n        storage OUT_S [64];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];
      │   ├─ ArchRegsStorageItemSyntaxNode at [L5, C9]: storage R0_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R0_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L6, C9]: storage R1_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L7, C9]: storage R2_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L8, C9]: storage R3_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R3_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L9, C9]: storage R4_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R4_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L10, C9]: storage R5_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R5_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L11, C9]: storage R6_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R6_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L12, C9]: storage R7_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R7_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L15, C9]: view R0 = R0_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L15, C19]: R0_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L16, C9]: view R1 = R1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L16, C19]: R1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L17, C9]: view R2 = R2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L17, C19]: R2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L18, C9]: view R3 = R3_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L18, C19]: R3_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L19, C9]: view R4 = R4_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L19, C19]: R4_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L20, C9]: view R5 = R5_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L20, C19]: R5_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L21, C9]: view R6 = R6_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L21, C19]: R6_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L22, C9]: view R7 = R7_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L22, C19]: R7_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L25, C9]: view ER0 = R0_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L25, C20]: R0_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: ER0
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L26, C9]: view ER1 = R1_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L26, C20]: R1_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: ER1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L27, C9]: view ER2 = R2_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L27, C20]: R2_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: ER2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L28, C9]: view ER3 = R3_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L28, C20]: R3_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: ER3
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L29, C9]: view ER4 = R4_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L29, C20]: R4_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: ER4
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L30, C9]: view ER5 = R5_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L30, C20]: R5_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: ER5
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L31, C9]: view ER6 = R6_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L31, C20]: R6_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: ER6
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L32, C9]: view ER7 = R7_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L32, C20]: R7_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: ER7
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L35, C9]: view R0H = R0_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L35, C20]: R0_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L36, C9]: view R1H = R1_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L36, C20]: R1_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L37, C9]: view R2H = R2_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L37, C20]: R2_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L38, C9]: view R3H = R3_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L38, C20]: R3_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L39, C9]: view R4H = R4_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L39, C20]: R4_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L40, C9]: view R5H = R5_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L40, C20]: R5_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L41, C9]: view R6H = R6_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L41, C20]: R6_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L42, C9]: view R7H = R7_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L42, C20]: R7_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L45, C9]: view R0L = R0_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L45, C20]: R0_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L46, C9]: view R1L = R1_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L46, C20]: R1_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L47, C9]: view R2L = R2_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L47, C20]: R2_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L48, C9]: view R3L = R3_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L48, C20]: R3_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L49, C9]: view R4L = R4_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L49, C20]: R4_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L50, C9]: view R5L = R5_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L50, C20]: R5_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L51, C9]: view R6L = R6_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L51, C20]: R6_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L52, C9]: view R7L = R7_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L52, C20]: R7_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7L
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L55, C9]: storage IP_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: IP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L56, C9]: storage AR_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: AR_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L57, C9]: view IP = IP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L57, C19]: IP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IP_S
      │   │   │ 
      │   │   └─ Name: IP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L58, C9]: view AR = AR_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L58, C19]: AR_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: AR_S
      │   │   │ 
      │   │   └─ Name: AR
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L61, C9]: storage SP_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: SP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L62, C9]: storage BP_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L63, C9]: storage BR1_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L64, C9]: storage BR2_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L65, C9]: storage RT_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: RT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L66, C9]: view SP = SP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L66, C19]: SP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: SP_S
      │   │   │ 
      │   │   └─ Name: SP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L67, C9]: view BP = BP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L67, C19]: BP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BP_S
      │   │   │ 
      │   │   └─ Name: BP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L68, C9]: view BR1 = BR1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L68, C20]: BR1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR1_S
      │   │   │ 
      │   │   └─ Name: BR1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L69, C9]: view BR2 = BR2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L69, C20]: BR2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR2_S
      │   │   │ 
      │   │   └─ Name: BR2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L70, C9]: view RT = RT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L70, C19]: RT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: RT_S
      │   │   │ 
      │   │   └─ Name: RT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L73, C9]: storage IN_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: IN_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L74, C9]: storage OUT_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: OUT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L75, C9]: view IN = IN_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L75, C19]: IN_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IN_S
      │   │   │ 
      │   │   └─ Name: IN
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L76, C9]: view OUT = OUT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L76, C20]: OUT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: OUT_S
      │   │   │ 
      │   │   └─ Name: OUT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L79, C9]: storage FLAGS_S [4]
      │   │   ├─ Size: 4
      │   │   └─ Name: FLAGS_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L80, C9]: view N = FLAGS_S[0]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L80, C18]: FLAGS_S[0]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 1
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: N
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L81, C9]: view Z = FLAGS_S[1]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L81, C18]: FLAGS_S[1]
      │   │   │   ├─ FromIndex: 1
      │   │   │   ├─ ToIndex: 2
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: Z
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L82, C9]: view V = FLAGS_S[2]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L82, C18]: FLAGS_S[2]
      │   │   │   ├─ FromIndex: 2
      │   │   │   ├─ ToIndex: 3
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: V
      │   │ 
      │   └─ ArchRegsViewItemSyntaxNode at [L83, C9]: view C = FLAGS_S[3]
      │       ├─ IsHidden: False
      │       ├─ ArchRegsViewWindowSyntaxNode at [L83, C18]: FLAGS_S[3]
      │       │   ├─ FromIndex: 3
      │       │   ├─ ToIndex: 4
      │       │   └─ Name: FLAGS_S
      │       │ 
      │       └─ Name: C
      │     
      ├─ ArchMemorySyntaxNode at [L86, C5]: memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L87, C9]: range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: codeM
      │   │ 
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L93, C9]: range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: constantsM
      │   │ 
      │   └─ ArchMemoryRangeItemSyntaxNode at [L99, C9]: range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │       ├─ AddressFrom: 0
      │       ├─ AddressTo: 4294967295
      │       ├─ CellSize: 8
      │       ├─ Endianess: Little
      │       ├─ Granularity: 0
      │       └─ Name: dataM
      │     
      ├─ ArchInstructionsSyntaxNode at [L105, C5]: instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};
      │   ├─ ArchFieldEncodingSyntaxNode at [L106, C9]: encode imm32 field = immediate[32]
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L106, C30]: immediate[32]
      │   │   │   ├─ Length: 32
      │   │   │   └─ Kind: Default
      │   │   │ 
      │   │   └─ Name: imm32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L107, C9]: encode off32 field = immediate[32] offset
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L107, C30]: immediate[32] offset
      │   │   │   ├─ Length: 32
      │   │   │   └─ Kind: Offset
      │   │   │ 
      │   │   └─ Name: off32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L109, C9]: encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000\n	    }
      │   │   ├─ ArchFieldEncRegisterDescrSyntaxNode at [L109, C28]: register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000\n	    }
      │   │   └─ Name: reg
      │   │ 
      │   ├─ ArchFieldsGroupEncodingSyntaxNode at [L129, C9]: encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        }
      │   │   └─ Name: size
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L136, C5]: instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L136, C23]: {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L136, C24]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L136, C105]: {\n	}
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L136, C105]: {\n	}
      │   │   │ 
      │   │   └─ Name: nop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L140, C5]: instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L140, C23]: {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L140, C24]: 0000 0001
      │   │   │   │   └─ BitsStr: 0000 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L140, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L140, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L140, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L140, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L140, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L140, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L141, C9]: when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L141, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L141, C23]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L142, C13]: let res = reg1 + reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L142, C23]: reg1 + reg2
      │   │   │       │   │   │       ├─ Operator: Sum
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L142, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L142, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L143, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L143, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L144, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L144, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L144, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L144, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L144, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L144, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L145, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L145, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L145, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L145, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L145, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L145, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L145, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L145, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L145, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L146, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L146, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L146, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L146, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L146, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L146, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L146, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L146, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L146, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L147, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L147, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L147, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L147, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L147, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L147, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L147, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L147, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L147, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L147, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L147, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L147, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L147, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L147, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L147, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L147, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L147, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L147, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L148, C16]: when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L148, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L148, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L149, C13]: let res = reg1 + reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L149, C23]: reg1 + reg2
      │   │   │       │       │   │       ├─ Operator: Sum
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L149, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L149, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L150, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L150, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L151, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L151, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L151, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L151, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L151, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L151, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L152, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L152, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L152, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L152, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L152, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L152, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L152, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L152, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L152, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L153, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L153, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L153, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L153, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L153, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L153, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L153, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L153, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L153, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L154, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L154, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L154, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L154, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L154, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L154, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L154, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L154, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L154, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L154, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L154, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L154, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L154, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L154, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L154, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L154, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L154, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L154, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L155, C16]: when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L155, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L155, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L156, C13]: let res = reg1 + reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L156, C23]: reg1 + reg2
      │   │   │       │           │   │       ├─ Operator: Sum
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L156, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L156, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L157, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L157, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L158, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L158, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L158, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L158, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L158, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L158, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L159, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L159, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L159, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L159, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L159, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L159, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L159, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L159, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L159, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L160, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L160, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L160, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L160, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L160, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L160, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L160, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L160, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L160, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L161, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L161, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L161, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L161, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L161, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L161, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L161, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L161, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L161, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L161, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L161, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L161, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L161, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L161, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L161, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L161, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L161, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L161, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L162, C16]: when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L162, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L162, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L163, C13]: let res = reg1 + reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L163, C23]: reg1 + reg2
      │   │   │       │               │   │       ├─ Operator: Sum
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L163, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L163, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L164, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L164, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L165, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L165, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L165, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L165, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L165, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L165, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L166, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L166, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L166, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L166, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L166, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L166, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L166, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L166, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L166, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L167, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L167, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L167, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L167, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L167, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L167, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L167, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L167, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L167, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L168, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L168, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L168, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L168, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L168, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L168, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L168, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L168, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L168, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L168, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L168, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L168, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L168, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L168, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L168, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L168, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L168, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L168, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L171, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L171, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L171, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L171, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L171, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L171, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L172, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L172, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L172, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L172, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ElseBranchOrNull: <NULL>
      │   │   │       │ 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L175, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L175, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L175, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L175, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L175, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L175, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: add
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L178, C5]: instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L178, C30]: {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L178, C31]: 0000 0010
      │   │   │   │   └─ BitsStr: 0000 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L178, C42]: 10
      │   │   │   │   └─ BitsStr: 10
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L178, C46]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L178, C57]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L178, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L178, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L178, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L178, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L179, C9]: to = value;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L179, C9]: to = value
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L179, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L179, C14]: value
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L181, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L181, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L181, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L181, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L181, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L181, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-imm32
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L184, C5]: instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L184, C24]: {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L184, C25]: 0000 0011
      │   │   │   │   └─ BitsStr: 0000 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L184, C36]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L184, C51]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L184, C62]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L184, C74]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L184, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L184, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L185, C9]: when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L185, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L185, C23]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L186, C13]: let res = dataM:8[ptr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L186, C23]: dataM:8[ptr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L186, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L186, C31]: ptr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L187, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L187, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L187, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L187, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L187, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L187, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L188, C16]: when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L188, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L188, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L189, C13]: let res = dataM:8[ptr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L189, C23]: dataM:8[ptr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L189, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L189, C31]: ptr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L190, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L190, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L190, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L190, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L190, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L190, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L191, C16]: when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L191, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L191, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L192, C13]: let res = dataM:8[ptr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L192, C23]: dataM:8[ptr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L192, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L192, C31]: ptr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L193, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L193, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L193, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L193, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L193, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L193, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L194, C16]: when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L194, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L194, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L195, C13]: let res = dataM:8[ptr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L195, C23]: dataM:8[ptr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L195, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L195, C31]: ptr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L196, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L196, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L196, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L196, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L196, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L196, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L198, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L198, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L198, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L198, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L198, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L198, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L201, C5]: instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L201, C25]: {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L201, C26]: 0000 0100
      │   │   │   │   └─ BitsStr: 0000 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L201, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L201, C52]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L201, C65]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L201, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L201, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L201, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L202, C9]: when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L202, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L202, C23]: {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L203, C13]: dataM:8[ptr] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L203, C13]: dataM:8[ptr] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L203, C13]: dataM:8[ptr]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L203, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnPlaceExprSyntaxNode at [L203, C21]: ptr
      │   │   │       │   │           │ 
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L203, C28]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L203, C28]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L203, C35]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L204, C16]: when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L204, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L204, C31]: {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L205, C13]: dataM:8[ptr] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L205, C13]: dataM:8[ptr] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L205, C13]: dataM:8[ptr]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L205, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnPlaceExprSyntaxNode at [L205, C21]: ptr
      │   │   │       │       │           │ 
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L205, C28]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L205, C28]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L205, C35]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L206, C16]: when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L206, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L206, C31]: {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L207, C13]: dataM:8[ptr] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L207, C13]: dataM:8[ptr] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L207, C13]: dataM:8[ptr]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L207, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnPlaceExprSyntaxNode at [L207, C21]: ptr
      │   │   │       │           │           │ 
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L207, C28]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L207, C28]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L207, C35]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L208, C16]: when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L208, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L208, C31]: {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L209, C13]: dataM:8[ptr] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L209, C13]: dataM:8[ptr] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L209, C13]: dataM:8[ptr]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L209, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnPlaceExprSyntaxNode at [L209, C21]: ptr
      │   │   │       │               │           │ 
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L209, C28]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L209, C28]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L209, C35]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L211, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L211, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L211, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L211, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L211, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L211, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L214, C5]: instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L214, C23]: {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L214, C24]: 0000 0101
      │   │   │   │   └─ BitsStr: 0000 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L214, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L214, C39]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L214, C52]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L214, C60]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L214, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L214, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L215, C9]: OUT = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L215, C9]: OUT = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L215, C9]: OUT
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L215, C15]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L216, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L216, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L216, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L216, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L216, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L216, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: out
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L219, C5]: instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L219, C22]: {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L219, C23]: 0000 0110
      │   │   │   │   └─ BitsStr: 0000 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L219, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L219, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L219, C46]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L219, C57]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L219, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L219, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L220, C9]: to = IN;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L220, C9]: to = IN
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L220, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L220, C14]: IN
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L221, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L221, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L221, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L221, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L221, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L221, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: in
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L224, C5]: instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L224, C28]: {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L224, C29]: 0000 0111
      │   │   │   │   └─ BitsStr: 0000 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L224, C40]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L224, C55]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L224, C66]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L224, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L224, C92]: off32 as offsetValue
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L224, C114]: {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L224, C114]: {\n        when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L225, C9]: when sz8 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L225, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L225, C23]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L226, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L226, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L226, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L226, C31]: ptr + offsetValue
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L226, C31]: ptr
      │   │   │       │   │   │           └─ ArchInsnPlaceExprSyntaxNode at [L226, C37]: offsetValue
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L227, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L227, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L227, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L227, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L227, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L227, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L228, C16]: when sz16 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L228, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L228, C31]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L229, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L229, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L229, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L229, C31]: ptr + offsetValue
      │   │   │       │       │   │           ├─ Operator: Sum
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L229, C31]: ptr
      │   │   │       │       │   │           └─ ArchInsnPlaceExprSyntaxNode at [L229, C37]: offsetValue
      │   │   │       │       │   │         
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L230, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L230, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L230, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L230, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L230, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L230, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L231, C16]: when sz32 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L231, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L231, C31]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L232, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L232, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L232, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L232, C31]: ptr + offsetValue
      │   │   │       │           │   │           ├─ Operator: Sum
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L232, C31]: ptr
      │   │   │       │           │   │           └─ ArchInsnPlaceExprSyntaxNode at [L232, C37]: offsetValue
      │   │   │       │           │   │         
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L233, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L233, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L233, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L233, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L233, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L233, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L234, C16]: when sz64 then {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L234, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L234, C31]: {\n            let res = dataM:8[ptr + offsetValue];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L235, C13]: let res = dataM:8[ptr + offsetValue];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L235, C23]: dataM:8[ptr + offsetValue]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L235, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L235, C31]: ptr + offsetValue
      │   │   │       │               │   │           ├─ Operator: Sum
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L235, C31]: ptr
      │   │   │       │               │   │           └─ ArchInsnPlaceExprSyntaxNode at [L235, C37]: offsetValue
      │   │   │       │               │   │         
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L236, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L236, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L236, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L236, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L236, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L236, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L238, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L238, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L238, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L238, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L238, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L238, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L241, C5]: instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L241, C29]: {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L241, C30]: 0000 1000
      │   │   │   │   └─ BitsStr: 0000 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L241, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L241, C56]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L241, C69]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L241, C81]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L241, C95]: off32 as offsetValue
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L241, C117]: {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L241, C117]: {\n        when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L242, C9]: when sz8 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L242, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L242, C23]: {\n            dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L243, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L243, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L243, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L243, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L243, C21]: ptr + offsetValue
      │   │   │       │   │           │       ├─ Operator: Sum
      │   │   │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L243, C21]: ptr
      │   │   │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L243, C27]: offsetValue
      │   │   │       │   │           │     
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L243, C42]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L243, C42]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L243, C49]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L244, C16]: when sz16 then {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L244, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L244, C31]: {\n            dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L245, C13]: dataM:8[ptr + offsetValue] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L245, C13]: dataM:8[ptr + offsetValue] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L245, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L245, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnBinaryExprSyntaxNode at [L245, C21]: ptr + offsetValue
      │   │   │       │       │           │       ├─ Operator: Sum
      │   │   │       │       │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L245, C21]: ptr
      │   │   │       │       │           │       └─ ArchInsnPlaceExprSyntaxNode at [L245, C27]: offsetValue
      │   │   │       │       │           │     
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L245, C42]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L245, C42]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L245, C49]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L246, C16]: when sz32 then {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L246, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L246, C31]: {\n            dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L247, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L247, C13]: dataM:8[ptr + offsetValue] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L247, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L247, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnBinaryExprSyntaxNode at [L247, C21]: ptr + offsetValue
      │   │   │       │           │           │       ├─ Operator: Sum
      │   │   │       │           │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L247, C21]: ptr
      │   │   │       │           │           │       └─ ArchInsnPlaceExprSyntaxNode at [L247, C27]: offsetValue
      │   │   │       │           │           │     
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L247, C42]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L247, C42]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L247, C49]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L248, C16]: when sz64 then {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L248, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L248, C31]: {\n            dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L249, C13]: dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L249, C13]: dataM:8[ptr + offsetValue] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L249, C13]: dataM:8[ptr + offsetValue]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L249, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnBinaryExprSyntaxNode at [L249, C21]: ptr + offsetValue
      │   │   │       │               │           │       ├─ Operator: Sum
      │   │   │       │               │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L249, C21]: ptr
      │   │   │       │               │           │       └─ ArchInsnPlaceExprSyntaxNode at [L249, C27]: offsetValue
      │   │   │       │               │           │     
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L249, C42]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L249, C42]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L249, C49]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L251, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L251, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L251, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L251, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L251, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L251, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L254, C5]: instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L254, C24]: {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L254, C25]: 0000 1001
      │   │   │   │   └─ BitsStr: 0000 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L254, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L254, C40]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L254, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L254, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L254, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L254, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L255, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L255, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L255, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L255, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L255, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L255, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L256, C9]: dataM:8[SP] = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L256, C9]: dataM:8[SP] = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L256, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L256, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L256, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L256, C23]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L257, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L257, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L257, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L257, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L257, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L257, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: push
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L260, C5]: instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L260, C23]: {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L260, C24]: 0000 1010
      │   │   │   │   └─ BitsStr: 0000 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L260, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L260, C39]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L260, C50]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L260, C58]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L260, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L260, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L261, C9]: to = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L261, C9]: to = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L261, C9]: to
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L261, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L261, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L261, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L262, C9]: SP = SP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L262, C9]: SP = SP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L262, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L262, C14]: SP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L262, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L262, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L263, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L263, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L263, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L263, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L263, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L263, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: pop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L266, C5]: instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L266, C23]: {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L266, C24]: 0000 1011
      │   │   │   │   └─ BitsStr: 0000 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L266, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L266, C39]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L266, C50]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L266, C63]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L266, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L266, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L267, C9]: to = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L267, C9]: to = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L267, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L267, C14]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L268, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L268, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L268, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L268, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L268, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L268, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L273, C5]: instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L273, C29]: {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L273, C30]: 0000 1100
      │   │   │   │   └─ BitsStr: 0000 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L273, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L273, C56]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L273, C67]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L273, C80]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L273, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L273, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L274, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L274, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L274, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L275, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L275, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L275, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L275, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L275, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L275, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L276, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L276, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L276, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L277, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L277, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L277, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L277, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L277, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L277, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L278, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L278, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L278, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L279, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L279, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L279, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L279, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L279, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L279, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L280, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L280, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L280, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L281, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L281, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L281, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L281, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L281, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L281, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L283, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L283, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L283, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L283, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L283, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L283, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-trunc
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L288, C5]: instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L288, C26]: {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L288, C27]: 0000 1101
      │   │   │   │   └─ BitsStr: 0000 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L288, C38]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L288, C53]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L288, C64]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L288, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L288, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L288, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L289, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L289, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L289, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L290, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L290, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L290, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L290, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L290, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L290, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L291, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L291, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L291, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L292, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L292, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L292, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L292, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L292, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L292, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L293, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L293, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L293, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L294, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L294, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L294, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L294, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L294, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L294, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L295, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L295, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L295, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L296, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L296, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L296, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L296, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L296, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L296, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L298, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L298, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L298, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L298, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L298, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L298, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-zx
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L301, C5]: instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L301, C31]: {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L301, C32]: 0000 1110
      │   │   │   │   └─ BitsStr: 0000 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L301, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L301, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L301, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L301, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L301, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L301, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L302, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L302, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L302, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L302, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L302, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L302, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L302, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L303, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L303, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L303, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L303, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L304, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L304, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L304, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L304, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L304, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L304, C35]: {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L305, C13]: let ext_mask = 0x000000000000ff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L305, C28]: 0x000000000000ff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x000000000000ff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L306, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L306, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L306, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L306, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L306, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L306, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L307, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L308, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L308, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L308, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L308, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L310, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L310, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L310, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L310, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L310, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L310, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-w
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L313, C5]: instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L313, C31]: {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L313, C32]: 0000 1111
      │   │   │   │   └─ BitsStr: 0000 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L313, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L313, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L313, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L313, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L313, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L313, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L314, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L314, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L314, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L314, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L314, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L314, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L314, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L315, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L315, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L315, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L315, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L316, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L316, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L316, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L316, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L316, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L316, C35]: {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L317, C13]: let ext_mask = 0x00000000ffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L317, C28]: 0x00000000ffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L318, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L318, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L318, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L318, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L318, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L318, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L319, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L320, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L320, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L320, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L320, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L322, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L322, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L322, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L322, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L322, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L322, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L325, C5]: instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L325, C31]: {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L325, C32]: 0001 0000
      │   │   │   │   └─ BitsStr: 0001 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L325, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L325, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L325, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L325, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L325, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L325, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L326, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L326, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L326, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L326, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L326, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L326, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L326, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L327, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L327, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L327, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L327, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L328, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L328, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L328, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L328, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L328, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L328, C35]: {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L329, C13]: let ext_mask = 0xffffffffffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L329, C28]: 0xffffffffffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L330, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L330, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L330, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L330, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L330, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L330, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L331, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L332, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L332, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L332, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L332, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L334, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L334, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L334, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L334, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L334, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L334, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L337, C5]: instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L337, C31]: {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L337, C32]: 0001 0001
      │   │   │   │   └─ BitsStr: 0001 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L337, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L337, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L337, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L337, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L337, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L337, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L338, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L338, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L338, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L338, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L338, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L338, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L338, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L339, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L339, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L339, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L339, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L340, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L340, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L340, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L340, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L340, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L340, C35]: {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L341, C13]: let ext_mask = 0x00000000ffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L341, C28]: 0x00000000ffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L342, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L342, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L342, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L342, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L342, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L342, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L343, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L344, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L344, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L344, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L344, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L346, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L346, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L346, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L346, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L346, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L346, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L349, C5]: instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L349, C31]: {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L349, C32]: 0001 0010
      │   │   │   │   └─ BitsStr: 0001 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L349, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L349, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L349, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L349, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L349, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L349, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L350, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L350, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L350, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L350, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L350, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L350, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L350, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L351, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L351, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L351, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L351, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L352, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L352, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L352, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L352, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L352, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L352, C35]: {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L353, C13]: let ext_mask = 0xffffffffffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L353, C28]: 0xffffffffffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L354, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L354, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L354, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L354, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L354, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L354, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L355, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L356, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L356, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L356, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L356, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L358, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L358, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L358, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L358, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L358, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L358, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L362, C5]: instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L362, C31]: {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L362, C32]: 0001 0011
      │   │   │   │   └─ BitsStr: 0001 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L362, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L362, C47]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L362, C58]: reg as from
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L362, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L362, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L362, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L363, C9]: let sign_bit = (from >> 31) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L363, C24]: (from >> 31) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L363, C24]: (from >> 31)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L363, C25]: from >> 31
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L363, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L363, C33]: 31
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 31
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L363, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L364, C9]: let from_masked = from & 0xffffffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L364, C27]: from & 0xffffffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L364, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L364, C34]: 0xffffffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffffffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L365, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L365, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L365, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L365, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L365, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L365, C35]: {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L366, C13]: let ext_mask = 0xffffffff00000000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L366, C28]: 0xffffffff00000000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffff00000000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L367, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L367, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L367, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L367, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L367, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L367, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L368, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L369, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L369, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L369, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L369, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L371, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L371, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L371, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L371, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L371, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L371, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-d-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L374, C5]: instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L374, C23]: {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L374, C24]: 0001 0100
      │   │   │   │   └─ BitsStr: 0001 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L374, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L374, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L374, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L374, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L374, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L374, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L375, C9]: when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L375, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L375, C23]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L376, C13]: let res = reg1 - reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L376, C23]: reg1 - reg2
      │   │   │       │   │   │       ├─ Operator: Sub
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L376, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L376, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L377, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L377, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L378, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L378, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L378, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L378, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L378, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L378, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L379, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L379, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L379, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L379, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L379, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L379, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L379, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L379, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L379, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L380, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L380, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L380, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L380, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L380, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L380, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L380, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L380, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L380, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L381, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L381, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L381, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L381, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L381, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L381, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L381, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L381, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L381, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L381, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L381, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L381, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L381, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L381, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L381, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L381, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L381, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L381, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L382, C16]: when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L382, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L382, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L383, C13]: let res = reg1 - reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L383, C23]: reg1 - reg2
      │   │   │       │       │   │       ├─ Operator: Sub
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L383, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L383, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L384, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L384, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L385, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L385, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L385, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L385, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L385, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L385, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L386, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L386, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L386, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L386, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L386, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L386, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L386, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L386, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L386, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L387, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L387, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L387, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L387, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L387, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L387, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L387, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L387, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L387, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L388, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L388, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L388, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L388, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L388, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L388, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L388, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L388, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L388, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L388, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L388, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L388, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L388, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L388, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L388, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L388, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L388, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L388, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L389, C16]: when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L389, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L389, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L390, C13]: let res = reg1 - reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L390, C23]: reg1 - reg2
      │   │   │       │           │   │       ├─ Operator: Sub
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L390, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L390, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L391, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L391, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L392, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L392, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L392, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L392, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L392, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L392, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L393, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L393, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L393, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L393, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L393, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L393, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L393, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L393, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L393, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L394, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L394, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L394, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L394, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L394, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L394, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L394, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L394, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L394, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L395, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L395, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L395, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L395, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L395, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L395, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L395, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L395, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L395, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L395, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L395, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L395, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L395, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L395, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L395, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L395, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L395, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L395, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L396, C16]: when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L396, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L396, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L397, C13]: let res = reg1 - reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L397, C23]: reg1 - reg2
      │   │   │       │               │   │       ├─ Operator: Sub
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L397, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L397, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L398, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L398, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L399, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L399, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L399, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L399, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L399, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L399, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L400, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L400, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L400, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L400, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L400, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L400, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L400, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L400, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L400, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L401, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L401, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L401, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L401, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L401, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L401, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L401, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L401, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L401, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L402, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L402, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L402, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L402, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L402, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L402, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L402, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L402, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L402, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L402, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L402, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L402, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L402, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L402, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L402, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L402, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L402, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L402, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L405, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L405, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L405, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L405, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L405, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L405, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L406, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L406, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L406, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L406, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L407, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L408, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L408, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L408, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L408, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L411, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L411, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L411, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L411, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L411, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L411, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: sub
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L414, C5]: instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L414, C23]: {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L414, C24]: 0001 0101
      │   │   │   │   └─ BitsStr: 0001 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L414, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L414, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L414, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L414, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L414, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L414, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L415, C9]: when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L415, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L415, C23]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L416, C13]: let res = reg1 * reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L416, C23]: reg1 * reg2
      │   │   │       │   │   │       ├─ Operator: Mul
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L416, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L416, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L417, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L417, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L417, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L417, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L417, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L417, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L418, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L418, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L418, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L418, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L418, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L418, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L418, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L418, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L418, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L419, C16]: when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L419, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L419, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L420, C13]: let res = reg1 * reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L420, C23]: reg1 * reg2
      │   │   │       │       │   │       ├─ Operator: Mul
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L420, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L420, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L421, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L421, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L421, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L421, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L421, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L421, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L422, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L422, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L422, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L422, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L422, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L422, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L422, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L422, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L422, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L423, C16]: when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L423, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L423, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L424, C13]: let res = reg1 * reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L424, C23]: reg1 * reg2
      │   │   │       │           │   │       ├─ Operator: Mul
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L424, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L424, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L425, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L425, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L425, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L425, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L425, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L425, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L426, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L426, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L426, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L426, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L426, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L426, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L426, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L426, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L426, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L427, C16]: when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L427, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L427, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L428, C13]: let res = reg1 * reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L428, C23]: reg1 * reg2
      │   │   │       │               │   │       ├─ Operator: Mul
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L428, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L428, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L429, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L429, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L429, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L429, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L429, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L429, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L430, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L430, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L430, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L430, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L430, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L430, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L430, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L430, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L430, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L433, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L433, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L433, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L433, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L433, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L433, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L434, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L434, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L434, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L434, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L435, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L436, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L436, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L436, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L436, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L439, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L439, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L439, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L439, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L439, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L439, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mul
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L442, C5]: instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L442, C23]: {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L442, C24]: 0001 0110
      │   │   │   │   └─ BitsStr: 0001 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L442, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L442, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L442, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L442, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L442, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L442, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L443, C9]: when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L443, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L443, C23]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L444, C13]: let res = reg1 / reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L444, C23]: reg1 / reg2
      │   │   │       │   │   │       ├─ Operator: Div
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L444, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L444, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L445, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L445, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L445, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L445, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L445, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L445, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L446, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L446, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L446, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L446, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L446, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L446, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L446, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L446, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L446, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L447, C16]: when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L447, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L447, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L448, C13]: let res = reg1 / reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L448, C23]: reg1 / reg2
      │   │   │       │       │   │       ├─ Operator: Div
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L448, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L448, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L449, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L449, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L449, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L449, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L449, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L449, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L450, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L450, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L450, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L450, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L450, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L450, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L450, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L450, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L450, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L451, C16]: when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L451, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L451, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L452, C13]: let res = reg1 / reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L452, C23]: reg1 / reg2
      │   │   │       │           │   │       ├─ Operator: Div
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L452, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L452, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L453, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L453, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L453, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L453, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L453, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L453, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L454, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L454, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L454, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L454, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L454, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L454, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L454, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L454, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L454, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L455, C16]: when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L455, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L455, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L456, C13]: let res = reg1 / reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L456, C23]: reg1 / reg2
      │   │   │       │               │   │       ├─ Operator: Div
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L456, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L456, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L457, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L457, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L457, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L457, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L457, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L457, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L458, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L458, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L458, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L458, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L458, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L458, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L458, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L458, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L458, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L461, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L461, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L461, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L461, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L461, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L461, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L462, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L462, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L462, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L462, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L463, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L464, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L464, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L464, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L464, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L467, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L467, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L467, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L467, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L467, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L467, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: div
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L470, C5]: instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L470, C23]: {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L470, C24]: 0001 0111
      │   │   │   │   └─ BitsStr: 0001 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L470, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L470, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L470, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L470, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L470, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L470, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L471, C9]: when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L471, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L471, C23]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L472, C13]: let res = reg1 % reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L472, C23]: reg1 % reg2
      │   │   │       │   │   │       ├─ Operator: Mod
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L472, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L472, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L473, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L473, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L473, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L473, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L473, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L473, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L474, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L474, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L474, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L474, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L474, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L474, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L474, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L474, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L474, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L475, C16]: when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L475, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L475, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L476, C13]: let res = reg1 % reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L476, C23]: reg1 % reg2
      │   │   │       │       │   │       ├─ Operator: Mod
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L476, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L476, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L477, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L477, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L477, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L477, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L477, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L477, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L478, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L478, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L478, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L478, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L478, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L478, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L478, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L478, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L478, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L479, C16]: when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L479, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L479, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L480, C13]: let res = reg1 % reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L480, C23]: reg1 % reg2
      │   │   │       │           │   │       ├─ Operator: Mod
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L480, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L480, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L481, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L481, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L481, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L481, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L481, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L481, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L482, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L482, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L482, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L482, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L482, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L482, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L482, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L482, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L482, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L483, C16]: when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L483, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L483, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L484, C13]: let res = reg1 % reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L484, C23]: reg1 % reg2
      │   │   │       │               │   │       ├─ Operator: Mod
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L484, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L484, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L485, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L485, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L485, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L485, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L485, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L485, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L486, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L486, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L486, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L486, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L486, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L486, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L486, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L486, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L486, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L489, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L489, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L489, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L489, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L489, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L489, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L490, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L490, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L490, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L490, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L491, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L492, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L492, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L492, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L492, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L495, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L495, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L495, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L495, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L495, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L495, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mod
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L498, C5]: instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L498, C23]: {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L498, C24]: 0001 1000
      │   │   │   │   └─ BitsStr: 0001 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L498, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L498, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L498, C63]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L498, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L498, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L498, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L499, C9]: when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L499, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L499, C23]: {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L500, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L500, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L501, C13]: if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L501, C16]: (reg1 == 0x80)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L501, C17]: reg1 == 0x80
      │   │   │       │   │   │   │       ├─ Operator: Equal
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L501, C17]: reg1
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L501, C25]: 0x80
      │   │   │       │   │   │   │           ├─ Kind: Hex
      │   │   │       │   │   │   │           └─ ValueString: 0x80
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L501, C36]: {\n                V = 1;\n            }
      │   │   │       │   │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L502, C17]: V = 1;
      │   │   │       │   │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L502, C17]: V = 1
      │   │   │       │   │   │   │           ├─ Operator: Assign
      │   │   │       │   │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L502, C17]: V
      │   │   │       │   │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L502, C21]: 1
      │   │   │       │   │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │   │               └─ ValueString: 1
      │   │   │       │   │   │   │             
      │   │   │       │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L503, C20]: {\n                V = 0;\n            }
      │   │   │       │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L504, C17]: V = 0;
      │   │   │       │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L504, C17]: V = 0
      │   │   │       │   │   │               ├─ Operator: Assign
      │   │   │       │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L504, C17]: V
      │   │   │       │   │   │               └─ ArchInsnLiteralExprSyntaxNode at [L504, C21]: 0
      │   │   │       │   │   │                   ├─ Kind: Dec
      │   │   │       │   │   │                   └─ ValueString: 0
      │   │   │       │   │   │                 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L506, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L506, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L506, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L506, C20]: ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L506, C20]: ((~res) + 1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L506, C21]: (~res) + 1
      │   │   │       │   │   │           │       ├─ Operator: Sum
      │   │   │       │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L506, C21]: (~res)
      │   │   │       │   │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L506, C22]: ~res
      │   │   │       │   │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L506, C23]: res
      │   │   │       │   │   │           │       │       └─ IsPrefix: True
      │   │   │       │   │   │           │       │     
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L506, C30]: 1
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 1
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L506, C35]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L507, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L507, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L507, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L507, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L507, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L507, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L507, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L507, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L507, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L508, C16]: when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L508, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L508, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L509, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L509, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L510, C13]: if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │       │   │   ├─ ArchInsnBracesExprSyntaxNode at [L510, C16]: (reg1 == 0x8000)
      │   │   │       │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L510, C17]: reg1 == 0x8000
      │   │   │       │       │   │   │       ├─ Operator: Equal
      │   │   │       │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L510, C17]: reg1
      │   │   │       │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L510, C25]: 0x8000
      │   │   │       │       │   │   │           ├─ Kind: Hex
      │   │   │       │       │   │   │           └─ ValueString: 0x8000
      │   │   │       │       │   │   │         
      │   │   │       │       │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L510, C38]: {\n                V = 1;\n            }
      │   │   │       │       │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L511, C17]: V = 1;
      │   │   │       │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L511, C17]: V = 1
      │   │   │       │       │   │   │           ├─ Operator: Assign
      │   │   │       │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L511, C17]: V
      │   │   │       │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L511, C21]: 1
      │   │   │       │       │   │   │               ├─ Kind: Dec
      │   │   │       │       │   │   │               └─ ValueString: 1
      │   │   │       │       │   │   │             
      │   │   │       │       │   │   └─ ArchInsnBlockStmtSyntaxNode at [L512, C20]: {\n                V = 0;\n            }
      │   │   │       │       │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L513, C17]: V = 0;
      │   │   │       │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L513, C17]: V = 0
      │   │   │       │       │   │               ├─ Operator: Assign
      │   │   │       │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L513, C17]: V
      │   │   │       │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L513, C21]: 0
      │   │   │       │       │   │                   ├─ Kind: Dec
      │   │   │       │       │   │                   └─ ValueString: 0
      │   │   │       │       │   │                 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L515, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L515, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L515, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L515, C20]: ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L515, C20]: ((~res) + 1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L515, C21]: (~res) + 1
      │   │   │       │       │   │           │       ├─ Operator: Sum
      │   │   │       │       │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L515, C21]: (~res)
      │   │   │       │       │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L515, C22]: ~res
      │   │   │       │       │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │       │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L515, C23]: res
      │   │   │       │       │   │           │       │       └─ IsPrefix: True
      │   │   │       │       │   │           │       │     
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L515, C30]: 1
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 1
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L515, C35]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L516, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L516, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L516, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L516, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L516, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L516, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L516, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L516, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L516, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L517, C16]: when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L517, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L517, C31]: {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L518, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L518, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L519, C13]: if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │           │   │   ├─ ArchInsnBracesExprSyntaxNode at [L519, C16]: (reg1 == 0x80000000)
      │   │   │       │           │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L519, C17]: reg1 == 0x80000000
      │   │   │       │           │   │   │       ├─ Operator: Equal
      │   │   │       │           │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L519, C17]: reg1
      │   │   │       │           │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L519, C25]: 0x80000000
      │   │   │       │           │   │   │           ├─ Kind: Hex
      │   │   │       │           │   │   │           └─ ValueString: 0x80000000
      │   │   │       │           │   │   │         
      │   │   │       │           │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L519, C42]: {\n                V = 1;\n            }
      │   │   │       │           │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L520, C17]: V = 1;
      │   │   │       │           │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L520, C17]: V = 1
      │   │   │       │           │   │   │           ├─ Operator: Assign
      │   │   │       │           │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L520, C17]: V
      │   │   │       │           │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L520, C21]: 1
      │   │   │       │           │   │   │               ├─ Kind: Dec
      │   │   │       │           │   │   │               └─ ValueString: 1
      │   │   │       │           │   │   │             
      │   │   │       │           │   │   └─ ArchInsnBlockStmtSyntaxNode at [L521, C20]: {\n                V = 0;\n            }
      │   │   │       │           │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L522, C17]: V = 0;
      │   │   │       │           │   │           └─ ArchInsnBinaryExprSyntaxNode at [L522, C17]: V = 0
      │   │   │       │           │   │               ├─ Operator: Assign
      │   │   │       │           │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L522, C17]: V
      │   │   │       │           │   │               └─ ArchInsnLiteralExprSyntaxNode at [L522, C21]: 0
      │   │   │       │           │   │                   ├─ Kind: Dec
      │   │   │       │           │   │                   └─ ValueString: 0
      │   │   │       │           │   │                 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L524, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L524, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L524, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L524, C20]: ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L524, C20]: ((~res) + 1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L524, C21]: (~res) + 1
      │   │   │       │           │   │           │       ├─ Operator: Sum
      │   │   │       │           │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L524, C21]: (~res)
      │   │   │       │           │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L524, C22]: ~res
      │   │   │       │           │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │           │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L524, C23]: res
      │   │   │       │           │   │           │       │       └─ IsPrefix: True
      │   │   │       │           │   │           │       │     
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L524, C30]: 1
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 1
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L524, C35]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L525, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L525, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L525, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L525, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L525, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L525, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L525, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L525, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L525, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L526, C16]: when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L526, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L526, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L527, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L527, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L528, C13]: if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │               │   │   ├─ ArchInsnBracesExprSyntaxNode at [L528, C16]: (reg1 == 0x8000000000000000)
      │   │   │       │               │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L528, C17]: reg1 == 0x8000000000000000
      │   │   │       │               │   │   │       ├─ Operator: Equal
      │   │   │       │               │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L528, C17]: reg1
      │   │   │       │               │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L528, C25]: 0x8000000000000000
      │   │   │       │               │   │   │           ├─ Kind: Hex
      │   │   │       │               │   │   │           └─ ValueString: 0x8000000000000000
      │   │   │       │               │   │   │         
      │   │   │       │               │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L528, C50]: {\n                V = 1;\n            }
      │   │   │       │               │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L529, C17]: V = 1;
      │   │   │       │               │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L529, C17]: V = 1
      │   │   │       │               │   │   │           ├─ Operator: Assign
      │   │   │       │               │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L529, C17]: V
      │   │   │       │               │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L529, C21]: 1
      │   │   │       │               │   │   │               ├─ Kind: Dec
      │   │   │       │               │   │   │               └─ ValueString: 1
      │   │   │       │               │   │   │             
      │   │   │       │               │   │   └─ ArchInsnBlockStmtSyntaxNode at [L530, C20]: {\n                V = 0;\n            }
      │   │   │       │               │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L531, C17]: V = 0;
      │   │   │       │               │   │           └─ ArchInsnBinaryExprSyntaxNode at [L531, C17]: V = 0
      │   │   │       │               │   │               ├─ Operator: Assign
      │   │   │       │               │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L531, C17]: V
      │   │   │       │               │   │               └─ ArchInsnLiteralExprSyntaxNode at [L531, C21]: 0
      │   │   │       │               │   │                   ├─ Kind: Dec
      │   │   │       │               │   │                   └─ ValueString: 0
      │   │   │       │               │   │                 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L533, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L533, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L533, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L533, C20]: ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L533, C20]: ((~res) + 1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L533, C21]: (~res) + 1
      │   │   │       │               │   │           │       ├─ Operator: Sum
      │   │   │       │               │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L533, C21]: (~res)
      │   │   │       │               │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L533, C22]: ~res
      │   │   │       │               │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │               │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L533, C23]: res
      │   │   │       │               │   │           │       │       └─ IsPrefix: True
      │   │   │       │               │   │           │       │     
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L533, C30]: 1
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 1
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L533, C35]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L534, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L534, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L534, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L534, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L534, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L534, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L534, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L534, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L534, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L537, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L537, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L537, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L537, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L537, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L537, C31]: {\n            Z = 1;\n            C = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L538, C13]: Z = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L538, C13]: Z = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L538, C13]: Z
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L538, C17]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L539, C13]: C = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L539, C13]: C = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L539, C13]: C
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L539, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L540, C16]: {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L541, C13]: Z = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L541, C13]: Z = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L541, C13]: Z
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L541, C17]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L542, C13]: C = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L542, C13]: C = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L542, C13]: C
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L542, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L545, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L545, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L545, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L545, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L545, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L545, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neg
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L548, C5]: instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L548, C25]: {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L548, C26]: 0001 1001
      │   │   │   │   └─ BitsStr: 0001 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L548, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L548, C52]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L548, C65]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L548, C73]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L548, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L548, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L549, C9]: when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L549, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L549, C23]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L550, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L550, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L551, C13]: reg1 = (~res) & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L551, C13]: reg1 = (~res) & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L551, C13]: reg1
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L551, C20]: (~res) & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L551, C20]: (~res)
      │   │   │       │   │               │   └─ ArchInsnUnaryExprSyntaxNode at [L551, C21]: ~res
      │   │   │       │   │               │       ├─ Operator: BitsInv
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L551, C22]: res
      │   │   │       │   │               │       └─ IsPrefix: True
      │   │   │       │   │               │     
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L551, C29]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L552, C16]: when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L552, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L552, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L553, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L553, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L554, C13]: reg1 = (~res) & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L554, C13]: reg1 = (~res) & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L554, C13]: reg1
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L554, C20]: (~res) & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L554, C20]: (~res)
      │   │   │       │       │               │   └─ ArchInsnUnaryExprSyntaxNode at [L554, C21]: ~res
      │   │   │       │       │               │       ├─ Operator: BitsInv
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L554, C22]: res
      │   │   │       │       │               │       └─ IsPrefix: True
      │   │   │       │       │               │     
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L554, C29]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L555, C16]: when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L555, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L555, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L556, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L556, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L557, C13]: reg1 = (~res) & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L557, C13]: reg1 = (~res) & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L557, C13]: reg1
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L557, C20]: (~res) & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L557, C20]: (~res)
      │   │   │       │           │               │   └─ ArchInsnUnaryExprSyntaxNode at [L557, C21]: ~res
      │   │   │       │           │               │       ├─ Operator: BitsInv
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L557, C22]: res
      │   │   │       │           │               │       └─ IsPrefix: True
      │   │   │       │           │               │     
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L557, C29]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L558, C16]: when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L558, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L558, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L559, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L559, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L560, C13]: reg1 = (~res) & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L560, C13]: reg1 = (~res) & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L560, C13]: reg1
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L560, C20]: (~res) & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L560, C20]: (~res)
      │   │   │       │               │               │   └─ ArchInsnUnaryExprSyntaxNode at [L560, C21]: ~res
      │   │   │       │               │               │       ├─ Operator: BitsInv
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L560, C22]: res
      │   │   │       │               │               │       └─ IsPrefix: True
      │   │   │       │               │               │     
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L560, C29]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L563, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L563, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L563, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L563, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L563, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L563, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: not-i
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L566, C5]: instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L566, C23]: {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L566, C24]: 0001 1010
      │   │   │   │   └─ BitsStr: 0001 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L566, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L566, C50]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L566, C63]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L566, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L566, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L566, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L567, C9]: when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L567, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L567, C23]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L568, C13]: let res = reg1 & reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L568, C23]: reg1 & reg2
      │   │   │       │   │   │       ├─ Operator: BitsAnd
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L568, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L568, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L569, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L569, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L569, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L569, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L569, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L569, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L570, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L570, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L570, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L570, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L570, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L570, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L570, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L570, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L570, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L571, C16]: when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L571, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L571, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L572, C13]: let res = reg1 & reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L572, C23]: reg1 & reg2
      │   │   │       │       │   │       ├─ Operator: BitsAnd
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L572, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L572, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L573, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L573, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L573, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L573, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L573, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L573, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L574, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L574, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L574, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L574, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L574, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L574, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L574, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L574, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L574, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L575, C16]: when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L575, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L575, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L576, C13]: let res = reg1 & reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L576, C23]: reg1 & reg2
      │   │   │       │           │   │       ├─ Operator: BitsAnd
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L576, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L576, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L577, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L577, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L577, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L577, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L577, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L577, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L578, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L578, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L578, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L578, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L578, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L578, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L578, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L578, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L578, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L579, C16]: when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L579, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L579, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L580, C13]: let res = reg1 & reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L580, C23]: reg1 & reg2
      │   │   │       │               │   │       ├─ Operator: BitsAnd
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L580, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L580, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L581, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L581, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L581, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L581, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L581, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L581, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L582, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L582, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L582, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L582, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L582, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L582, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L582, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L582, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L582, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L585, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L585, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L585, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L585, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L585, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L585, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L586, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L586, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L586, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L586, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L587, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L588, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L588, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L588, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L588, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L591, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L591, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L591, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L591, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L591, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L591, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L594, C5]: instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L594, C22]: {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L594, C23]: 0001 1011
      │   │   │   │   └─ BitsStr: 0001 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L594, C34]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L594, C49]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L594, C62]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L594, C75]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L594, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L594, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L595, C9]: when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L595, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L595, C23]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L596, C13]: let res = reg1 | reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L596, C23]: reg1 | reg2
      │   │   │       │   │   │       ├─ Operator: BitsOr
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L596, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L596, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L597, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L597, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L597, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L597, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L597, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L597, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L598, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L598, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L598, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L598, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L598, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L598, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L598, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L598, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L598, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L599, C16]: when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L599, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L599, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L600, C13]: let res = reg1 | reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L600, C23]: reg1 | reg2
      │   │   │       │       │   │       ├─ Operator: BitsOr
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L600, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L600, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L601, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L601, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L601, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L601, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L601, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L601, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L602, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L602, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L602, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L602, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L602, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L602, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L602, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L602, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L602, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L603, C16]: when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L603, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L603, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L604, C13]: let res = reg1 | reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L604, C23]: reg1 | reg2
      │   │   │       │           │   │       ├─ Operator: BitsOr
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L604, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L604, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L605, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L605, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L605, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L605, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L605, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L605, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L606, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L606, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L606, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L606, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L606, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L606, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L606, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L606, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L606, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L607, C16]: when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L607, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L607, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L608, C13]: let res = reg1 | reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L608, C23]: reg1 | reg2
      │   │   │       │               │   │       ├─ Operator: BitsOr
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L608, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L608, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L609, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L609, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L609, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L609, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L609, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L609, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L610, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L610, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L610, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L610, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L610, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L610, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L610, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L610, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L610, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L613, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L613, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L613, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L613, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L613, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L613, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L614, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L614, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L614, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L614, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L615, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L616, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L616, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L616, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L616, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L619, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L619, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L619, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L619, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L619, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L619, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L622, C5]: instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L622, C22]: {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L622, C23]: 0001 1100
      │   │   │   │   └─ BitsStr: 0001 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L622, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L622, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L622, C46]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L622, C54]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L622, C68]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L622, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L622, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L623, C9]: if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L623, C12]: (Z == 0x1)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L623, C13]: Z == 0x1
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L623, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L623, C18]: 0x1
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x1
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L623, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L624, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L624, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L624, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L624, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L625, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L626, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L626, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L626, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L626, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L626, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L626, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L630, C5]: instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L630, C23]: {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L630, C24]: 0001 1101
      │   │   │   │   └─ BitsStr: 0001 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L630, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L630, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L630, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L630, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L630, C69]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L630, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L630, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L631, C9]: if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L631, C12]: (Z == 0x0)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L631, C13]: Z == 0x0
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L631, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L631, C18]: 0x0
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x0
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L631, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L632, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L632, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L632, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L632, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L633, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L634, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L634, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L634, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L634, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L634, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L634, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jnz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L638, C5]: instruction jeq = {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L638, C23]: {0001 1110, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L638, C24]: 0001 1110
      │   │   │   │   └─ BitsStr: 0001 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L638, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L638, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L638, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L638, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L638, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L638, C95]: {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L638, C95]: {\n        if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L639, C9]: if (reg1 == reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L639, C12]: (reg1 == reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L639, C13]: reg1 == reg2
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L639, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L639, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L639, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L640, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L640, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L640, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L640, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L641, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L642, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L642, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L642, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L642, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L642, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L642, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L646, C5]: instruction jneq = {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L646, C24]: {0001 1111, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L646, C25]: 0001 1111
      │   │   │   │   └─ BitsStr: 0001 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L646, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L646, C40]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L646, C53]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L646, C66]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L646, C80]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L646, C96]: {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L646, C96]: {\n        if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L647, C9]: if (reg1 != reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L647, C12]: (reg1 != reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L647, C13]: reg1 != reg2
      │   │   │           │       ├─ Operator: NotEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L647, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L647, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L647, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L648, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L648, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L648, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L648, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L649, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L650, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L650, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L650, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L650, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L650, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L650, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jneq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L654, C5]: instruction jgr = {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L654, C23]: {0010 0000, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L654, C24]: 0010 0000
      │   │   │   │   └─ BitsStr: 0010 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L654, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L654, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L654, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L654, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L654, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L654, C95]: {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L654, C95]: {\n        if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L655, C9]: if (reg1 > reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L655, C12]: (reg1 > reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L655, C13]: reg1 > reg2
      │   │   │           │       ├─ Operator: Greater
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L655, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L655, C20]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L655, C31]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L656, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L656, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L656, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L656, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L657, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L658, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L658, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L658, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L658, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L658, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L658, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L662, C5]: instruction jle = {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L662, C23]: {0010 0001, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L662, C24]: 0010 0001
      │   │   │   │   └─ BitsStr: 0010 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L662, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L662, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L662, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L662, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L662, C79]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L662, C95]: {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L662, C95]: {\n        if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L663, C9]: if (reg1 < reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L663, C12]: (reg1 < reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L663, C13]: reg1 < reg2
      │   │   │           │       ├─ Operator: Less
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L663, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L663, C20]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L663, C31]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L664, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L664, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L664, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L664, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L665, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L666, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L666, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L666, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L666, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L666, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L666, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jle
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L670, C5]: instruction jgreq = {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L670, C25]: {0010 0010, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L670, C26]: 0010 0010
      │   │   │   │   └─ BitsStr: 0010 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L670, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L670, C41]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L670, C54]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L670, C67]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L670, C81]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L670, C97]: {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L670, C97]: {\n        if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L671, C9]: if (reg1 >= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L671, C12]: (reg1 >= reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L671, C13]: reg1 >= reg2
      │   │   │           │       ├─ Operator: GreaterOrEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L671, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L671, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L671, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L672, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L672, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L672, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L672, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L673, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L674, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L674, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L674, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L674, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L674, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L674, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgreq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L678, C5]: instruction jleeq = {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value} {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L678, C25]: {0010 0011, 00, reg as reg1, reg as reg2, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L678, C26]: 0010 0011
      │   │   │   │   └─ BitsStr: 0010 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L678, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L678, C41]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L678, C54]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L678, C67]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L678, C81]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L678, C97]: {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L678, C97]: {\n        if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L679, C9]: if (reg1 <= reg2) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L679, C12]: (reg1 <= reg2)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L679, C13]: reg1 <= reg2
      │   │   │           │       ├─ Operator: LessOrEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L679, C13]: reg1
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L679, C21]: reg2
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L679, C32]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L680, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L680, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L680, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L680, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L681, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L682, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L682, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L682, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L682, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L682, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L682, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jleeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L686, C5]: instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L686, C23]: {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L686, C24]: 0010 0100
      │   │   │   │   └─ BitsStr: 0010 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L686, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L686, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L686, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L686, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L686, C69]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L686, C85]: {\n        IP = value;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L686, C85]: {\n        IP = value;\n    }
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L687, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L687, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L687, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L687, C14]: value
      │   │   │             
      │   │   └─ Name: jmp
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L690, C5]: instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L690, C24]: {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L690, C25]: 0010 0101
      │   │   │   │   └─ BitsStr: 0010 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L690, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L690, C40]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L690, C48]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L690, C56]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L690, C70]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L690, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L690, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L691, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L691, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L691, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L691, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L691, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L691, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L692, C9]: dataM:8[SP] = IP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L692, C9]: dataM:8[SP] = IP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L692, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L692, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L692, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L692, C23]: IP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L692, C23]: IP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L692, C28]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L693, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L693, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L693, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L693, C14]: value
      │   │   │             
      │   │   └─ Name: call
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L696, C5]: instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L696, C23]: {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L696, C24]: 0010 0110
      │   │   │   │   └─ BitsStr: 0010 0110
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L696, C35]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L696, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L696, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L697, C9]: IP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L697, C9]: IP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L697, C9]: IP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L697, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L697, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L697, C22]: SP
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L698, C9]: SP = SP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L698, C9]: SP = SP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L698, C9]: SP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L698, C14]: SP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L698, C14]: SP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L698, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: ret
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L701, C5]: instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L701, C25]: {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L701, C26]: 0010 0111
      │   │   │   │   └─ BitsStr: 0010 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L701, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L701, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L701, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L701, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L701, C71]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L701, C87]: {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L701, C87]: {\n        SP = SP - (8 * value);\n        dataM:8[SP] = BP;\n        BP = SP;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L702, C9]: SP = SP - (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L702, C9]: SP = SP - (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L702, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L702, C14]: SP - (8 * value)
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L702, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L702, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L702, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L702, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L702, C24]: value
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L703, C9]: dataM:8[SP] = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L703, C9]: dataM:8[SP] = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L703, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L703, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L703, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L703, C23]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L704, C9]: BP = SP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L704, C9]: BP = SP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L704, C9]: BP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L704, C14]: SP
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L705, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L705, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L705, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L705, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L705, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L705, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: enter
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L708, C5]: instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L708, C25]: {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L708, C26]: 0010 1000
      │   │   │   │   └─ BitsStr: 0010 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L708, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L708, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L708, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L708, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L708, C71]: imm32 as value
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L708, C87]: {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L708, C87]: {\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + (8 * value);\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L709, C9]: SP = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L709, C9]: SP = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L709, C9]: SP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L709, C14]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L710, C9]: BP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L710, C9]: BP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L710, C9]: BP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L710, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L710, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L710, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L711, C9]: SP = SP + (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L711, C9]: SP = SP + (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L711, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L711, C14]: SP + (8 * value)
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L711, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L711, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L711, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L711, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L711, C24]: value
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L712, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L712, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L712, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L712, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L712, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L712, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leave
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L715, C5]: instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L715, C30]: {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L715, C31]: 0010 1001
      │   │   │   │   └─ BitsStr: 0010 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L715, C42]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L715, C46]: reg as to
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L715, C57]: reg as ptr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L715, C69]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L715, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L715, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L716, C9]: let res = constantsM:8[ptr];
      │   │   │       │   ├─ Name: res
      │   │   │       │   └─ ArchInsnIndexerExprSyntaxNode at [L716, C19]: constantsM:8[ptr]
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L716, C19]: constantsM:8
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L716, C32]: ptr
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L717, C9]: to = res & 0xffffffffffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L717, C9]: to = res & 0xffffffffffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L717, C9]: to
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L717, C14]: res & 0xffffffffffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L717, C14]: res
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L717, C20]: 0xffffffffffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L718, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L718, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L718, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L718, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L718, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L718, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-const
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L721, C5]: instruction eq = {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L721, C22]: {0010 1010, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L721, C23]: 0010 1010
      │   │   │   │   └─ BitsStr: 0010 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L721, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L721, C38]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L721, C51]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L721, C64]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L721, C118]: {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L721, C118]: {\n        if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L722, C9]: if (reg1 == reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L722, C12]: (reg1 == reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L722, C13]: reg1 == reg2
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L722, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L722, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L722, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L723, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L723, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L723, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L723, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L724, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L724, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L724, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L724, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L725, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L726, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L726, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L726, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L726, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L727, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L727, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L727, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L727, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L729, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L729, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L729, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L729, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L729, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L729, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: eq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L732, C5]: instruction neq = {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L732, C23]: {0010 1011, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L732, C24]: 0010 1011
      │   │   │   │   └─ BitsStr: 0010 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L732, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L732, C39]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L732, C52]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L732, C65]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L732, C119]: {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L732, C119]: {\n        if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L733, C9]: if (reg1 != reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L733, C12]: (reg1 != reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L733, C13]: reg1 != reg2
      │   │   │       │   │       ├─ Operator: NotEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L733, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L733, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L733, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L734, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L734, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L734, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L734, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L735, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L735, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L735, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L735, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L736, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L737, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L737, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L737, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L737, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L738, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L738, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L738, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L738, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L740, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L740, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L740, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L740, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L740, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L740, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L743, C5]: instruction gr = {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L743, C22]: {0010 1100, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L743, C23]: 0010 1100
      │   │   │   │   └─ BitsStr: 0010 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L743, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L743, C38]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L743, C51]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L743, C64]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L743, C118]: {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L743, C118]: {\n        if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L744, C9]: if (reg1 > reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L744, C12]: (reg1 > reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L744, C13]: reg1 > reg2
      │   │   │       │   │       ├─ Operator: Greater
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L744, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L744, C20]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L744, C31]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L745, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L745, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L745, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L745, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L746, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L746, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L746, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L746, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L747, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L748, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L748, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L748, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L748, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L749, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L749, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L749, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L749, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L751, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L751, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L751, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L751, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L751, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L751, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: gr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L754, C5]: instruction le = {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L754, C22]: {0010 1101, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L754, C23]: 0010 1101
      │   │   │   │   └─ BitsStr: 0010 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L754, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L754, C38]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L754, C51]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L754, C64]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L754, C118]: {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L754, C118]: {\n        if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L755, C9]: if (reg1 < reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L755, C12]: (reg1 < reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L755, C13]: reg1 < reg2
      │   │   │       │   │       ├─ Operator: Less
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L755, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L755, C20]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L755, C31]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L756, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L756, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L756, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L756, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L757, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L757, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L757, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L757, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L758, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L759, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L759, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L759, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L759, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L760, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L760, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L760, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L760, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L762, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L762, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L762, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L762, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L762, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L762, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: le
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L765, C5]: instruction greq = {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L765, C24]: {0010 1110, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L765, C25]: 0010 1110
      │   │   │   │   └─ BitsStr: 0010 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L765, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L765, C40]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L765, C53]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L765, C66]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L765, C120]: {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L765, C120]: {\n        if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L766, C9]: if (reg1 >= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L766, C12]: (reg1 >= reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L766, C13]: reg1 >= reg2
      │   │   │       │   │       ├─ Operator: GreaterOrEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L766, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L766, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L766, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L767, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L767, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L767, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L767, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L768, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L768, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L768, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L768, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L769, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L770, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L770, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L770, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L770, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L771, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L771, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L771, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L771, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L773, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L773, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L773, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L773, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L773, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L773, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: greq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L776, C5]: instruction leeq = {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L776, C24]: {0010 1111, 00, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L776, C25]: 0010 1111
      │   │   │   │   └─ BitsStr: 0010 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L776, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L776, C40]: reg as reg1
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L776, C53]: reg as reg2
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L776, C66]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L776, C120]: {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L776, C120]: {\n        if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L777, C9]: if (reg1 <= reg2) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L777, C12]: (reg1 <= reg2)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L777, C13]: reg1 <= reg2
      │   │   │       │   │       ├─ Operator: LessOrEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L777, C13]: reg1
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L777, C21]: reg2
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L777, C32]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L778, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L778, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L778, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L778, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L779, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L779, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L779, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L779, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L780, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L781, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L781, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L781, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L781, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L782, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L782, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L782, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L782, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L784, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L784, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L784, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L784, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L784, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L784, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L787, C5]: instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L787, C32]: {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L787, C33]: 0011 0000
      │   │   │   │   └─ BitsStr: 0011 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L787, C44]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L787, C48]: reg as toPtr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: toPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L787, C62]: reg as fromPtr
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: fromPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L787, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L787, C92]: imm32 as size
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: size
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L787, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L787, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L788, C9]: let i = size;
      │   │   │       │   ├─ Name: i
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L788, C17]: size
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L789, C9]: let dest = toPtr;
      │   │   │       │   ├─ Name: dest
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L789, C20]: toPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L790, C9]: let src = fromPtr;
      │   │   │       │   ├─ Name: src
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L790, C19]: fromPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnWhileLoopStmtSyntaxNode at [L792, C9]: while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L792, C24]: {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L793, C13]: dataM:8[dest] = constantsM:8[src];
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L793, C13]: dataM:8[dest] = constantsM:8[src]
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnIndexerExprSyntaxNode at [L793, C13]: dataM:8[dest]
      │   │   │       │   │   │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L793, C13]: dataM:8
      │   │   │       │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L793, C21]: dest
      │   │   │       │   │   │       │ 
      │   │   │       │   │   │       └─ ArchInsnIndexerExprSyntaxNode at [L793, C29]: constantsM:8[src]
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L793, C29]: constantsM:8
      │   │   │       │   │   │           └─ ArchInsnPlaceExprSyntaxNode at [L793, C42]: src
      │   │   │       │   │   │         
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L794, C13]: dest = dest + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L794, C13]: dest = dest + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L794, C13]: dest
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L794, C20]: dest + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L794, C20]: dest
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L794, C27]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L795, C13]: src = src + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L795, C13]: src = src + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L795, C13]: src
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L795, C19]: src + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L795, C19]: src
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L795, C25]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L796, C13]: i = i - 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L796, C13]: i = i - 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L796, C13]: i
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L796, C17]: i - 1
      │   │   │       │   │               ├─ Operator: Sub
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L796, C17]: i
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L796, C21]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L792, C15]: i > 0
      │   │   │       │       ├─ Operator: Greater
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L792, C15]: i
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L792, C19]: 0
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 0
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L799, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L799, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L799, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L799, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L799, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L799, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: memcpy-const
      │   │ 
      │   └─ ArchInstructionEncodingSyntaxNode at [L802, C5]: instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │       ├─ ArchIstructionFieldsSequenceSyntaxNode at [L802, C23]: {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │       │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L802, C24]: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │       │       └─ BitsStr: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │       │     
      │       ├─ ArchInstructionFunctionSyntaxNode at [L802, C105]: {\n	}
      │       │   └─ ArchInsnBlockStmtSyntaxNode at [L802, C105]: {\n	}
      │       │ 
      │       └─ Name: hlt
      │     
      ├─ ArchMnemonicsSyntaxNode at [L805, C5]: mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1, reg2) plain2;\n        mnemonic NEQ for neq(reg1, reg2) plain2;\n        mnemonic GR for gr(reg1, reg2) plain2;\n        mnemonic LE for le(reg1, reg2) plain2;\n        mnemonic GREQ for greq(reg1, reg2) plain2;\n        mnemonic LEEQ for leeq(reg1, reg2) plain2;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(reg1, reg2, value) plain3;\n        mnemonic JNEQ for jneq(reg1, reg2, value) plain3;\n        mnemonic JGR for jgr(reg1, reg2, value) plain3;\n        mnemonic JLE for jle(reg1, reg2, value) plain3;\n        mnemonic JGREQ for jgreq(reg1, reg2, value) plain3;\n        mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3;\n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L806, C9]: format plain1 is "{1}"
      │   │   ├─ SingleFormatString: "{1}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain1
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L807, C9]: format plain2 is "{1}, {2}"
      │   │   ├─ SingleFormatString: "{1}, {2}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain2
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L808, C9]: format plain3 is "{1}, {2}, {3}"
      │   │   ├─ SingleFormatString: "{1}, {2}, {3}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain3
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L810, C9]: mnemonic HLT for hlt()
      │   │   └─ Name: HLT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L811, C9]: mnemonic NOP for nop()
      │   │   └─ Name: NOP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L812, C9]: mnemonic RET for ret()
      │   │   └─ Name: RET
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L814, C9]: mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: ADD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L818, C9]: mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: SUB
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L822, C9]: mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MUL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L826, C9]: mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: DIV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L830, C9]: mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MOD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L835, C9]: mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: ST
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L843, C9]: mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,  \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: LD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L851, C9]: mnemonic LDI32 for load-imm32(to, value) plain2
      │   │   └─ Name: LDI32
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L852, C9]: mnemonic LDC64 for load-const(to, ptr) plain2
      │   │   └─ Name: LDC64
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L854, C9]: mnemonic PUSH for push(from) plain1
      │   │   └─ Name: PUSH
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L855, C9]: mnemonic POP for pop(to) plain1
      │   │   └─ Name: POP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L857, C9]: mnemonic MOV for mov(to, from) plain2
      │   │   └─ Name: MOV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L858, C9]: mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L862, C9]: mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVZX
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L867, C9]: mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3
      │   │   └─ Name: MEMCPYC
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L869, C9]: mnemonic CBW for convert-b-w(to, from) plain2
      │   │   └─ Name: CBW
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L870, C9]: mnemonic CBD for convert-b-d(to, from) plain2
      │   │   └─ Name: CBD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L871, C9]: mnemonic CBQ for convert-b-q(to, from) plain2
      │   │   └─ Name: CBQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L872, C9]: mnemonic CWD for convert-w-d(to, from) plain2
      │   │   └─ Name: CWD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L873, C9]: mnemonic CWQ for convert-w-q(to, from) plain2
      │   │   └─ Name: CWQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L874, C9]: mnemonic CDQ for convert-d-q(to, from) plain2
      │   │   └─ Name: CDQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L876, C9]: mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64
      │   │   └─ Name: NEG
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L880, C9]: mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64
      │   │   └─ Name: NOT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L884, C9]: mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L888, C9]: mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L893, C9]: mnemonic EQ for eq(reg1, reg2) plain2
      │   │   └─ Name: EQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L894, C9]: mnemonic NEQ for neq(reg1, reg2) plain2
      │   │   └─ Name: NEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L895, C9]: mnemonic GR for gr(reg1, reg2) plain2
      │   │   └─ Name: GR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L896, C9]: mnemonic LE for le(reg1, reg2) plain2
      │   │   └─ Name: LE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L897, C9]: mnemonic GREQ for greq(reg1, reg2) plain2
      │   │   └─ Name: GREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L898, C9]: mnemonic LEEQ for leeq(reg1, reg2) plain2
      │   │   └─ Name: LEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L900, C9]: mnemonic JMP for jmp(value) plain1
      │   │   └─ Name: JMP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L901, C9]: mnemonic JZ for jz(value) plain1
      │   │   └─ Name: JZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L902, C9]: mnemonic JNZ for jnz(value) plain1
      │   │   └─ Name: JNZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L903, C9]: mnemonic JEQ for jeq(reg1, reg2, value) plain3
      │   │   └─ Name: JEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L904, C9]: mnemonic JNEQ for jneq(reg1, reg2, value) plain3
      │   │   └─ Name: JNEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L905, C9]: mnemonic JGR for jgr(reg1, reg2, value) plain3
      │   │   └─ Name: JGR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L906, C9]: mnemonic JLE for jle(reg1, reg2, value) plain3
      │   │   └─ Name: JLE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L907, C9]: mnemonic JGREQ for jgreq(reg1, reg2, value) plain3
      │   │   └─ Name: JGREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L908, C9]: mnemonic JLEEQ for jleeq(reg1, reg2, value) plain3
      │   │   └─ Name: JLEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L910, C9]: mnemonic CALL for call(value) plain1
      │   │   └─ Name: CALL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L911, C9]: mnemonic ENTER for enter(value) plain1
      │   │   └─ Name: ENTER
      │   │ 
      │   └─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L912, C9]: mnemonic LEAVE for leave(value) plain1
      │       └─ Name: LEAVE
      │     
      ├─ Kind: Default
      └─ Name: myArch
    


