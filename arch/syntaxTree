Definition syntax tree at 14.04.2025 21:29:01

Parsing C:\RemoteTasks.Workspace\Sessions\VisualizeArchModel_771d0981-0710-4acb-9780-3d1b96db71f1\workdir\In\myArch.target.pdsl

 DefSyntaxTree at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [32];\n        storage AR_S [32];\n        storage ALR_S [32];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [32];\n        storage BP_S [32];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [8];\n        storage OUT_S [8];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n    instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction m_call = {0011 0011, 11, reg as objectPtr, 000000, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let vtablePtr = constantsM:8[classInfoPtr + 16];\n        let mAddr = constantsM:8[vtablePtr + offsetValue];\n\n        IP = mAddr;        \n    };\n\n    instruction f_load = {0011 0100, sequence size, reg as to, reg as objectPtr, 00 0000 0000, off32 as offsetValue} {\n        let addr = objectPtr + offsetValue;\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    instruction i_call = {0011 0011, 11, reg as objectPtr, reg as iid, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let interfaceCount = constantsM:8[classInfoPtr + 24];\n        \n        let i = 0; \n        let tmp = 0;\n        while i != interfaceCount do {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }\n\n        let interfaceImpl = constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i];\n\n        let mAddr = constantsM:8[interfaceImpl + offsetValue];\n\n        IP = mAddr;        \n    };\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;\n        mnemonic LDF for f_load(to, objectPtr, offsetValue) "b {1}, {2}, {3}" when sz8,\n                     for f_load(to, objectPtr, offsetValue) "w {1}, {2}, {3}" when sz16,\n                     for f_load(to, objectPtr, offsetValue) "d {1}, {2}, {3}" when sz32,\n                     for f_load(to, objectPtr, offsetValue) "q {1}, {2}, {3}" when sz64;\n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1) plain1;\n        mnemonic NEQ for neq(reg1) plain1;\n        mnemonic GR for gr(reg1) plain1;\n        mnemonic LE for le(reg1) plain1;\n        mnemonic GREQ for greq(reg1) plain1;\n        mnemonic LEEQ for leeq(reg1) plain1;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(value) plain1;\n        mnemonic JNEQ for jneq(value) plain1;\n        mnemonic JGR for jgr(value) plain1;\n        mnemonic JLE for jle(value) plain1;\n        mnemonic JGREQ for jgreq(value) plain1;\n        mnemonic JLEEQ for jleeq(value) plain1;\n\n        mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n        mnemonic MCALL for m_call(objectPtr, offsetValue) plain2;\n        mnemonic ICALL for i_call(objectPtr, iid, offsetValue) plain3;\n}
  └─ ArchitectureAspectSyntaxNode at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [32];\n        storage AR_S [32];\n        storage ALR_S [32];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [32];\n        storage BP_S [32];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [8];\n        storage OUT_S [8];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n    instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction m_call = {0011 0011, 11, reg as objectPtr, 000000, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let vtablePtr = constantsM:8[classInfoPtr + 16];\n        let mAddr = constantsM:8[vtablePtr + offsetValue];\n\n        IP = mAddr;        \n    };\n\n    instruction f_load = {0011 0100, sequence size, reg as to, reg as objectPtr, 00 0000 0000, off32 as offsetValue} {\n        let addr = objectPtr + offsetValue;\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    instruction i_call = {0011 0011, 11, reg as objectPtr, reg as iid, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let interfaceCount = constantsM:8[classInfoPtr + 24];\n        \n        let i = 0; \n        let tmp = 0;\n        while i != interfaceCount do {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }\n\n        let interfaceImpl = constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i];\n\n        let mAddr = constantsM:8[interfaceImpl + offsetValue];\n\n        IP = mAddr;        \n    };\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;\n        mnemonic LDF for f_load(to, objectPtr, offsetValue) "b {1}, {2}, {3}" when sz8,\n                     for f_load(to, objectPtr, offsetValue) "w {1}, {2}, {3}" when sz16,\n                     for f_load(to, objectPtr, offsetValue) "d {1}, {2}, {3}" when sz32,\n                     for f_load(to, objectPtr, offsetValue) "q {1}, {2}, {3}" when sz64;\n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1) plain1;\n        mnemonic NEQ for neq(reg1) plain1;\n        mnemonic GR for gr(reg1) plain1;\n        mnemonic LE for le(reg1) plain1;\n        mnemonic GREQ for greq(reg1) plain1;\n        mnemonic LEEQ for leeq(reg1) plain1;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(value) plain1;\n        mnemonic JNEQ for jneq(value) plain1;\n        mnemonic JGR for jgr(value) plain1;\n        mnemonic JLE for jle(value) plain1;\n        mnemonic JGREQ for jgreq(value) plain1;\n        mnemonic JLEEQ for jleeq(value) plain1;\n\n        mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n        mnemonic MCALL for m_call(objectPtr, offsetValue) plain2;\n        mnemonic ICALL for i_call(objectPtr, iid, offsetValue) plain3;\n}
      ├─ ArchRegistersSyntaxNode at [L3, C5]: registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [32];\n        storage AR_S [32];\n        storage ALR_S [32];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [32];\n        storage BP_S [32];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [8];\n        storage OUT_S [8];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];
      │   ├─ ArchRegsStorageItemSyntaxNode at [L5, C9]: storage R0_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R0_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L6, C9]: storage R1_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L7, C9]: storage R2_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L8, C9]: storage R3_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R3_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L9, C9]: storage R4_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R4_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L10, C9]: storage R5_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R5_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L11, C9]: storage R6_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R6_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L12, C9]: storage R7_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R7_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L15, C9]: view R0 = R0_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L15, C19]: R0_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L16, C9]: view R1 = R1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L16, C19]: R1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L17, C9]: view R2 = R2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L17, C19]: R2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L18, C9]: view R3 = R3_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L18, C19]: R3_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L19, C9]: view R4 = R4_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L19, C19]: R4_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L20, C9]: view R5 = R5_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L20, C19]: R5_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L21, C9]: view R6 = R6_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L21, C19]: R6_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L22, C9]: view R7 = R7_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L22, C19]: R7_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L25, C9]: storage IP_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: IP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L26, C9]: storage AR_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: AR_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L27, C9]: storage ALR_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: ALR_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L28, C9]: view IP = IP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L28, C19]: IP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IP_S
      │   │   │ 
      │   │   └─ Name: IP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L29, C9]: view AR = AR_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L29, C19]: AR_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: AR_S
      │   │   │ 
      │   │   └─ Name: AR
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L30, C9]: view ALR = ALR_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L30, C20]: ALR_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: ALR_S
      │   │   │ 
      │   │   └─ Name: ALR
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L33, C9]: storage SP_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: SP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L34, C9]: storage BP_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: BP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L35, C9]: storage BR1_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L36, C9]: storage BR2_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L37, C9]: storage RT_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: RT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L38, C9]: view SP = SP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L38, C19]: SP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: SP_S
      │   │   │ 
      │   │   └─ Name: SP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L39, C9]: view BP = BP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L39, C19]: BP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BP_S
      │   │   │ 
      │   │   └─ Name: BP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L40, C9]: view BR1 = BR1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L40, C20]: BR1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR1_S
      │   │   │ 
      │   │   └─ Name: BR1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L41, C9]: view BR2 = BR2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L41, C20]: BR2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR2_S
      │   │   │ 
      │   │   └─ Name: BR2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L42, C9]: view RT = RT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L42, C19]: RT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: RT_S
      │   │   │ 
      │   │   └─ Name: RT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L45, C9]: storage IN_S [8]
      │   │   ├─ Size: 8
      │   │   └─ Name: IN_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L46, C9]: storage OUT_S [8]
      │   │   ├─ Size: 8
      │   │   └─ Name: OUT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L47, C9]: view IN = IN_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L47, C19]: IN_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IN_S
      │   │   │ 
      │   │   └─ Name: IN
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L48, C9]: view OUT = OUT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L48, C20]: OUT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: OUT_S
      │   │   │ 
      │   │   └─ Name: OUT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L51, C9]: storage FLAGS_S [4]
      │   │   ├─ Size: 4
      │   │   └─ Name: FLAGS_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L52, C9]: view N = FLAGS_S[0]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L52, C18]: FLAGS_S[0]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 1
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: N
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L53, C9]: view Z = FLAGS_S[1]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L53, C18]: FLAGS_S[1]
      │   │   │   ├─ FromIndex: 1
      │   │   │   ├─ ToIndex: 2
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: Z
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L54, C9]: view V = FLAGS_S[2]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L54, C18]: FLAGS_S[2]
      │   │   │   ├─ FromIndex: 2
      │   │   │   ├─ ToIndex: 3
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: V
      │   │ 
      │   └─ ArchRegsViewItemSyntaxNode at [L55, C9]: view C = FLAGS_S[3]
      │       ├─ IsHidden: False
      │       ├─ ArchRegsViewWindowSyntaxNode at [L55, C18]: FLAGS_S[3]
      │       │   ├─ FromIndex: 3
      │       │   ├─ ToIndex: 4
      │       │   └─ Name: FLAGS_S
      │       │ 
      │       └─ Name: C
      │     
      ├─ ArchMemorySyntaxNode at [L58, C5]: memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L59, C9]: range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: codeM
      │   │ 
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L65, C9]: range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: constantsM
      │   │ 
      │   └─ ArchMemoryRangeItemSyntaxNode at [L71, C9]: range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │       ├─ AddressFrom: 0
      │       ├─ AddressTo: 4294967295
      │       ├─ CellSize: 8
      │       ├─ Endianess: Little
      │       ├─ Granularity: 0
      │       └─ Name: dataM
      │     
      ├─ ArchInstructionsSyntaxNode at [L77, C5]: instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n    instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction m_call = {0011 0011, 11, reg as objectPtr, 000000, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let vtablePtr = constantsM:8[classInfoPtr + 16];\n        let mAddr = constantsM:8[vtablePtr + offsetValue];\n\n        IP = mAddr;        \n    };\n\n    instruction f_load = {0011 0100, sequence size, reg as to, reg as objectPtr, 00 0000 0000, off32 as offsetValue} {\n        let addr = objectPtr + offsetValue;\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    instruction i_call = {0011 0011, 11, reg as objectPtr, reg as iid, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let interfaceCount = constantsM:8[classInfoPtr + 24];\n        \n        let i = 0; \n        let tmp = 0;\n        while i != interfaceCount do {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }\n\n        let interfaceImpl = constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i];\n\n        let mAddr = constantsM:8[interfaceImpl + offsetValue];\n\n        IP = mAddr;        \n    };
      │   ├─ ArchFieldEncodingSyntaxNode at [L78, C9]: encode imm32 field = immediate[32]
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L78, C30]: immediate[32]
      │   │   │   ├─ Length: 32
      │   │   │   ├─ Modifier: None
      │   │   │   └─ Kind: Default
      │   │   │ 
      │   │   └─ Name: imm32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L79, C9]: encode off32 field = immediate[32] offset
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L79, C30]: immediate[32] offset
      │   │   │   ├─ Length: 32
      │   │   │   ├─ Modifier: None
      │   │   │   └─ Kind: Offset
      │   │   │ 
      │   │   └─ Name: off32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L81, C9]: encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    }
      │   │   ├─ ArchFieldEncRegisterDescrSyntaxNode at [L81, C28]: register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    }
      │   │   │   └─ Modifier: None
      │   │   │ 
      │   │   └─ Name: reg
      │   │ 
      │   ├─ ArchFieldsGroupEncodingSyntaxNode at [L102, C9]: encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        }
      │   │   └─ Name: size
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L109, C5]: instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L109, C23]: {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L109, C24]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L109, C105]: {\n	}
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L109, C105]: {\n	}
      │   │   │ 
      │   │   └─ Name: nop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L113, C5]: instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L113, C23]: {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L113, C24]: 0000 0001
      │   │   │   │   └─ BitsStr: 0000 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L113, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L113, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L113, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L113, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L113, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L113, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L114, C9]: when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L114, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L114, C23]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L115, C13]: let res = reg1 + reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L115, C23]: reg1 + reg2
      │   │   │       │   │   │       ├─ Operator: Sum
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L115, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L115, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L116, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L116, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L117, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L117, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L117, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L117, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L117, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L117, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L118, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L118, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L118, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L118, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L118, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L118, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L118, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L118, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L118, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L119, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L119, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L119, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L119, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L119, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L119, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L119, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L119, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L119, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L120, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L120, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L120, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L120, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L120, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L120, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L120, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L120, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L120, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L120, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L120, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L120, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L120, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L120, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L120, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L120, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L120, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L120, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L121, C16]: when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L121, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L121, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L122, C13]: let res = reg1 + reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L122, C23]: reg1 + reg2
      │   │   │       │       │   │       ├─ Operator: Sum
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L122, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L122, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L123, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L123, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L124, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L124, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L124, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L124, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L124, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L124, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L125, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L125, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L125, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L125, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L125, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L125, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L125, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L125, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L125, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L126, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L126, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L126, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L126, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L126, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L126, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L126, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L126, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L126, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L127, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L127, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L127, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L127, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L127, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L127, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L127, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L127, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L127, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L127, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L127, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L127, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L127, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L127, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L127, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L127, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L127, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L127, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L128, C16]: when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L128, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L128, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L129, C13]: let res = reg1 + reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L129, C23]: reg1 + reg2
      │   │   │       │           │   │       ├─ Operator: Sum
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L129, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L129, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L130, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L130, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L131, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L131, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L131, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L131, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L131, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L131, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L132, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L132, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L132, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L132, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L132, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L132, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L132, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L132, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L132, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L133, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L133, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L133, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L133, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L133, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L133, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L133, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L133, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L133, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L134, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L134, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L134, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L134, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L134, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L134, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L134, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L134, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L134, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L134, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L134, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L134, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L134, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L134, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L134, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L134, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L134, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L134, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L135, C16]: when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L135, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L135, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L136, C13]: let res = reg1 + reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L136, C23]: reg1 + reg2
      │   │   │       │               │   │       ├─ Operator: Sum
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L136, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L136, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L137, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L137, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L138, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L138, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L138, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L138, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L138, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L138, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L139, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L139, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L139, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L139, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L139, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L139, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L139, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L139, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L139, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L140, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L140, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L140, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L140, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L140, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L140, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L140, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L140, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L140, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L141, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L141, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L141, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L141, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L141, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L141, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L141, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L141, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L141, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L141, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L141, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L141, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L141, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L141, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L141, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L141, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L141, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L141, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L144, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L144, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L144, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L144, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L144, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L144, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L145, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L145, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L145, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L145, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ElseBranchOrNull: <NULL>
      │   │   │       │ 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L148, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L148, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L148, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L148, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L148, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L148, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: add
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L151, C5]: instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L151, C30]: {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L151, C31]: 0000 0010
      │   │   │   │   └─ BitsStr: 0000 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L151, C42]: 10
      │   │   │   │   └─ BitsStr: 10
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L151, C46]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L151, C57]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L151, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L151, C79]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L151, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L151, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L152, C9]: to = value;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L152, C9]: to = value
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L152, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L152, C14]: value
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L154, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L154, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L154, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L154, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L154, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L154, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-imm32
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L157, C5]: instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L157, C24]: {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L157, C25]: 0000 0011
      │   │   │   │   └─ BitsStr: 0000 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L157, C36]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L157, C51]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L157, C62]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L157, C74]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L157, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L157, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L158, C9]: when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L158, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L158, C23]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L159, C13]: let res = dataM:8[ptr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L159, C23]: dataM:8[ptr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L159, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L159, C31]: ptr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L160, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L160, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L160, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L160, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L160, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L160, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L161, C16]: when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L161, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L161, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L162, C13]: let res = dataM:8[ptr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L162, C23]: dataM:8[ptr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L162, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L162, C31]: ptr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L163, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L163, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L163, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L163, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L163, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L163, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L164, C16]: when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L164, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L164, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L165, C13]: let res = dataM:8[ptr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L165, C23]: dataM:8[ptr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L165, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L165, C31]: ptr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L166, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L166, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L166, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L166, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L166, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L166, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L167, C16]: when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L167, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L167, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L168, C13]: let res = dataM:8[ptr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L168, C23]: dataM:8[ptr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L168, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L168, C31]: ptr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L169, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L169, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L169, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L169, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L169, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L169, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L171, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L171, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L171, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L171, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L171, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L171, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L174, C5]: instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L174, C25]: {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L174, C26]: 0000 0100
      │   │   │   │   └─ BitsStr: 0000 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L174, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L174, C52]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L174, C65]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L174, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L174, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L174, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L175, C9]: when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L175, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L175, C23]: {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L176, C13]: dataM:8[ptr] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L176, C13]: dataM:8[ptr] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L176, C13]: dataM:8[ptr]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L176, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnPlaceExprSyntaxNode at [L176, C21]: ptr
      │   │   │       │   │           │ 
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L176, C28]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L176, C28]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L176, C35]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L177, C16]: when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L177, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L177, C31]: {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L178, C13]: dataM:8[ptr] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L178, C13]: dataM:8[ptr] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L178, C13]: dataM:8[ptr]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L178, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnPlaceExprSyntaxNode at [L178, C21]: ptr
      │   │   │       │       │           │ 
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L178, C28]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L178, C28]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L178, C35]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L179, C16]: when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L179, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L179, C31]: {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L180, C13]: dataM:8[ptr] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L180, C13]: dataM:8[ptr] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L180, C13]: dataM:8[ptr]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L180, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnPlaceExprSyntaxNode at [L180, C21]: ptr
      │   │   │       │           │           │ 
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L180, C28]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L180, C28]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L180, C35]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L181, C16]: when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L181, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L181, C31]: {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L182, C13]: dataM:8[ptr] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L182, C13]: dataM:8[ptr] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L182, C13]: dataM:8[ptr]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L182, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnPlaceExprSyntaxNode at [L182, C21]: ptr
      │   │   │       │               │           │ 
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L182, C28]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L182, C28]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L182, C35]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L184, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L184, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L184, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L184, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L184, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L184, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L187, C5]: instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L187, C23]: {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C24]: 0000 0101
      │   │   │   │   └─ BitsStr: 0000 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L187, C39]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C52]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C60]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L187, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L187, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L188, C9]: OUT = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L188, C9]: OUT = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L188, C9]: OUT
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L188, C15]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L189, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L189, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L189, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L189, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L189, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L189, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: out
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L192, C5]: instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L192, C22]: {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L192, C23]: 0000 0110
      │   │   │   │   └─ BitsStr: 0000 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L192, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L192, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L192, C46]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L192, C57]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L192, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L192, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L193, C9]: to = IN;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L193, C9]: to = IN
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L193, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L193, C14]: IN
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L194, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L194, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L194, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L194, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L194, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L194, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: in
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L197, C5]: instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L197, C28]: {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L197, C29]: 0000 0111
      │   │   │   │   └─ BitsStr: 0000 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L197, C40]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L197, C55]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L197, C66]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L197, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L197, C92]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L197, C114]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L197, C114]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L198, C9]: let addr = 0;
      │   │   │       │   ├─ Name: addr
      │   │   │       │   └─ ArchInsnLiteralExprSyntaxNode at [L198, C20]: 0
      │   │   │       │       ├─ Kind: Dec
      │   │   │       │       └─ ValueString: 0
      │   │   │       │     
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L199, C9]: if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │   ├─ ArchInsnBinaryExprSyntaxNode at [L199, C12]: (offsetValue >> 31) & 1 == 1
      │   │   │       │   │   ├─ Operator: Equal
      │   │   │       │   │   ├─ ArchInsnBinaryExprSyntaxNode at [L199, C12]: (offsetValue >> 31) & 1
      │   │   │       │   │   │   ├─ Operator: BitsAnd
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L199, C12]: (offsetValue >> 31)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L199, C13]: offsetValue >> 31
      │   │   │       │   │   │   │       ├─ Operator: BitsShRight
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L199, C13]: offsetValue
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L199, C28]: 31
      │   │   │       │   │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │   │           └─ ValueString: 31
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L199, C34]: 1
      │   │   │       │   │   │       ├─ Kind: Dec
      │   │   │       │   │   │       └─ ValueString: 1
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnLiteralExprSyntaxNode at [L199, C39]: 1
      │   │   │       │   │       ├─ Kind: Dec
      │   │   │       │   │       └─ ValueString: 1
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L199, C46]: { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L200, C13]: let temp = offsetValue;
      │   │   │       │   │   │   ├─ Name: temp
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L200, C24]: offsetValue
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L201, C13]: addr = ptr + temp;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L201, C13]: addr = ptr + temp
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L201, C13]: addr
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L201, C20]: ptr + temp
      │   │   │       │   │               ├─ Operator: Sum
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L201, C20]: ptr
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L201, C26]: temp
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L202, C16]: { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L203, C13]: addr = ptr + offsetValue;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L203, C13]: addr = ptr + offsetValue
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L203, C13]: addr
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L203, C20]: ptr + offsetValue
      │   │   │       │                   ├─ Operator: Sum
      │   │   │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L203, C20]: ptr
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L203, C26]: offsetValue
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L205, C9]: addr = addr & 0x00000000ffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L205, C9]: addr = addr & 0x00000000ffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L205, C9]: addr
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L205, C16]: addr & 0x00000000ffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L205, C16]: addr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L205, C23]: 0x00000000ffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │             
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L206, C9]: when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L206, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L206, C23]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L207, C13]: let res = dataM:8[addr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L207, C23]: dataM:8[addr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L207, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L207, C31]: addr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L208, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L208, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L208, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L208, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L208, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L208, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L209, C16]: when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L209, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L209, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L210, C13]: let res = dataM:8[addr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L210, C23]: dataM:8[addr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L210, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L210, C31]: addr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L211, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L211, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L211, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L211, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L211, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L211, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L212, C16]: when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L212, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L212, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L213, C13]: let res = dataM:8[addr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L213, C23]: dataM:8[addr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L213, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L213, C31]: addr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L214, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L214, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L214, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L214, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L214, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L214, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L215, C16]: when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L215, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L215, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L216, C13]: let res = dataM:8[addr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L216, C23]: dataM:8[addr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L216, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L216, C31]: addr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L217, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L217, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L217, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L217, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L217, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L217, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L219, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L219, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L219, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L219, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L219, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L219, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L222, C5]: instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L222, C29]: {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C30]: 0000 1000
      │   │   │   │   └─ BitsStr: 0000 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L222, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L222, C56]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L222, C69]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C81]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L222, C95]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L222, C117]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L222, C117]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L223, C9]: let addr = 0;
      │   │   │       │   ├─ Name: addr
      │   │   │       │   └─ ArchInsnLiteralExprSyntaxNode at [L223, C20]: 0
      │   │   │       │       ├─ Kind: Dec
      │   │   │       │       └─ ValueString: 0
      │   │   │       │     
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L224, C9]: if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │   ├─ ArchInsnBinaryExprSyntaxNode at [L224, C12]: (offsetValue >> 31) & 1 == 1
      │   │   │       │   │   ├─ Operator: Equal
      │   │   │       │   │   ├─ ArchInsnBinaryExprSyntaxNode at [L224, C12]: (offsetValue >> 31) & 1
      │   │   │       │   │   │   ├─ Operator: BitsAnd
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L224, C12]: (offsetValue >> 31)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L224, C13]: offsetValue >> 31
      │   │   │       │   │   │   │       ├─ Operator: BitsShRight
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L224, C13]: offsetValue
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L224, C28]: 31
      │   │   │       │   │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │   │           └─ ValueString: 31
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L224, C34]: 1
      │   │   │       │   │   │       ├─ Kind: Dec
      │   │   │       │   │   │       └─ ValueString: 1
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnLiteralExprSyntaxNode at [L224, C39]: 1
      │   │   │       │   │       ├─ Kind: Dec
      │   │   │       │   │       └─ ValueString: 1
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L224, C46]: { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L225, C13]: let temp = offsetValue;
      │   │   │       │   │   │   ├─ Name: temp
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L225, C24]: offsetValue
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L226, C13]: addr = ptr + temp;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L226, C13]: addr = ptr + temp
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L226, C13]: addr
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L226, C20]: ptr + temp
      │   │   │       │   │               ├─ Operator: Sum
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L226, C20]: ptr
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L226, C26]: temp
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L227, C16]: { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L228, C13]: addr = ptr + offsetValue;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L228, C13]: addr = ptr + offsetValue
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L228, C13]: addr
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L228, C20]: ptr + offsetValue
      │   │   │       │                   ├─ Operator: Sum
      │   │   │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L228, C20]: ptr
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L228, C26]: offsetValue
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L230, C9]: addr = addr & 0x00000000ffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L230, C9]: addr = addr & 0x00000000ffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L230, C9]: addr
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L230, C16]: addr & 0x00000000ffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L230, C16]: addr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L230, C23]: 0x00000000ffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │             
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L231, C9]: when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L231, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L231, C23]: {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L232, C13]: dataM:8[addr] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L232, C13]: dataM:8[addr] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L232, C13]: dataM:8[addr]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L232, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnPlaceExprSyntaxNode at [L232, C21]: addr
      │   │   │       │   │           │ 
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L232, C29]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L232, C29]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L232, C36]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L233, C16]: when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L233, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L233, C31]: {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L234, C13]: dataM:8[addr] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L234, C13]: dataM:8[addr] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L234, C13]: dataM:8[addr]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L234, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnPlaceExprSyntaxNode at [L234, C21]: addr
      │   │   │       │       │           │ 
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L234, C29]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L234, C29]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L234, C36]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L235, C16]: when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L235, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L235, C31]: {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L236, C13]: dataM:8[addr] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L236, C13]: dataM:8[addr] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L236, C13]: dataM:8[addr]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L236, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnPlaceExprSyntaxNode at [L236, C21]: addr
      │   │   │       │           │           │ 
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L236, C29]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L236, C29]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L236, C36]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L237, C16]: when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L237, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L237, C31]: {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L238, C13]: dataM:8[addr] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L238, C13]: dataM:8[addr] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L238, C13]: dataM:8[addr]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L238, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnPlaceExprSyntaxNode at [L238, C21]: addr
      │   │   │       │               │           │ 
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L238, C29]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L238, C29]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L238, C36]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L240, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L240, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L240, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L240, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L240, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L240, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L243, C5]: instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L243, C24]: {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L243, C25]: 0000 1001
      │   │   │   │   └─ BitsStr: 0000 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L243, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L243, C40]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L243, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L243, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L243, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L243, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L244, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L244, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L244, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L244, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L244, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L244, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L245, C9]: dataM:8[SP] = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L245, C9]: dataM:8[SP] = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L245, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L245, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L245, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L245, C23]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L246, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L246, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L246, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L246, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L246, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L246, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: push
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L249, C5]: instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L249, C23]: {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L249, C24]: 0000 1010
      │   │   │   │   └─ BitsStr: 0000 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L249, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L249, C39]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L249, C50]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L249, C58]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L249, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L249, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L250, C9]: to = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L250, C9]: to = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L250, C9]: to
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L250, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L250, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L250, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L251, C9]: SP = SP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L251, C9]: SP = SP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L251, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L251, C14]: SP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L251, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L251, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L252, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L252, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L252, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L252, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L252, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L252, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: pop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L255, C5]: instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L255, C23]: {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L255, C24]: 0000 1011
      │   │   │   │   └─ BitsStr: 0000 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L255, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L255, C39]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L255, C50]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L255, C63]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L255, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L255, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L256, C9]: to = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L256, C9]: to = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L256, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L256, C14]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L257, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L257, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L257, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L257, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L257, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L257, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L262, C5]: instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L262, C29]: {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L262, C30]: 0000 1100
      │   │   │   │   └─ BitsStr: 0000 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L262, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L262, C56]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L262, C67]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L262, C80]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L262, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L262, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L263, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L263, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L263, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L264, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L264, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L264, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L264, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L264, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L264, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L265, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L265, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L265, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L266, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L266, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L266, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L266, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L266, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L266, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L267, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L267, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L267, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L268, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L268, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L268, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L268, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L268, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L268, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L269, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L269, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L269, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L270, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L270, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L270, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L270, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L270, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L270, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L272, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L272, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L272, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L272, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L272, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L272, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-trunc
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L277, C5]: instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L277, C26]: {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L277, C27]: 0000 1101
      │   │   │   │   └─ BitsStr: 0000 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L277, C38]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L277, C53]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L277, C64]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L277, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L277, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L277, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L278, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L278, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L278, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L279, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L279, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L279, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L279, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L279, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L279, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L280, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L280, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L280, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L281, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L281, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L281, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L281, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L281, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L281, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L282, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L282, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L282, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L283, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L283, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L283, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L283, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L283, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L283, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L284, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L284, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L284, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L285, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L285, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L285, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L285, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L285, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L285, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L287, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L287, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L287, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L287, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L287, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L287, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-zx
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L290, C5]: instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L290, C31]: {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L290, C32]: 0000 1110
      │   │   │   │   └─ BitsStr: 0000 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L290, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L290, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L290, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L290, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L290, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L290, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L291, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L291, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L291, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L291, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L291, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L291, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L291, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L292, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L292, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L292, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L292, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L293, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L293, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L293, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L293, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L293, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L293, C35]: {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L294, C13]: let ext_mask = 0x000000000000ff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L294, C28]: 0x000000000000ff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x000000000000ff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L295, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L295, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L295, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L295, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L295, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L295, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L296, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L297, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L297, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L297, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L297, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L299, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L299, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L299, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L299, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L299, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L299, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-w
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L302, C5]: instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L302, C31]: {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L302, C32]: 0000 1111
      │   │   │   │   └─ BitsStr: 0000 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L302, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L302, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L302, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L302, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L302, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L302, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L303, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L303, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L303, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L303, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L303, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L303, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L303, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L304, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L304, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L304, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L304, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L305, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L305, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L305, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L305, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L305, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L305, C35]: {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L306, C13]: let ext_mask = 0x00000000ffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L306, C28]: 0x00000000ffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L307, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L307, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L307, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L307, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L307, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L307, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L308, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L309, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L309, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L309, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L309, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L311, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L311, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L311, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L311, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L311, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L311, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L314, C5]: instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L314, C31]: {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L314, C32]: 0001 0000
      │   │   │   │   └─ BitsStr: 0001 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L314, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L314, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L314, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L314, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L314, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L314, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L315, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L315, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L315, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L315, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L315, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L315, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L315, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L316, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L316, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L316, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L316, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L317, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L317, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L317, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L317, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L317, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L317, C35]: {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L318, C13]: let ext_mask = 0xffffffffffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L318, C28]: 0xffffffffffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L319, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L319, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L319, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L319, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L319, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L319, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L320, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L321, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L321, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L321, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L321, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L323, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L323, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L323, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L323, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L323, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L323, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L326, C5]: instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L326, C31]: {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L326, C32]: 0001 0001
      │   │   │   │   └─ BitsStr: 0001 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L326, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L326, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L326, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L326, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L326, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L326, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L327, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L327, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L327, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L327, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L327, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L327, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L327, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L328, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L328, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L328, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L328, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L329, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L329, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L329, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L329, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L329, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L329, C35]: {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L330, C13]: let ext_mask = 0x00000000ffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L330, C28]: 0x00000000ffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L331, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L331, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L331, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L331, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L331, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L331, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L332, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L333, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L333, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L333, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L333, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L335, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L335, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L335, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L335, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L335, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L335, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L338, C5]: instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L338, C31]: {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L338, C32]: 0001 0010
      │   │   │   │   └─ BitsStr: 0001 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L338, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L338, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L338, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L338, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L338, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L338, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L339, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L339, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L339, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L339, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L339, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L339, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L339, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L340, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L340, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L340, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L340, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L341, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L341, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L341, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L341, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L341, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L341, C35]: {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L342, C13]: let ext_mask = 0xffffffffffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L342, C28]: 0xffffffffffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L343, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L343, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L343, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L343, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L343, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L343, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L344, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L345, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L345, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L345, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L345, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L347, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L347, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L347, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L347, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L347, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L347, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L351, C5]: instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L351, C31]: {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L351, C32]: 0001 0011
      │   │   │   │   └─ BitsStr: 0001 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L351, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L351, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L351, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L351, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L351, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L351, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L352, C9]: let sign_bit = (from >> 31) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L352, C24]: (from >> 31) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L352, C24]: (from >> 31)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L352, C25]: from >> 31
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L352, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L352, C33]: 31
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 31
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L352, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L353, C9]: let from_masked = from & 0xffffffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L353, C27]: from & 0xffffffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L353, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L353, C34]: 0xffffffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffffffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L354, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L354, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L354, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L354, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L354, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L354, C35]: {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L355, C13]: let ext_mask = 0xffffffff00000000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L355, C28]: 0xffffffff00000000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffff00000000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L356, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L356, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L356, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L356, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L356, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L356, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L357, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L358, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L358, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L358, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L358, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L360, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L360, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L360, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L360, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L360, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L360, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-d-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L363, C5]: instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L363, C23]: {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L363, C24]: 0001 0100
      │   │   │   │   └─ BitsStr: 0001 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L363, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L363, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L363, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L363, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L363, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L363, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L364, C9]: when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L364, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L364, C23]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L365, C13]: let res = reg1 - reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L365, C23]: reg1 - reg2
      │   │   │       │   │   │       ├─ Operator: Sub
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L365, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L365, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L366, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L366, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L367, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L367, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L367, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L367, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L367, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L367, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L368, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L368, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L368, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L368, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L368, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L368, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L368, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L368, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L368, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L369, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L369, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L369, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L369, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L369, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L369, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L369, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L369, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L369, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L370, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L370, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L370, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L370, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L370, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L370, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L370, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L370, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L370, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L370, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L370, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L370, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L370, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L370, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L370, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L370, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L370, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L370, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L371, C16]: when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L371, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L371, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L372, C13]: let res = reg1 - reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L372, C23]: reg1 - reg2
      │   │   │       │       │   │       ├─ Operator: Sub
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L372, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L372, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L373, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L373, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L374, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L374, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L374, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L374, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L374, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L374, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L375, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L375, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L375, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L375, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L375, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L375, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L375, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L375, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L375, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L376, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L376, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L376, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L376, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L376, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L376, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L376, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L376, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L376, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L377, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L377, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L377, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L377, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L377, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L377, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L377, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L377, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L377, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L377, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L377, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L377, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L377, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L377, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L377, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L377, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L377, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L377, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L378, C16]: when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L378, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L378, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L379, C13]: let res = reg1 - reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L379, C23]: reg1 - reg2
      │   │   │       │           │   │       ├─ Operator: Sub
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L379, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L379, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L380, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L380, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L381, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L381, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L381, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L381, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L381, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L381, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L382, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L382, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L382, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L382, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L382, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L382, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L382, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L382, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L382, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L383, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L383, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L383, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L383, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L383, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L383, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L383, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L383, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L383, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L384, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L384, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L384, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L384, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L384, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L384, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L384, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L384, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L384, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L384, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L384, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L384, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L384, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L384, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L384, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L384, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L384, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L384, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L385, C16]: when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L385, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L385, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L386, C13]: let res = reg1 - reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L386, C23]: reg1 - reg2
      │   │   │       │               │   │       ├─ Operator: Sub
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L386, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L386, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L387, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L387, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L388, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L388, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L388, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L388, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L388, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L388, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L389, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L389, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L389, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L389, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L389, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L389, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L389, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L389, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L389, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L390, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L390, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L390, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L390, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L390, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L390, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L390, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L390, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L390, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L391, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L391, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L391, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L391, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L391, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L391, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L391, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L391, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L391, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L391, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L391, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L391, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L391, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L391, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L391, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L391, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L391, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L391, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L394, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L394, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L394, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L394, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L394, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L394, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L395, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L395, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L395, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L395, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L396, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L397, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L397, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L397, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L397, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L400, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L400, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L400, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L400, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L400, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L400, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: sub
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L403, C5]: instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L403, C23]: {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L403, C24]: 0001 0101
      │   │   │   │   └─ BitsStr: 0001 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L403, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L403, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L403, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L403, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L403, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L403, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L404, C9]: when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L404, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L404, C23]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L405, C13]: let res = reg1 * reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L405, C23]: reg1 * reg2
      │   │   │       │   │   │       ├─ Operator: Mul
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L405, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L405, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L406, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L406, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L406, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L406, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L406, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L406, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L407, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L407, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L407, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L407, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L407, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L407, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L407, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L407, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L407, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L408, C16]: when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L408, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L408, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L409, C13]: let res = reg1 * reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L409, C23]: reg1 * reg2
      │   │   │       │       │   │       ├─ Operator: Mul
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L409, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L409, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L410, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L410, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L410, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L410, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L410, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L410, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L411, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L411, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L411, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L411, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L411, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L411, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L411, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L411, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L411, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L412, C16]: when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L412, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L412, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L413, C13]: let res = reg1 * reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L413, C23]: reg1 * reg2
      │   │   │       │           │   │       ├─ Operator: Mul
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L413, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L413, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L414, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L414, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L414, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L414, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L414, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L414, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L415, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L415, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L415, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L415, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L415, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L415, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L415, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L415, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L415, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L416, C16]: when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L416, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L416, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L417, C13]: let res = reg1 * reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L417, C23]: reg1 * reg2
      │   │   │       │               │   │       ├─ Operator: Mul
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L417, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L417, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L418, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L418, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L418, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L418, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L418, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L418, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L419, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L419, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L419, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L419, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L419, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L419, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L419, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L419, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L419, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L422, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L422, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L422, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L422, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L422, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L422, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L423, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L423, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L423, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L423, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L424, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L425, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L425, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L425, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L425, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L428, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L428, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L428, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L428, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L428, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L428, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mul
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L431, C5]: instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L431, C23]: {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L431, C24]: 0001 0110
      │   │   │   │   └─ BitsStr: 0001 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L431, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L431, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L431, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L431, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L431, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L431, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L432, C9]: when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L432, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L432, C23]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L433, C13]: let res = reg1 / reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L433, C23]: reg1 / reg2
      │   │   │       │   │   │       ├─ Operator: Div
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L433, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L433, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L434, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L434, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L434, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L434, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L434, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L434, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L435, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L435, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L435, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L435, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L435, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L435, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L435, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L435, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L435, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L436, C16]: when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L436, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L436, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L437, C13]: let res = reg1 / reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L437, C23]: reg1 / reg2
      │   │   │       │       │   │       ├─ Operator: Div
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L437, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L437, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L438, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L438, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L438, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L438, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L438, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L438, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L439, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L439, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L439, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L439, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L439, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L439, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L439, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L439, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L439, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L440, C16]: when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L440, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L440, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L441, C13]: let res = reg1 / reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L441, C23]: reg1 / reg2
      │   │   │       │           │   │       ├─ Operator: Div
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L441, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L441, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L442, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L442, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L442, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L442, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L442, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L442, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L443, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L443, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L443, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L443, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L443, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L443, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L443, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L443, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L443, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L444, C16]: when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L444, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L444, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L445, C13]: let res = reg1 / reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L445, C23]: reg1 / reg2
      │   │   │       │               │   │       ├─ Operator: Div
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L445, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L445, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L446, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L446, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L446, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L446, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L446, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L446, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L447, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L447, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L447, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L447, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L447, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L447, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L447, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L447, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L447, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L450, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L450, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L450, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L450, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L450, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L450, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L451, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L451, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L451, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L451, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L452, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L453, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L453, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L453, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L453, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L456, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L456, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L456, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L456, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L456, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L456, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: div
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L459, C5]: instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L459, C23]: {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L459, C24]: 0001 0111
      │   │   │   │   └─ BitsStr: 0001 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L459, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L459, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L459, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L459, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L459, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L459, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L460, C9]: when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L460, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L460, C23]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L461, C13]: let res = reg1 % reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L461, C23]: reg1 % reg2
      │   │   │       │   │   │       ├─ Operator: Mod
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L461, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L461, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L462, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L462, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L462, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L462, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L462, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L462, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L463, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L463, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L463, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L463, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L463, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L463, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L463, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L463, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L463, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L464, C16]: when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L464, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L464, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L465, C13]: let res = reg1 % reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L465, C23]: reg1 % reg2
      │   │   │       │       │   │       ├─ Operator: Mod
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L465, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L465, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L466, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L466, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L466, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L466, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L466, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L466, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L467, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L467, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L467, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L467, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L467, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L467, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L467, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L467, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L467, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L468, C16]: when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L468, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L468, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L469, C13]: let res = reg1 % reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L469, C23]: reg1 % reg2
      │   │   │       │           │   │       ├─ Operator: Mod
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L469, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L469, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L470, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L470, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L470, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L470, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L470, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L470, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L471, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L471, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L471, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L471, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L471, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L471, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L471, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L471, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L471, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L472, C16]: when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L472, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L472, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L473, C13]: let res = reg1 % reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L473, C23]: reg1 % reg2
      │   │   │       │               │   │       ├─ Operator: Mod
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L473, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L473, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L474, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L474, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L474, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L474, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L474, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L474, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L475, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L475, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L475, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L475, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L475, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L475, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L475, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L475, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L475, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L478, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L478, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L478, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L478, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L478, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L478, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L479, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L479, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L479, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L479, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L480, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L481, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L481, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L481, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L481, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L484, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L484, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L484, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L484, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L484, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L484, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mod
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L487, C5]: instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L487, C23]: {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L487, C24]: 0001 1000
      │   │   │   │   └─ BitsStr: 0001 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L487, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L487, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L487, C63]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L487, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L487, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L487, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L488, C9]: when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L488, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L488, C23]: {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L489, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L489, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L490, C13]: if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L490, C16]: (reg1 == 0x80)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L490, C17]: reg1 == 0x80
      │   │   │       │   │   │   │       ├─ Operator: Equal
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L490, C17]: reg1
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L490, C25]: 0x80
      │   │   │       │   │   │   │           ├─ Kind: Hex
      │   │   │       │   │   │   │           └─ ValueString: 0x80
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L490, C36]: {\n                V = 1;\n            }
      │   │   │       │   │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L491, C17]: V = 1;
      │   │   │       │   │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L491, C17]: V = 1
      │   │   │       │   │   │   │           ├─ Operator: Assign
      │   │   │       │   │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L491, C17]: V
      │   │   │       │   │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L491, C21]: 1
      │   │   │       │   │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │   │               └─ ValueString: 1
      │   │   │       │   │   │   │             
      │   │   │       │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L492, C20]: {\n                V = 0;\n            }
      │   │   │       │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L493, C17]: V = 0;
      │   │   │       │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L493, C17]: V = 0
      │   │   │       │   │   │               ├─ Operator: Assign
      │   │   │       │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L493, C17]: V
      │   │   │       │   │   │               └─ ArchInsnLiteralExprSyntaxNode at [L493, C21]: 0
      │   │   │       │   │   │                   ├─ Kind: Dec
      │   │   │       │   │   │                   └─ ValueString: 0
      │   │   │       │   │   │                 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L495, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L495, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L495, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L495, C20]: ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L495, C20]: ((~res) + 1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L495, C21]: (~res) + 1
      │   │   │       │   │   │           │       ├─ Operator: Sum
      │   │   │       │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L495, C21]: (~res)
      │   │   │       │   │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L495, C22]: ~res
      │   │   │       │   │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L495, C23]: res
      │   │   │       │   │   │           │       │       └─ IsPrefix: True
      │   │   │       │   │   │           │       │     
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L495, C30]: 1
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 1
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L495, C35]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L496, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L496, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L496, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L496, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L496, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L496, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L496, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L496, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L496, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L497, C16]: when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L497, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L497, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L498, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L498, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L499, C13]: if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │       │   │   ├─ ArchInsnBracesExprSyntaxNode at [L499, C16]: (reg1 == 0x8000)
      │   │   │       │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L499, C17]: reg1 == 0x8000
      │   │   │       │       │   │   │       ├─ Operator: Equal
      │   │   │       │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L499, C17]: reg1
      │   │   │       │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L499, C25]: 0x8000
      │   │   │       │       │   │   │           ├─ Kind: Hex
      │   │   │       │       │   │   │           └─ ValueString: 0x8000
      │   │   │       │       │   │   │         
      │   │   │       │       │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L499, C38]: {\n                V = 1;\n            }
      │   │   │       │       │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L500, C17]: V = 1;
      │   │   │       │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L500, C17]: V = 1
      │   │   │       │       │   │   │           ├─ Operator: Assign
      │   │   │       │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L500, C17]: V
      │   │   │       │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L500, C21]: 1
      │   │   │       │       │   │   │               ├─ Kind: Dec
      │   │   │       │       │   │   │               └─ ValueString: 1
      │   │   │       │       │   │   │             
      │   │   │       │       │   │   └─ ArchInsnBlockStmtSyntaxNode at [L501, C20]: {\n                V = 0;\n            }
      │   │   │       │       │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L502, C17]: V = 0;
      │   │   │       │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L502, C17]: V = 0
      │   │   │       │       │   │               ├─ Operator: Assign
      │   │   │       │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L502, C17]: V
      │   │   │       │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L502, C21]: 0
      │   │   │       │       │   │                   ├─ Kind: Dec
      │   │   │       │       │   │                   └─ ValueString: 0
      │   │   │       │       │   │                 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L504, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L504, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L504, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L504, C20]: ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L504, C20]: ((~res) + 1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L504, C21]: (~res) + 1
      │   │   │       │       │   │           │       ├─ Operator: Sum
      │   │   │       │       │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L504, C21]: (~res)
      │   │   │       │       │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L504, C22]: ~res
      │   │   │       │       │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │       │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L504, C23]: res
      │   │   │       │       │   │           │       │       └─ IsPrefix: True
      │   │   │       │       │   │           │       │     
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L504, C30]: 1
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 1
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L504, C35]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L505, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L505, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L505, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L505, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L505, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L505, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L505, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L505, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L505, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L506, C16]: when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L506, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L506, C31]: {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L507, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L507, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L508, C13]: if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │           │   │   ├─ ArchInsnBracesExprSyntaxNode at [L508, C16]: (reg1 == 0x80000000)
      │   │   │       │           │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L508, C17]: reg1 == 0x80000000
      │   │   │       │           │   │   │       ├─ Operator: Equal
      │   │   │       │           │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L508, C17]: reg1
      │   │   │       │           │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L508, C25]: 0x80000000
      │   │   │       │           │   │   │           ├─ Kind: Hex
      │   │   │       │           │   │   │           └─ ValueString: 0x80000000
      │   │   │       │           │   │   │         
      │   │   │       │           │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L508, C42]: {\n                V = 1;\n            }
      │   │   │       │           │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L509, C17]: V = 1;
      │   │   │       │           │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L509, C17]: V = 1
      │   │   │       │           │   │   │           ├─ Operator: Assign
      │   │   │       │           │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L509, C17]: V
      │   │   │       │           │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L509, C21]: 1
      │   │   │       │           │   │   │               ├─ Kind: Dec
      │   │   │       │           │   │   │               └─ ValueString: 1
      │   │   │       │           │   │   │             
      │   │   │       │           │   │   └─ ArchInsnBlockStmtSyntaxNode at [L510, C20]: {\n                V = 0;\n            }
      │   │   │       │           │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L511, C17]: V = 0;
      │   │   │       │           │   │           └─ ArchInsnBinaryExprSyntaxNode at [L511, C17]: V = 0
      │   │   │       │           │   │               ├─ Operator: Assign
      │   │   │       │           │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L511, C17]: V
      │   │   │       │           │   │               └─ ArchInsnLiteralExprSyntaxNode at [L511, C21]: 0
      │   │   │       │           │   │                   ├─ Kind: Dec
      │   │   │       │           │   │                   └─ ValueString: 0
      │   │   │       │           │   │                 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L513, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L513, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L513, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L513, C20]: ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L513, C20]: ((~res) + 1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L513, C21]: (~res) + 1
      │   │   │       │           │   │           │       ├─ Operator: Sum
      │   │   │       │           │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L513, C21]: (~res)
      │   │   │       │           │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L513, C22]: ~res
      │   │   │       │           │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │           │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L513, C23]: res
      │   │   │       │           │   │           │       │       └─ IsPrefix: True
      │   │   │       │           │   │           │       │     
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L513, C30]: 1
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 1
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L513, C35]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L514, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L514, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L514, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L514, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L514, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L514, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L514, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L514, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L514, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L515, C16]: when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L515, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L515, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L516, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L516, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L517, C13]: if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │               │   │   ├─ ArchInsnBracesExprSyntaxNode at [L517, C16]: (reg1 == 0x8000000000000000)
      │   │   │       │               │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L517, C17]: reg1 == 0x8000000000000000
      │   │   │       │               │   │   │       ├─ Operator: Equal
      │   │   │       │               │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L517, C17]: reg1
      │   │   │       │               │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L517, C25]: 0x8000000000000000
      │   │   │       │               │   │   │           ├─ Kind: Hex
      │   │   │       │               │   │   │           └─ ValueString: 0x8000000000000000
      │   │   │       │               │   │   │         
      │   │   │       │               │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L517, C50]: {\n                V = 1;\n            }
      │   │   │       │               │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L518, C17]: V = 1;
      │   │   │       │               │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L518, C17]: V = 1
      │   │   │       │               │   │   │           ├─ Operator: Assign
      │   │   │       │               │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L518, C17]: V
      │   │   │       │               │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L518, C21]: 1
      │   │   │       │               │   │   │               ├─ Kind: Dec
      │   │   │       │               │   │   │               └─ ValueString: 1
      │   │   │       │               │   │   │             
      │   │   │       │               │   │   └─ ArchInsnBlockStmtSyntaxNode at [L519, C20]: {\n                V = 0;\n            }
      │   │   │       │               │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L520, C17]: V = 0;
      │   │   │       │               │   │           └─ ArchInsnBinaryExprSyntaxNode at [L520, C17]: V = 0
      │   │   │       │               │   │               ├─ Operator: Assign
      │   │   │       │               │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L520, C17]: V
      │   │   │       │               │   │               └─ ArchInsnLiteralExprSyntaxNode at [L520, C21]: 0
      │   │   │       │               │   │                   ├─ Kind: Dec
      │   │   │       │               │   │                   └─ ValueString: 0
      │   │   │       │               │   │                 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L522, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L522, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L522, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L522, C20]: ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L522, C20]: ((~res) + 1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L522, C21]: (~res) + 1
      │   │   │       │               │   │           │       ├─ Operator: Sum
      │   │   │       │               │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L522, C21]: (~res)
      │   │   │       │               │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L522, C22]: ~res
      │   │   │       │               │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │               │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L522, C23]: res
      │   │   │       │               │   │           │       │       └─ IsPrefix: True
      │   │   │       │               │   │           │       │     
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L522, C30]: 1
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 1
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L522, C35]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L523, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L523, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L523, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L523, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L523, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L523, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L523, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L523, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L523, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L526, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L526, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L526, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L526, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L526, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L526, C31]: {\n            Z = 1;\n            C = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L527, C13]: Z = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L527, C13]: Z = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L527, C13]: Z
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L527, C17]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L528, C13]: C = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L528, C13]: C = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L528, C13]: C
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L528, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L529, C16]: {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L530, C13]: Z = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L530, C13]: Z = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L530, C13]: Z
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L530, C17]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L531, C13]: C = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L531, C13]: C = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L531, C13]: C
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L531, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L534, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L534, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L534, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L534, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L534, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L534, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neg
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L537, C5]: instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L537, C25]: {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L537, C26]: 0001 1001
      │   │   │   │   └─ BitsStr: 0001 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L537, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L537, C52]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L537, C65]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L537, C73]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L537, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L537, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L538, C9]: when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L538, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L538, C23]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L539, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L539, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L540, C13]: reg1 = (~res) & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L540, C13]: reg1 = (~res) & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L540, C13]: reg1
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L540, C20]: (~res) & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L540, C20]: (~res)
      │   │   │       │   │               │   └─ ArchInsnUnaryExprSyntaxNode at [L540, C21]: ~res
      │   │   │       │   │               │       ├─ Operator: BitsInv
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L540, C22]: res
      │   │   │       │   │               │       └─ IsPrefix: True
      │   │   │       │   │               │     
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L540, C29]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L541, C16]: when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L541, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L541, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L542, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L542, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L543, C13]: reg1 = (~res) & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L543, C13]: reg1 = (~res) & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L543, C13]: reg1
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L543, C20]: (~res) & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L543, C20]: (~res)
      │   │   │       │       │               │   └─ ArchInsnUnaryExprSyntaxNode at [L543, C21]: ~res
      │   │   │       │       │               │       ├─ Operator: BitsInv
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L543, C22]: res
      │   │   │       │       │               │       └─ IsPrefix: True
      │   │   │       │       │               │     
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L543, C29]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L544, C16]: when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L544, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L544, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L545, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L545, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L546, C13]: reg1 = (~res) & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L546, C13]: reg1 = (~res) & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L546, C13]: reg1
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L546, C20]: (~res) & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L546, C20]: (~res)
      │   │   │       │           │               │   └─ ArchInsnUnaryExprSyntaxNode at [L546, C21]: ~res
      │   │   │       │           │               │       ├─ Operator: BitsInv
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L546, C22]: res
      │   │   │       │           │               │       └─ IsPrefix: True
      │   │   │       │           │               │     
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L546, C29]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L547, C16]: when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L547, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L547, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L548, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L548, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L549, C13]: reg1 = (~res) & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L549, C13]: reg1 = (~res) & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L549, C13]: reg1
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L549, C20]: (~res) & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L549, C20]: (~res)
      │   │   │       │               │               │   └─ ArchInsnUnaryExprSyntaxNode at [L549, C21]: ~res
      │   │   │       │               │               │       ├─ Operator: BitsInv
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L549, C22]: res
      │   │   │       │               │               │       └─ IsPrefix: True
      │   │   │       │               │               │     
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L549, C29]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L552, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L552, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L552, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L552, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L552, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L552, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L553, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L553, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L553, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L553, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L554, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L555, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L555, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L555, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L555, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L558, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L558, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L558, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L558, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L558, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L558, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: not-i
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L561, C5]: instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L561, C23]: {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L561, C24]: 0001 1010
      │   │   │   │   └─ BitsStr: 0001 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L561, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L561, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L561, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L561, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L561, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L561, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L562, C9]: when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L562, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L562, C23]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L563, C13]: let res = reg1 & reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L563, C23]: reg1 & reg2
      │   │   │       │   │   │       ├─ Operator: BitsAnd
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L563, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L563, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L564, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L564, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L564, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L564, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L564, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L564, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L565, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L565, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L565, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L565, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L565, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L565, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L565, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L565, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L565, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L566, C16]: when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L566, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L566, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L567, C13]: let res = reg1 & reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L567, C23]: reg1 & reg2
      │   │   │       │       │   │       ├─ Operator: BitsAnd
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L567, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L567, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L568, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L568, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L568, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L568, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L568, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L568, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L569, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L569, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L569, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L569, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L569, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L569, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L569, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L569, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L569, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L570, C16]: when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L570, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L570, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L571, C13]: let res = reg1 & reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L571, C23]: reg1 & reg2
      │   │   │       │           │   │       ├─ Operator: BitsAnd
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L571, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L571, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L572, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L572, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L572, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L572, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L572, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L572, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L573, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L573, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L573, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L573, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L573, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L573, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L573, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L573, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L573, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L574, C16]: when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L574, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L574, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L575, C13]: let res = reg1 & reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L575, C23]: reg1 & reg2
      │   │   │       │               │   │       ├─ Operator: BitsAnd
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L575, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L575, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L576, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L576, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L576, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L576, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L576, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L576, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L577, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L577, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L577, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L577, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L577, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L577, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L577, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L577, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L577, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L580, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L580, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L580, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L580, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L580, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L580, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L581, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L581, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L581, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L581, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L582, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L583, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L583, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L583, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L583, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L586, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L586, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L586, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L586, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L586, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L586, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L589, C5]: instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L589, C22]: {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L589, C23]: 0001 1011
      │   │   │   │   └─ BitsStr: 0001 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L589, C34]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L589, C49]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L589, C62]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L589, C75]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L589, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L589, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L590, C9]: when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L590, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L590, C23]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L591, C13]: let res = reg1 | reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L591, C23]: reg1 | reg2
      │   │   │       │   │   │       ├─ Operator: BitsOr
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L591, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L591, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L592, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L592, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L592, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L592, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L592, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L592, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L593, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L593, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L593, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L593, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L593, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L593, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L593, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L593, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L593, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L594, C16]: when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L594, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L594, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L595, C13]: let res = reg1 | reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L595, C23]: reg1 | reg2
      │   │   │       │       │   │       ├─ Operator: BitsOr
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L595, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L595, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L596, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L596, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L596, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L596, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L596, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L596, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L597, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L597, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L597, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L597, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L597, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L597, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L597, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L597, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L597, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L598, C16]: when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L598, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L598, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L599, C13]: let res = reg1 | reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L599, C23]: reg1 | reg2
      │   │   │       │           │   │       ├─ Operator: BitsOr
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L599, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L599, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L600, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L600, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L600, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L600, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L600, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L600, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L601, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L601, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L601, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L601, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L601, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L601, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L601, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L601, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L601, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L602, C16]: when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L602, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L602, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L603, C13]: let res = reg1 | reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L603, C23]: reg1 | reg2
      │   │   │       │               │   │       ├─ Operator: BitsOr
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L603, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L603, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L604, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L604, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L604, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L604, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L604, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L604, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L605, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L605, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L605, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L605, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L605, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L605, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L605, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L605, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L605, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L608, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L608, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L608, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L608, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L608, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L608, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L609, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L609, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L609, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L609, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L610, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L611, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L611, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L611, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L611, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L614, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L614, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L614, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L614, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L614, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L614, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L617, C5]: instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L617, C22]: {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L617, C23]: 0001 1100
      │   │   │   │   └─ BitsStr: 0001 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L617, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L617, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L617, C46]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L617, C54]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L617, C68]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L617, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L617, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L618, C9]: if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L618, C12]: (Z == 0x1)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L618, C13]: Z == 0x1
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L618, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L618, C18]: 0x1
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x1
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L618, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L619, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L619, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L619, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L619, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L620, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L621, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L621, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L621, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L621, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L621, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L621, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L625, C5]: instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L625, C23]: {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C24]: 0001 1101
      │   │   │   │   └─ BitsStr: 0001 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L625, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L625, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L625, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L625, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L626, C9]: if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L626, C12]: (Z == 0x0)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L626, C13]: Z == 0x0
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L626, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L626, C18]: 0x0
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x0
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L626, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L627, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L627, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L627, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L627, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L628, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L629, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L629, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L629, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L629, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L629, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L629, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jnz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L633, C5]: instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L633, C23]: {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C24]: 0001 1110
      │   │   │   │   └─ BitsStr: 0001 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L633, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L633, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L633, C85]: {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L633, C85]: {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L634, C9]: if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L634, C12]: (Z == 1)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L634, C13]: Z == 1
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L634, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L634, C18]: 1
      │   │   │           │           ├─ Kind: Dec
      │   │   │           │           └─ ValueString: 1
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L634, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L635, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L635, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L635, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L635, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L636, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L637, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L637, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L637, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L637, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L637, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L637, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L641, C5]: instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L641, C24]: {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C25]: 0001 1111
      │   │   │   │   └─ BitsStr: 0001 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C40]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C48]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C56]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L641, C70]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L641, C86]: {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L641, C86]: {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L642, C9]: if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L642, C12]: (Z == 0)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L642, C13]: Z == 0
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L642, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L642, C18]: 0
      │   │   │           │           ├─ Kind: Dec
      │   │   │           │           └─ ValueString: 0
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L642, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L643, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L643, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L643, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L643, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L644, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L645, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L645, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L645, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L645, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L645, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L645, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jneq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L649, C5]: instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L649, C23]: {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C24]: 0010 0000
      │   │   │   │   └─ BitsStr: 0010 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L649, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L649, C85]: {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L649, C85]: {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L650, C9]: if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L650, C12]: ((N == V) && !Z)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L650, C13]: (N == V) && !Z
      │   │   │           │       ├─ Operator: BoolAnd
      │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L650, C13]: (N == V)
      │   │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L650, C14]: N == V
      │   │   │           │       │       ├─ Operator: Equal
      │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L650, C14]: N
      │   │   │           │       │       └─ ArchInsnPlaceExprSyntaxNode at [L650, C19]: V
      │   │   │           │       │     
      │   │   │           │       └─ ArchInsnUnaryExprSyntaxNode at [L650, C25]: !Z
      │   │   │           │           ├─ Operator: BoolInv
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L650, C26]: Z
      │   │   │           │           └─ IsPrefix: True
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L650, C34]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L651, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L651, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L651, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L651, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L652, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L653, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L653, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L653, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L653, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L653, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L653, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L657, C5]: instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L657, C23]: {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C24]: 0010 0001
      │   │   │   │   └─ BitsStr: 0010 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L657, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L657, C85]: {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L657, C85]: {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L658, C9]: if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L658, C12]: (N != V)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L658, C13]: N != V
      │   │   │           │       ├─ Operator: NotEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L658, C13]: N
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L658, C18]: V
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L658, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L659, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L659, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L659, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L659, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L660, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L661, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L661, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L661, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L661, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L661, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L661, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jle
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L665, C5]: instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L665, C25]: {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C26]: 0010 0010
      │   │   │   │   └─ BitsStr: 0010 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L665, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L665, C87]: {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L665, C87]: {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L666, C9]: if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L666, C12]: (N == V)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L666, C13]: N == V
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L666, C13]: N
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L666, C18]: V
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L666, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L667, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L667, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L667, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L667, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L668, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L669, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L669, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L669, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L669, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L669, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L669, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgreq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L673, C5]: instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L673, C25]: {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C26]: 0010 0011
      │   │   │   │   └─ BitsStr: 0010 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L673, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L673, C87]: {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L673, C87]: {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L674, C9]: if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L674, C12]: ((N != V) || Z)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L674, C13]: (N != V) || Z
      │   │   │           │       ├─ Operator: BoolOr
      │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L674, C13]: (N != V)
      │   │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L674, C14]: N != V
      │   │   │           │       │       ├─ Operator: NotEqual
      │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L674, C14]: N
      │   │   │           │       │       └─ ArchInsnPlaceExprSyntaxNode at [L674, C19]: V
      │   │   │           │       │     
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L674, C25]: Z
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L674, C33]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L675, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L675, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L675, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L675, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L676, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L677, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L677, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L677, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L677, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L677, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L677, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jleeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L681, C5]: instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L681, C23]: {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C24]: 0010 0100
      │   │   │   │   └─ BitsStr: 0010 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L681, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L681, C85]: {\n        IP = value;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L681, C85]: {\n        IP = value;\n    }
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L682, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L682, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L682, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L682, C14]: value
      │   │   │             
      │   │   └─ Name: jmp
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L685, C5]: instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L685, C24]: {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L685, C25]: 0010 0101
      │   │   │   │   └─ BitsStr: 0010 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L685, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L685, C40]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L685, C48]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L685, C56]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L685, C70]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L685, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L685, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L686, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L686, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L686, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L686, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L686, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L686, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L687, C9]: dataM:8[SP] = IP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L687, C9]: dataM:8[SP] = IP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L687, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L687, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L687, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L687, C23]: IP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L687, C23]: IP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L687, C28]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L688, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L688, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L688, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L688, C14]: value
      │   │   │             
      │   │   └─ Name: call
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L691, C5]: instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L691, C23]: {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L691, C24]: 0010 0110
      │   │   │   │   └─ BitsStr: 0010 0110
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L691, C35]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L691, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L691, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L692, C9]: IP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L692, C9]: IP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L692, C9]: IP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L692, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L692, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L692, C22]: SP
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L693, C9]: SP = SP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L693, C9]: SP = SP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L693, C9]: SP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L693, C14]: SP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L693, C14]: SP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L693, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: ret
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L696, C5]: instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L696, C25]: {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L696, C26]: 0010 0111
      │   │   │   │   └─ BitsStr: 0010 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L696, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L696, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L696, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L696, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L696, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L696, C87]: {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L696, C87]: {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L697, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L697, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L697, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L697, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L697, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L697, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L698, C9]: dataM:8[SP] = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L698, C9]: dataM:8[SP] = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L698, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L698, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L698, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L698, C23]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L699, C9]: BP = SP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L699, C9]: BP = SP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L699, C9]: BP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L699, C14]: SP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L700, C9]: SP = SP - (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L700, C9]: SP = SP - (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L700, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L700, C14]: SP - (8 * value)
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L700, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L700, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L700, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L700, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L700, C24]: value
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L701, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L701, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L701, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L701, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L701, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L701, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: enter
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L704, C5]: instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L704, C25]: {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C26]: 0010 1000
      │   │   │   │   └─ BitsStr: 0010 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L704, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L704, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L704, C87]: {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L704, C87]: {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L705, C9]: SP = SP + (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L705, C9]: SP = SP + (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L705, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L705, C14]: SP + (8 * value)
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L705, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L705, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L705, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L705, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L705, C24]: value
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L706, C9]: SP = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L706, C9]: SP = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L706, C9]: SP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L706, C14]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L707, C9]: BP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L707, C9]: BP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L707, C9]: BP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L707, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L707, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L707, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L708, C9]: SP = SP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L708, C9]: SP = SP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L708, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L708, C14]: SP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L708, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L708, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L709, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L709, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L709, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L709, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L709, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L709, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leave
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L712, C5]: instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L712, C30]: {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L712, C31]: 0010 1001
      │   │   │   │   └─ BitsStr: 0010 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L712, C42]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L712, C46]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L712, C57]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L712, C69]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L712, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L712, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L713, C9]: let res = constantsM:8[ptr];
      │   │   │       │   ├─ Name: res
      │   │   │       │   └─ ArchInsnIndexerExprSyntaxNode at [L713, C19]: constantsM:8[ptr]
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L713, C19]: constantsM:8
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L713, C32]: ptr
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L714, C9]: to = res & 0xffffffffffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L714, C9]: to = res & 0xffffffffffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L714, C9]: to
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L714, C14]: res & 0xffffffffffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L714, C14]: res
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L714, C20]: 0xffffffffffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L715, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L715, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L715, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L715, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L715, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L715, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-const
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L718, C5]: instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L718, C22]: {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L718, C23]: 0010 1010
      │   │   │   │   └─ BitsStr: 0010 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L718, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L718, C38]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L718, C51]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L718, C59]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L718, C113]: {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L718, C113]: {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L719, C9]: if (Z == 1) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L719, C12]: (Z == 1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L719, C13]: Z == 1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L719, C13]: Z
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L719, C18]: 1
      │   │   │       │   │           ├─ Kind: Dec
      │   │   │       │   │           └─ ValueString: 1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L719, C26]: {\n            reg1 = 1;\n            Z = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L720, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L720, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L720, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L720, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L721, C13]: Z = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L721, C13]: Z = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L721, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L721, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L722, C16]: {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L723, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L723, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L723, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L723, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L724, C13]: Z = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L724, C13]: Z = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L724, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L724, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L726, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L726, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L726, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L726, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L726, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L726, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: eq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L729, C5]: instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L729, C23]: {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L729, C24]: 0010 1011
      │   │   │   │   └─ BitsStr: 0010 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L729, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L729, C39]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L729, C52]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L729, C60]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L729, C114]: {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L729, C114]: {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L730, C9]: if (Z == 0) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L730, C12]: (Z == 0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L730, C13]: Z == 0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L730, C13]: Z
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L730, C18]: 0
      │   │   │       │   │           ├─ Kind: Dec
      │   │   │       │   │           └─ ValueString: 0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L730, C26]: {\n            reg1 = 1;\n            Z = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L731, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L731, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L731, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L731, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L732, C13]: Z = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L732, C13]: Z = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L732, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L732, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L733, C16]: {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L734, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L734, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L734, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L734, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L735, C13]: Z = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L735, C13]: Z = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L735, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L735, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L737, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L737, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L737, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L737, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L737, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L737, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L740, C5]: instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L740, C22]: {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L740, C23]: 0010 1100
      │   │   │   │   └─ BitsStr: 0010 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L740, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L740, C38]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L740, C51]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L740, C59]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L740, C113]: {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L740, C113]: {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L741, C9]: if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L741, C12]: ((N == V) && !Z)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L741, C13]: (N == V) && !Z
      │   │   │       │   │       ├─ Operator: BoolAnd
      │   │   │       │   │       ├─ ArchInsnBracesExprSyntaxNode at [L741, C13]: (N == V)
      │   │   │       │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L741, C14]: N == V
      │   │   │       │   │       │       ├─ Operator: Equal
      │   │   │       │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L741, C14]: N
      │   │   │       │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L741, C19]: V
      │   │   │       │   │       │     
      │   │   │       │   │       └─ ArchInsnUnaryExprSyntaxNode at [L741, C25]: !Z
      │   │   │       │   │           ├─ Operator: BoolInv
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L741, C26]: Z
      │   │   │       │   │           └─ IsPrefix: True
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L741, C34]: {\n            reg1 = 1;\n            Z = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L742, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L742, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L742, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L742, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L743, C13]: Z = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L743, C13]: Z = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L743, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L743, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L744, C16]: {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L745, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L745, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L745, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L745, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L746, C13]: Z = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L746, C13]: Z = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L746, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L746, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L748, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L748, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L748, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L748, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L748, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L748, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: gr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L751, C5]: instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L751, C22]: {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L751, C23]: 0010 1101
      │   │   │   │   └─ BitsStr: 0010 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L751, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L751, C38]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L751, C51]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L751, C59]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L751, C113]: {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L751, C113]: {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L752, C9]: if (N != V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L752, C12]: (N != V)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L752, C13]: N != V
      │   │   │       │   │       ├─ Operator: NotEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L752, C13]: N
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L752, C18]: V
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L752, C26]: {\n            reg1 = 1;\n            Z = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L753, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L753, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L753, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L753, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L754, C13]: Z = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L754, C13]: Z = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L754, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L754, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L755, C16]: {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L756, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L756, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L756, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L756, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L757, C13]: Z = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L757, C13]: Z = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L757, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L757, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L759, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L759, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L759, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L759, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L759, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L759, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: le
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L762, C5]: instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L762, C24]: {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L762, C25]: 0010 1110
      │   │   │   │   └─ BitsStr: 0010 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L762, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L762, C40]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L762, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L762, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L762, C115]: {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L762, C115]: {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L763, C9]: if (N == V) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L763, C12]: (N == V)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L763, C13]: N == V
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L763, C13]: N
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L763, C18]: V
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L763, C26]: {\n            reg1 = 1;\n            Z = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L764, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L764, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L764, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L764, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L765, C13]: Z = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L765, C13]: Z = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L765, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L765, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L766, C16]: {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L767, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L767, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L767, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L767, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L768, C13]: Z = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L768, C13]: Z = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L768, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L768, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L770, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L770, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L770, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L770, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L770, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L770, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: greq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L773, C5]: instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L773, C24]: {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L773, C25]: 0010 1111
      │   │   │   │   └─ BitsStr: 0010 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L773, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L773, C40]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L773, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L773, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L773, C115]: {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L773, C115]: {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L774, C9]: if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 0;\n        } else {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L774, C12]: ((N != V) || Z)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L774, C13]: (N != V) || Z
      │   │   │       │   │       ├─ Operator: BoolOr
      │   │   │       │   │       ├─ ArchInsnBracesExprSyntaxNode at [L774, C13]: (N != V)
      │   │   │       │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L774, C14]: N != V
      │   │   │       │   │       │       ├─ Operator: NotEqual
      │   │   │       │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L774, C14]: N
      │   │   │       │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L774, C19]: V
      │   │   │       │   │       │     
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L774, C25]: Z
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L774, C33]: {\n            reg1 = 1;\n            Z = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L775, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L775, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L775, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L775, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L776, C13]: Z = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L776, C13]: Z = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L776, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L776, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L777, C16]: {\n            reg1 = 0;\n            Z = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L778, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L778, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L778, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L778, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L779, C13]: Z = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L779, C13]: Z = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L779, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L779, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L781, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L781, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L781, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L781, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L781, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L781, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L784, C5]: instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L784, C32]: {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L784, C33]: 0011 0000
      │   │   │   │   └─ BitsStr: 0011 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L784, C44]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L784, C48]: reg as toPtr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: toPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L784, C62]: reg as fromPtr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: fromPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L784, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L784, C92]: imm32 as size
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: size
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L784, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L784, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L785, C9]: let i = size;
      │   │   │       │   ├─ Name: i
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L785, C17]: size
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L786, C9]: let dest = toPtr;
      │   │   │       │   ├─ Name: dest
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L786, C20]: toPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L787, C9]: let src = fromPtr;
      │   │   │       │   ├─ Name: src
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L787, C19]: fromPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnWhileLoopStmtSyntaxNode at [L789, C9]: while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L789, C24]: {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L790, C13]: dataM:8[dest] = constantsM:8[src];
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L790, C13]: dataM:8[dest] = constantsM:8[src]
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnIndexerExprSyntaxNode at [L790, C13]: dataM:8[dest]
      │   │   │       │   │   │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L790, C13]: dataM:8
      │   │   │       │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L790, C21]: dest
      │   │   │       │   │   │       │ 
      │   │   │       │   │   │       └─ ArchInsnIndexerExprSyntaxNode at [L790, C29]: constantsM:8[src]
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L790, C29]: constantsM:8
      │   │   │       │   │   │           └─ ArchInsnPlaceExprSyntaxNode at [L790, C42]: src
      │   │   │       │   │   │         
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L791, C13]: dest = dest + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L791, C13]: dest = dest + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L791, C13]: dest
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L791, C20]: dest + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L791, C20]: dest
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L791, C27]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L792, C13]: src = src + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L792, C13]: src = src + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L792, C13]: src
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L792, C19]: src + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L792, C19]: src
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L792, C25]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L793, C13]: i = i - 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L793, C13]: i = i - 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L793, C13]: i
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L793, C17]: i - 1
      │   │   │       │   │               ├─ Operator: Sub
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L793, C17]: i
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L793, C21]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L789, C15]: i > 0
      │   │   │       │       ├─ Operator: Greater
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L789, C15]: i
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L789, C19]: 0
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 0
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L796, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L796, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L796, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L796, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L796, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L796, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: memcpy-const
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L798, C5]: instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L798, C30]: {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L798, C31]: 0011 0001
      │   │   │   │   └─ BitsStr: 0011 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L798, C42]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L798, C57]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L798, C68]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L798, C80]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L798, C94]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L798, C116]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L798, C116]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L799, C9]: let addr = 0;
      │   │   │       │   ├─ Name: addr
      │   │   │       │   └─ ArchInsnLiteralExprSyntaxNode at [L799, C20]: 0
      │   │   │       │       ├─ Kind: Dec
      │   │   │       │       └─ ValueString: 0
      │   │   │       │     
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L800, C9]: if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │   ├─ ArchInsnBinaryExprSyntaxNode at [L800, C12]: (offsetValue >> 31) & 1 == 1
      │   │   │       │   │   ├─ Operator: Equal
      │   │   │       │   │   ├─ ArchInsnBinaryExprSyntaxNode at [L800, C12]: (offsetValue >> 31) & 1
      │   │   │       │   │   │   ├─ Operator: BitsAnd
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L800, C12]: (offsetValue >> 31)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L800, C13]: offsetValue >> 31
      │   │   │       │   │   │   │       ├─ Operator: BitsShRight
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L800, C13]: offsetValue
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L800, C28]: 31
      │   │   │       │   │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │   │           └─ ValueString: 31
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L800, C34]: 1
      │   │   │       │   │   │       ├─ Kind: Dec
      │   │   │       │   │   │       └─ ValueString: 1
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnLiteralExprSyntaxNode at [L800, C39]: 1
      │   │   │       │   │       ├─ Kind: Dec
      │   │   │       │   │       └─ ValueString: 1
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L800, C46]: { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L801, C13]: let temp = offsetValue;
      │   │   │       │   │   │   ├─ Name: temp
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L801, C24]: offsetValue
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L802, C13]: addr = ptr + temp;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L802, C13]: addr = ptr + temp
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L802, C13]: addr
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L802, C20]: ptr + temp
      │   │   │       │   │               ├─ Operator: Sum
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L802, C20]: ptr
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L802, C26]: temp
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L803, C16]: { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L804, C13]: addr = ptr + offsetValue;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L804, C13]: addr = ptr + offsetValue
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L804, C13]: addr
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L804, C20]: ptr + offsetValue
      │   │   │       │                   ├─ Operator: Sum
      │   │   │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L804, C20]: ptr
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L804, C26]: offsetValue
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L806, C9]: addr = addr & 0x00000000ffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L806, C9]: addr = addr & 0x00000000ffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L806, C9]: addr
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L806, C16]: addr & 0x00000000ffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L806, C16]: addr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L806, C23]: 0x00000000ffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │             
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L807, C9]: when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L807, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L807, C23]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L808, C13]: let res = dataM:8[addr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L808, C23]: dataM:8[addr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L808, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L808, C31]: addr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L809, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L809, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L809, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L809, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L809, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L809, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L810, C16]: when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L810, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L810, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L811, C13]: let res = dataM:8[addr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L811, C23]: dataM:8[addr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L811, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L811, C31]: addr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L812, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L812, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L812, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L812, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L812, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L812, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L813, C16]: when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L813, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L813, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L814, C13]: let res = dataM:8[addr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L814, C23]: dataM:8[addr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L814, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L814, C31]: addr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L815, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L815, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L815, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L815, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L815, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L815, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L816, C16]: when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L816, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L816, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L817, C13]: let res = dataM:8[addr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L817, C23]: dataM:8[addr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L817, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L817, C31]: addr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L818, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L818, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L818, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L818, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L818, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L818, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L820, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L820, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L820, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L820, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L820, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L820, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-c-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L823, C5]: instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L823, C23]: {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L823, C24]: 0011 0010
      │   │   │   │   └─ BitsStr: 0011 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L823, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L823, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L823, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L823, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L823, C130]: {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L823, C130]: {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L824, C9]: let result = reg1 - reg2;
      │   │   │       │   ├─ Name: result
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L824, C22]: reg1 - reg2
      │   │   │       │       ├─ Operator: Sub
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L824, C22]: reg1
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L824, C29]: reg2
      │   │   │       │     
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L826, C9]: when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L826, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L826, C23]: {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L827, C13]: Z = (result == 0);
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L827, C13]: Z = (result == 0)
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L827, C13]: Z
      │   │   │       │   │   │       └─ ArchInsnBracesExprSyntaxNode at [L827, C17]: (result == 0)
      │   │   │       │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L827, C18]: result == 0
      │   │   │       │   │   │               ├─ Operator: Equal
      │   │   │       │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L827, C18]: result
      │   │   │       │   │   │               └─ ArchInsnLiteralExprSyntaxNode at [L827, C28]: 0
      │   │   │       │   │   │                   ├─ Kind: Dec
      │   │   │       │   │   │                   └─ ValueString: 0
      │   │   │       │   │   │                 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L828, C13]: N = (result & (1 << 7)) != 0;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L828, C13]: N = (result & (1 << 7)) != 0
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L828, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L828, C17]: (result & (1 << 7)) != 0
      │   │   │       │   │   │           ├─ Operator: NotEqual
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L828, C17]: (result & (1 << 7))
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L828, C18]: result & (1 << 7)
      │   │   │       │   │   │           │       ├─ Operator: BitsAnd
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L828, C18]: result
      │   │   │       │   │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L828, C27]: (1 << 7)
      │   │   │       │   │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L828, C28]: 1 << 7
      │   │   │       │   │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │   │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L828, C28]: 1
      │   │   │       │   │   │           │               │   ├─ Kind: Dec
      │   │   │       │   │   │           │               │   └─ ValueString: 1
      │   │   │       │   │   │           │               │ 
      │   │   │       │   │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L828, C33]: 7
      │   │   │       │   │   │           │                   ├─ Kind: Dec
      │   │   │       │   │   │           │                   └─ ValueString: 7
      │   │   │       │   │   │           │                 
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L828, C40]: 0
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 0
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L829, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L829, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L829, C13]: V
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L829, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L829, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L829, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L829, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │   │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L829, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │   │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │   │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L829, C19]: (reg1 ^ reg2)
      │   │   │       │   │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L829, C20]: reg1 ^ reg2
      │   │   │       │   │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L829, C20]: reg1
      │   │   │       │   │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L829, C27]: reg2
      │   │   │       │   │   │           │       │       │     
      │   │   │       │   │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L829, C35]: (reg1 ^ result)
      │   │   │       │   │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L829, C36]: reg1 ^ result
      │   │   │       │   │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │   │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L829, C36]: reg1
      │   │   │       │   │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L829, C43]: result
      │   │   │       │   │   │           │       │             
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L829, C55]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L829, C60]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L830, C13]: C = (reg1 < reg2);
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L830, C13]: C = (reg1 < reg2)
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L830, C13]: C
      │   │   │       │   │           └─ ArchInsnBracesExprSyntaxNode at [L830, C17]: (reg1 < reg2)
      │   │   │       │   │               └─ ArchInsnBinaryExprSyntaxNode at [L830, C18]: reg1 < reg2
      │   │   │       │   │                   ├─ Operator: Less
      │   │   │       │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L830, C18]: reg1
      │   │   │       │   │                   └─ ArchInsnPlaceExprSyntaxNode at [L830, C25]: reg2
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L831, C16]: when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L831, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L831, C31]: {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L832, C13]: Z = (result == 0);
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L832, C13]: Z = (result == 0)
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L832, C13]: Z
      │   │   │       │       │   │       └─ ArchInsnBracesExprSyntaxNode at [L832, C17]: (result == 0)
      │   │   │       │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L832, C18]: result == 0
      │   │   │       │       │   │               ├─ Operator: Equal
      │   │   │       │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L832, C18]: result
      │   │   │       │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L832, C28]: 0
      │   │   │       │       │   │                   ├─ Kind: Dec
      │   │   │       │       │   │                   └─ ValueString: 0
      │   │   │       │       │   │                 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L833, C13]: N = (result & (1 << 15)) != 0;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L833, C13]: N = (result & (1 << 15)) != 0
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L833, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L833, C17]: (result & (1 << 15)) != 0
      │   │   │       │       │   │           ├─ Operator: NotEqual
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L833, C17]: (result & (1 << 15))
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L833, C18]: result & (1 << 15)
      │   │   │       │       │   │           │       ├─ Operator: BitsAnd
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L833, C18]: result
      │   │   │       │       │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L833, C27]: (1 << 15)
      │   │   │       │       │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L833, C28]: 1 << 15
      │   │   │       │       │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │       │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L833, C28]: 1
      │   │   │       │       │   │           │               │   ├─ Kind: Dec
      │   │   │       │       │   │           │               │   └─ ValueString: 1
      │   │   │       │       │   │           │               │ 
      │   │   │       │       │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L833, C33]: 15
      │   │   │       │       │   │           │                   ├─ Kind: Dec
      │   │   │       │       │   │           │                   └─ ValueString: 15
      │   │   │       │       │   │           │                 
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L833, C41]: 0
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 0
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L834, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L834, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L834, C13]: V
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L834, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L834, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L834, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L834, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │       │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L834, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │       │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │       │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L834, C19]: (reg1 ^ reg2)
      │   │   │       │       │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L834, C20]: reg1 ^ reg2
      │   │   │       │       │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L834, C20]: reg1
      │   │   │       │       │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L834, C27]: reg2
      │   │   │       │       │   │           │       │       │     
      │   │   │       │       │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L834, C35]: (reg1 ^ result)
      │   │   │       │       │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L834, C36]: reg1 ^ result
      │   │   │       │       │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │       │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L834, C36]: reg1
      │   │   │       │       │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L834, C43]: result
      │   │   │       │       │   │           │       │             
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L834, C55]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L834, C61]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L835, C13]: C = (reg1 < reg2);
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L835, C13]: C = (reg1 < reg2)
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L835, C13]: C
      │   │   │       │       │           └─ ArchInsnBracesExprSyntaxNode at [L835, C17]: (reg1 < reg2)
      │   │   │       │       │               └─ ArchInsnBinaryExprSyntaxNode at [L835, C18]: reg1 < reg2
      │   │   │       │       │                   ├─ Operator: Less
      │   │   │       │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L835, C18]: reg1
      │   │   │       │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L835, C25]: reg2
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L836, C16]: when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L836, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L836, C31]: {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L837, C13]: Z = (result == 0);
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L837, C13]: Z = (result == 0)
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L837, C13]: Z
      │   │   │       │           │   │       └─ ArchInsnBracesExprSyntaxNode at [L837, C17]: (result == 0)
      │   │   │       │           │   │           └─ ArchInsnBinaryExprSyntaxNode at [L837, C18]: result == 0
      │   │   │       │           │   │               ├─ Operator: Equal
      │   │   │       │           │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L837, C18]: result
      │   │   │       │           │   │               └─ ArchInsnLiteralExprSyntaxNode at [L837, C28]: 0
      │   │   │       │           │   │                   ├─ Kind: Dec
      │   │   │       │           │   │                   └─ ValueString: 0
      │   │   │       │           │   │                 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L838, C13]: N = (result & (1 << 31)) != 0;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L838, C13]: N = (result & (1 << 31)) != 0
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L838, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L838, C17]: (result & (1 << 31)) != 0
      │   │   │       │           │   │           ├─ Operator: NotEqual
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L838, C17]: (result & (1 << 31))
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L838, C18]: result & (1 << 31)
      │   │   │       │           │   │           │       ├─ Operator: BitsAnd
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L838, C18]: result
      │   │   │       │           │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L838, C27]: (1 << 31)
      │   │   │       │           │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L838, C28]: 1 << 31
      │   │   │       │           │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │           │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L838, C28]: 1
      │   │   │       │           │   │           │               │   ├─ Kind: Dec
      │   │   │       │           │   │           │               │   └─ ValueString: 1
      │   │   │       │           │   │           │               │ 
      │   │   │       │           │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L838, C33]: 31
      │   │   │       │           │   │           │                   ├─ Kind: Dec
      │   │   │       │           │   │           │                   └─ ValueString: 31
      │   │   │       │           │   │           │                 
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L838, C41]: 0
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 0
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L839, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L839, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L839, C13]: V
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L839, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L839, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L839, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L839, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │           │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L839, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │           │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │           │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L839, C19]: (reg1 ^ reg2)
      │   │   │       │           │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L839, C20]: reg1 ^ reg2
      │   │   │       │           │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L839, C20]: reg1
      │   │   │       │           │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L839, C27]: reg2
      │   │   │       │           │   │           │       │       │     
      │   │   │       │           │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L839, C35]: (reg1 ^ result)
      │   │   │       │           │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L839, C36]: reg1 ^ result
      │   │   │       │           │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │           │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L839, C36]: reg1
      │   │   │       │           │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L839, C43]: result
      │   │   │       │           │   │           │       │             
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L839, C55]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L839, C61]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L840, C13]: C = (reg1 < reg2);
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L840, C13]: C = (reg1 < reg2)
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L840, C13]: C
      │   │   │       │           │           └─ ArchInsnBracesExprSyntaxNode at [L840, C17]: (reg1 < reg2)
      │   │   │       │           │               └─ ArchInsnBinaryExprSyntaxNode at [L840, C18]: reg1 < reg2
      │   │   │       │           │                   ├─ Operator: Less
      │   │   │       │           │                   ├─ ArchInsnPlaceExprSyntaxNode at [L840, C18]: reg1
      │   │   │       │           │                   └─ ArchInsnPlaceExprSyntaxNode at [L840, C25]: reg2
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L841, C16]: when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L841, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L841, C31]: {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L842, C13]: Z = (result == 0);
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L842, C13]: Z = (result == 0)
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L842, C13]: Z
      │   │   │       │               │   │       └─ ArchInsnBracesExprSyntaxNode at [L842, C17]: (result == 0)
      │   │   │       │               │   │           └─ ArchInsnBinaryExprSyntaxNode at [L842, C18]: result == 0
      │   │   │       │               │   │               ├─ Operator: Equal
      │   │   │       │               │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L842, C18]: result
      │   │   │       │               │   │               └─ ArchInsnLiteralExprSyntaxNode at [L842, C28]: 0
      │   │   │       │               │   │                   ├─ Kind: Dec
      │   │   │       │               │   │                   └─ ValueString: 0
      │   │   │       │               │   │                 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L843, C13]: N = (result & (1 << 63)) != 0;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L843, C13]: N = (result & (1 << 63)) != 0
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L843, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L843, C17]: (result & (1 << 63)) != 0
      │   │   │       │               │   │           ├─ Operator: NotEqual
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L843, C17]: (result & (1 << 63))
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L843, C18]: result & (1 << 63)
      │   │   │       │               │   │           │       ├─ Operator: BitsAnd
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L843, C18]: result
      │   │   │       │               │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L843, C27]: (1 << 63)
      │   │   │       │               │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L843, C28]: 1 << 63
      │   │   │       │               │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │               │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L843, C28]: 1
      │   │   │       │               │   │           │               │   ├─ Kind: Dec
      │   │   │       │               │   │           │               │   └─ ValueString: 1
      │   │   │       │               │   │           │               │ 
      │   │   │       │               │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L843, C33]: 63
      │   │   │       │               │   │           │                   ├─ Kind: Dec
      │   │   │       │               │   │           │                   └─ ValueString: 63
      │   │   │       │               │   │           │                 
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L843, C41]: 0
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 0
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L844, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L844, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L844, C13]: V
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L844, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L844, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L844, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L844, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │               │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L844, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │               │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │               │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L844, C19]: (reg1 ^ reg2)
      │   │   │       │               │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L844, C20]: reg1 ^ reg2
      │   │   │       │               │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L844, C20]: reg1
      │   │   │       │               │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L844, C27]: reg2
      │   │   │       │               │   │           │       │       │     
      │   │   │       │               │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L844, C35]: (reg1 ^ result)
      │   │   │       │               │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L844, C36]: reg1 ^ result
      │   │   │       │               │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │               │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L844, C36]: reg1
      │   │   │       │               │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L844, C43]: result
      │   │   │       │               │   │           │       │             
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L844, C55]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L844, C61]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L845, C13]: C = (reg1 < reg2);
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L845, C13]: C = (reg1 < reg2)
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L845, C13]: C
      │   │   │       │               │           └─ ArchInsnBracesExprSyntaxNode at [L845, C17]: (reg1 < reg2)
      │   │   │       │               │               └─ ArchInsnBinaryExprSyntaxNode at [L845, C18]: reg1 < reg2
      │   │   │       │               │                   ├─ Operator: Less
      │   │   │       │               │                   ├─ ArchInsnPlaceExprSyntaxNode at [L845, C18]: reg1
      │   │   │       │               │                   └─ ArchInsnPlaceExprSyntaxNode at [L845, C25]: reg2
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L848, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L848, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L848, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L848, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L848, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L848, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: cmp
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L851, C5]: instruction m_call = {0011 0011, 11, reg as objectPtr, 000000, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let vtablePtr = constantsM:8[classInfoPtr + 16];\n        let mAddr = constantsM:8[vtablePtr + offsetValue];\n\n        IP = mAddr;        \n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L851, C26]: {0011 0011, 11, reg as objectPtr, 000000, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L851, C27]: 0011 0011
      │   │   │   │   └─ BitsStr: 0011 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L851, C38]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L851, C42]: reg as objectPtr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: objectPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L851, C60]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L851, C68]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L851, C82]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L851, C104]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let vtablePtr = constantsM:8[classInfoPtr + 16];\n        let mAddr = constantsM:8[vtablePtr + offsetValue];\n\n        IP = mAddr;        \n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L851, C104]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let vtablePtr = constantsM:8[classInfoPtr + 16];\n        let mAddr = constantsM:8[vtablePtr + offsetValue];\n\n        IP = mAddr;        \n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L852, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L852, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L852, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L852, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L852, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L852, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L853, C9]: dataM:8[SP] = IP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L853, C9]: dataM:8[SP] = IP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L853, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L853, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L853, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L853, C23]: IP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L853, C23]: IP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L853, C28]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L855, C9]: let classInfoPtr = dataM:8[objectPtr + 0];
      │   │   │       │   ├─ Name: classInfoPtr
      │   │   │       │   └─ ArchInsnIndexerExprSyntaxNode at [L855, C28]: dataM:8[objectPtr + 0]
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L855, C28]: dataM:8
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L855, C36]: objectPtr + 0
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L855, C36]: objectPtr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L855, C48]: 0
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 0
      │   │   │       │             
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L856, C9]: let vtablePtr = constantsM:8[classInfoPtr + 16];
      │   │   │       │   ├─ Name: vtablePtr
      │   │   │       │   └─ ArchInsnIndexerExprSyntaxNode at [L856, C25]: constantsM:8[classInfoPtr + 16]
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L856, C25]: constantsM:8
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L856, C38]: classInfoPtr + 16
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L856, C38]: classInfoPtr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L856, C53]: 16
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 16
      │   │   │       │             
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L857, C9]: let mAddr = constantsM:8[vtablePtr + offsetValue];
      │   │   │       │   ├─ Name: mAddr
      │   │   │       │   └─ ArchInsnIndexerExprSyntaxNode at [L857, C21]: constantsM:8[vtablePtr + offsetValue]
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L857, C21]: constantsM:8
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L857, C34]: vtablePtr + offsetValue
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L857, C34]: vtablePtr
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L857, C46]: offsetValue
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L859, C9]: IP = mAddr;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L859, C9]: IP = mAddr
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L859, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L859, C14]: mAddr
      │   │   │             
      │   │   └─ Name: m_call
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L862, C5]: instruction f_load = {0011 0100, sequence size, reg as to, reg as objectPtr, 00 0000 0000, off32 as offsetValue} {\n        let addr = objectPtr + offsetValue;\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L862, C26]: {0011 0100, sequence size, reg as to, reg as objectPtr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L862, C27]: 0011 0100
      │   │   │   │   └─ BitsStr: 0011 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L862, C38]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L862, C53]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L862, C64]: reg as objectPtr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: objectPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L862, C82]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L862, C96]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L862, C118]: {\n        let addr = objectPtr + offsetValue;\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L862, C118]: {\n        let addr = objectPtr + offsetValue;\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L863, C9]: let addr = objectPtr + offsetValue;
      │   │   │       │   ├─ Name: addr
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L863, C20]: objectPtr + offsetValue
      │   │   │       │       ├─ Operator: Sum
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L863, C20]: objectPtr
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L863, C32]: offsetValue
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L864, C9]: addr = addr & 0x00000000ffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L864, C9]: addr = addr & 0x00000000ffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L864, C9]: addr
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L864, C16]: addr & 0x00000000ffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L864, C16]: addr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L864, C23]: 0x00000000ffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │             
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L865, C9]: when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L865, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L865, C23]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L866, C13]: let res = dataM:8[addr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L866, C23]: dataM:8[addr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L866, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L866, C31]: addr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L867, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L867, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L867, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L867, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L867, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L867, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L868, C16]: when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L868, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L868, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L869, C13]: let res = dataM:8[addr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L869, C23]: dataM:8[addr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L869, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L869, C31]: addr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L870, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L870, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L870, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L870, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L870, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L870, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L871, C16]: when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L871, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L871, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L872, C13]: let res = dataM:8[addr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L872, C23]: dataM:8[addr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L872, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L872, C31]: addr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L873, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L873, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L873, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L873, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L873, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L873, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L874, C16]: when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L874, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L874, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L875, C13]: let res = dataM:8[addr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L875, C23]: dataM:8[addr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L875, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L875, C31]: addr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L876, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L876, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L876, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L876, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L876, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L876, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L878, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L878, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L878, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L878, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L878, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L878, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: f_load
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L881, C5]: instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L881, C23]: {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L881, C24]: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L881, C105]: {\n	}
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L881, C105]: {\n	}
      │   │   │ 
      │   │   └─ Name: hlt
      │   │ 
      │   └─ ArchInstructionEncodingSyntaxNode at [L884, C5]: instruction i_call = {0011 0011, 11, reg as objectPtr, reg as iid, 00 0000 0000, off32 as offsetValue} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let interfaceCount = constantsM:8[classInfoPtr + 24];\n        \n        let i = 0; \n        let tmp = 0;\n        while i != interfaceCount do {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }\n\n        let interfaceImpl = constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i];\n\n        let mAddr = constantsM:8[interfaceImpl + offsetValue];\n\n        IP = mAddr;        \n    }
      │       ├─ ArchIstructionFieldsSequenceSyntaxNode at [L884, C26]: {0011 0011, 11, reg as objectPtr, reg as iid, 00 0000 0000, off32 as offsetValue}
      │       │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L884, C27]: 0011 0011
      │       │   │   └─ BitsStr: 0011 0011
      │       │   │ 
      │       │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L884, C38]: 11
      │       │   │   └─ BitsStr: 11
      │       │   │ 
      │       │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L884, C42]: reg as objectPtr
      │       │   │   ├─ ModifierKind: None
      │       │   │   ├─ FieldEncName: reg
      │       │   │   └─ FieldName: objectPtr
      │       │   │ 
      │       │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L884, C60]: reg as iid
      │       │   │   ├─ ModifierKind: None
      │       │   │   ├─ FieldEncName: reg
      │       │   │   └─ FieldName: iid
      │       │   │ 
      │       │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L884, C72]: 00 0000 0000
      │       │   │   └─ BitsStr: 00 0000 0000
      │       │   │ 
      │       │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L884, C86]: off32 as offsetValue
      │       │       ├─ ModifierKind: None
      │       │       ├─ FieldEncName: off32
      │       │       └─ FieldName: offsetValue
      │       │     
      │       ├─ ArchInstructionFunctionSyntaxNode at [L884, C108]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let interfaceCount = constantsM:8[classInfoPtr + 24];\n        \n        let i = 0; \n        let tmp = 0;\n        while i != interfaceCount do {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }\n\n        let interfaceImpl = constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i];\n\n        let mAddr = constantsM:8[interfaceImpl + offsetValue];\n\n        IP = mAddr;        \n    }
      │       │   └─ ArchInsnBlockStmtSyntaxNode at [L884, C108]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n\n        let classInfoPtr = dataM:8[objectPtr + 0];\n        let interfaceCount = constantsM:8[classInfoPtr + 24];\n        \n        let i = 0; \n        let tmp = 0;\n        while i != interfaceCount do {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }\n\n        let interfaceImpl = constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i];\n\n        let mAddr = constantsM:8[interfaceImpl + offsetValue];\n\n        IP = mAddr;        \n    }
      │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L885, C9]: SP = SP - 8;
      │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L885, C9]: SP = SP - 8
      │       │       │       ├─ Operator: Assign
      │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L885, C9]: SP
      │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L885, C14]: SP - 8
      │       │       │           ├─ Operator: Sub
      │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L885, C14]: SP
      │       │       │           └─ ArchInsnLiteralExprSyntaxNode at [L885, C19]: 8
      │       │       │               ├─ Kind: Dec
      │       │       │               └─ ValueString: 8
      │       │       │             
      │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L886, C9]: dataM:8[SP] = IP + 8;
      │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L886, C9]: dataM:8[SP] = IP + 8
      │       │       │       ├─ Operator: Assign
      │       │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L886, C9]: dataM:8[SP]
      │       │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L886, C9]: dataM:8
      │       │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L886, C17]: SP
      │       │       │       │ 
      │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L886, C23]: IP + 8
      │       │       │           ├─ Operator: Sum
      │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L886, C23]: IP
      │       │       │           └─ ArchInsnLiteralExprSyntaxNode at [L886, C28]: 8
      │       │       │               ├─ Kind: Dec
      │       │       │               └─ ValueString: 8
      │       │       │             
      │       │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L888, C9]: let classInfoPtr = dataM:8[objectPtr + 0];
      │       │       │   ├─ Name: classInfoPtr
      │       │       │   └─ ArchInsnIndexerExprSyntaxNode at [L888, C28]: dataM:8[objectPtr + 0]
      │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L888, C28]: dataM:8
      │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L888, C36]: objectPtr + 0
      │       │       │           ├─ Operator: Sum
      │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L888, C36]: objectPtr
      │       │       │           └─ ArchInsnLiteralExprSyntaxNode at [L888, C48]: 0
      │       │       │               ├─ Kind: Dec
      │       │       │               └─ ValueString: 0
      │       │       │             
      │       │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L889, C9]: let interfaceCount = constantsM:8[classInfoPtr + 24];
      │       │       │   ├─ Name: interfaceCount
      │       │       │   └─ ArchInsnIndexerExprSyntaxNode at [L889, C30]: constantsM:8[classInfoPtr + 24]
      │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L889, C30]: constantsM:8
      │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L889, C43]: classInfoPtr + 24
      │       │       │           ├─ Operator: Sum
      │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L889, C43]: classInfoPtr
      │       │       │           └─ ArchInsnLiteralExprSyntaxNode at [L889, C58]: 24
      │       │       │               ├─ Kind: Dec
      │       │       │               └─ ValueString: 24
      │       │       │             
      │       │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L891, C9]: let i = 0;
      │       │       │   ├─ Name: i
      │       │       │   └─ ArchInsnLiteralExprSyntaxNode at [L891, C17]: 0
      │       │       │       ├─ Kind: Dec
      │       │       │       └─ ValueString: 0
      │       │       │     
      │       │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L892, C9]: let tmp = 0;
      │       │       │   ├─ Name: tmp
      │       │       │   └─ ArchInsnLiteralExprSyntaxNode at [L892, C19]: 0
      │       │       │       ├─ Kind: Dec
      │       │       │       └─ ValueString: 0
      │       │       │     
      │       │       ├─ ArchInsnWhileLoopStmtSyntaxNode at [L893, C9]: while i != interfaceCount do {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }
      │       │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L893, C38]: {\n            tmp = constantsM:8[classInfoPtr + 32 + (8*i)];\n\n            if (tmp == iid) then {\n                break;\n            }\n\n            i = i + 1;\n        }
      │       │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L894, C13]: tmp = constantsM:8[classInfoPtr + 32 + (8*i)];
      │       │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L894, C13]: tmp = constantsM:8[classInfoPtr + 32 + (8*i)]
      │       │       │   │   │       ├─ Operator: Assign
      │       │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L894, C13]: tmp
      │       │       │   │   │       └─ ArchInsnIndexerExprSyntaxNode at [L894, C19]: constantsM:8[classInfoPtr + 32 + (8*i)]
      │       │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L894, C19]: constantsM:8
      │       │       │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L894, C32]: classInfoPtr + 32 + (8*i)
      │       │       │   │   │               ├─ Operator: Sum
      │       │       │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L894, C32]: classInfoPtr
      │       │       │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L894, C47]: 32 + (8*i)
      │       │       │   │   │                   ├─ Operator: Sum
      │       │       │   │   │                   ├─ ArchInsnLiteralExprSyntaxNode at [L894, C47]: 32
      │       │       │   │   │                   │   ├─ Kind: Dec
      │       │       │   │   │                   │   └─ ValueString: 32
      │       │       │   │   │                   │ 
      │       │       │   │   │                   └─ ArchInsnBracesExprSyntaxNode at [L894, C52]: (8*i)
      │       │       │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L894, C53]: 8*i
      │       │       │   │   │                           ├─ Operator: Mul
      │       │       │   │   │                           ├─ ArchInsnLiteralExprSyntaxNode at [L894, C53]: 8
      │       │       │   │   │                           │   ├─ Kind: Dec
      │       │       │   │   │                           │   └─ ValueString: 8
      │       │       │   │   │                           │ 
      │       │       │   │   │                           └─ ArchInsnPlaceExprSyntaxNode at [L894, C55]: i
      │       │       │   │   │                         
      │       │       │   │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L896, C13]: if (tmp == iid) then {\n                break;\n            }
      │       │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L896, C16]: (tmp == iid)
      │       │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L896, C17]: tmp == iid
      │       │       │   │   │   │       ├─ Operator: Equal
      │       │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L896, C17]: tmp
      │       │       │   │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L896, C24]: iid
      │       │       │   │   │   │     
      │       │       │   │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L896, C34]: {\n                break;\n            }
      │       │       │   │   │   │   └─ ArchInsnBreakStmtSyntaxNode at [L897, C17]: break;
      │       │       │   │   │   │ 
      │       │       │   │   │   └─ ElseBranchOrNull: <NULL>
      │       │       │   │   │ 
      │       │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L900, C13]: i = i + 1;
      │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L900, C13]: i = i + 1
      │       │       │   │           ├─ Operator: Assign
      │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L900, C13]: i
      │       │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L900, C17]: i + 1
      │       │       │   │               ├─ Operator: Sum
      │       │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L900, C17]: i
      │       │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L900, C21]: 1
      │       │       │   │                   ├─ Kind: Dec
      │       │       │   │                   └─ ValueString: 1
      │       │       │   │                 
      │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L893, C15]: i != interfaceCount
      │       │       │       ├─ Operator: NotEqual
      │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L893, C15]: i
      │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L893, C20]: interfaceCount
      │       │       │     
      │       │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L903, C9]: let interfaceImpl = constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i];
      │       │       │   ├─ Name: interfaceImpl
      │       │       │   └─ ArchInsnIndexerExprSyntaxNode at [L903, C29]: constantsM:8[classInfoPtr + 24 + (interfaceCount * 8) + i]
      │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L903, C29]: constantsM:8
      │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L903, C42]: classInfoPtr + 24 + (interfaceCount * 8) + i
      │       │       │           ├─ Operator: Sum
      │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L903, C42]: classInfoPtr
      │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L903, C57]: 24 + (interfaceCount * 8) + i
      │       │       │               ├─ Operator: Sum
      │       │       │               ├─ ArchInsnLiteralExprSyntaxNode at [L903, C57]: 24
      │       │       │               │   ├─ Kind: Dec
      │       │       │               │   └─ ValueString: 24
      │       │       │               │ 
      │       │       │               └─ ArchInsnBinaryExprSyntaxNode at [L903, C62]: (interfaceCount * 8) + i
      │       │       │                   ├─ Operator: Sum
      │       │       │                   ├─ ArchInsnBracesExprSyntaxNode at [L903, C62]: (interfaceCount * 8)
      │       │       │                   │   └─ ArchInsnBinaryExprSyntaxNode at [L903, C63]: interfaceCount * 8
      │       │       │                   │       ├─ Operator: Mul
      │       │       │                   │       ├─ ArchInsnPlaceExprSyntaxNode at [L903, C63]: interfaceCount
      │       │       │                   │       └─ ArchInsnLiteralExprSyntaxNode at [L903, C80]: 8
      │       │       │                   │           ├─ Kind: Dec
      │       │       │                   │           └─ ValueString: 8
      │       │       │                   │         
      │       │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L903, C85]: i
      │       │       │                 
      │       │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L905, C9]: let mAddr = constantsM:8[interfaceImpl + offsetValue];
      │       │       │   ├─ Name: mAddr
      │       │       │   └─ ArchInsnIndexerExprSyntaxNode at [L905, C21]: constantsM:8[interfaceImpl + offsetValue]
      │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L905, C21]: constantsM:8
      │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L905, C34]: interfaceImpl + offsetValue
      │       │       │           ├─ Operator: Sum
      │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L905, C34]: interfaceImpl
      │       │       │           └─ ArchInsnPlaceExprSyntaxNode at [L905, C50]: offsetValue
      │       │       │         
      │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L907, C9]: IP = mAddr;
      │       │           └─ ArchInsnBinaryExprSyntaxNode at [L907, C9]: IP = mAddr
      │       │               ├─ Operator: Assign
      │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L907, C9]: IP
      │       │               └─ ArchInsnPlaceExprSyntaxNode at [L907, C14]: mAddr
      │       │             
      │       └─ Name: i_call
      │     
      ├─ ArchMnemonicsSyntaxNode at [L910, C5]: mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;\n        mnemonic LDF for f_load(to, objectPtr, offsetValue) "b {1}, {2}, {3}" when sz8,\n                     for f_load(to, objectPtr, offsetValue) "w {1}, {2}, {3}" when sz16,\n                     for f_load(to, objectPtr, offsetValue) "d {1}, {2}, {3}" when sz32,\n                     for f_load(to, objectPtr, offsetValue) "q {1}, {2}, {3}" when sz64;\n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1) plain1;\n        mnemonic NEQ for neq(reg1) plain1;\n        mnemonic GR for gr(reg1) plain1;\n        mnemonic LE for le(reg1) plain1;\n        mnemonic GREQ for greq(reg1) plain1;\n        mnemonic LEEQ for leeq(reg1) plain1;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(value) plain1;\n        mnemonic JNEQ for jneq(value) plain1;\n        mnemonic JGR for jgr(value) plain1;\n        mnemonic JLE for jle(value) plain1;\n        mnemonic JGREQ for jgreq(value) plain1;\n        mnemonic JLEEQ for jleeq(value) plain1;\n\n        mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n        mnemonic MCALL for m_call(objectPtr, offsetValue) plain2;\n        mnemonic ICALL for i_call(objectPtr, iid, offsetValue) plain3;
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L911, C9]: format plain1 is "{1}"
      │   │   ├─ SingleFormatString: "{1}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain1
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L912, C9]: format plain2 is "{1}, {2}"
      │   │   ├─ SingleFormatString: "{1}, {2}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain2
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L913, C9]: format plain3 is "{1}, {2}, {3}"
      │   │   ├─ SingleFormatString: "{1}, {2}, {3}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain3
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L915, C9]: mnemonic HLT for hlt()
      │   │   └─ Name: HLT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L916, C9]: mnemonic NOP for nop()
      │   │   └─ Name: NOP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L917, C9]: mnemonic RET for ret()
      │   │   └─ Name: RET
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L919, C9]: mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: ADD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L923, C9]: mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: SUB
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L927, C9]: mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MUL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L931, C9]: mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: DIV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L935, C9]: mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MOD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L940, C9]: mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: ST
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L948, C9]: mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: LD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L956, C9]: mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: LDC
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L960, C9]: mnemonic LDI32 for load-imm32(to, value) plain2
      │   │   └─ Name: LDI32
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L961, C9]: mnemonic LDC64 for load-const(to, ptr) plain2
      │   │   └─ Name: LDC64
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L962, C9]: mnemonic LDF for f_load(to, objectPtr, offsetValue) "b {1}, {2}, {3}" when sz8,\n                     for f_load(to, objectPtr, offsetValue) "w {1}, {2}, {3}" when sz16,\n                     for f_load(to, objectPtr, offsetValue) "d {1}, {2}, {3}" when sz32,\n                     for f_load(to, objectPtr, offsetValue) "q {1}, {2}, {3}" when sz64
      │   │   └─ Name: LDF
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L967, C9]: mnemonic PUSH for push(from) plain1
      │   │   └─ Name: PUSH
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L968, C9]: mnemonic POP for pop(to) plain1
      │   │   └─ Name: POP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L970, C9]: mnemonic MOV for mov(to, from) plain2
      │   │   └─ Name: MOV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L971, C9]: mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L975, C9]: mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVZX
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L980, C9]: mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3
      │   │   └─ Name: MEMCPYC
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L982, C9]: mnemonic CBW for convert-b-w(to, from) plain2
      │   │   └─ Name: CBW
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L983, C9]: mnemonic CBD for convert-b-d(to, from) plain2
      │   │   └─ Name: CBD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L984, C9]: mnemonic CBQ for convert-b-q(to, from) plain2
      │   │   └─ Name: CBQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L985, C9]: mnemonic CWD for convert-w-d(to, from) plain2
      │   │   └─ Name: CWD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L986, C9]: mnemonic CWQ for convert-w-q(to, from) plain2
      │   │   └─ Name: CWQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L987, C9]: mnemonic CDQ for convert-d-q(to, from) plain2
      │   │   └─ Name: CDQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L989, C9]: mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64
      │   │   └─ Name: NEG
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L993, C9]: mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64
      │   │   └─ Name: NOT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L997, C9]: mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1001, C9]: mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1006, C9]: mnemonic EQ for eq(reg1) plain1
      │   │   └─ Name: EQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1007, C9]: mnemonic NEQ for neq(reg1) plain1
      │   │   └─ Name: NEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1008, C9]: mnemonic GR for gr(reg1) plain1
      │   │   └─ Name: GR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1009, C9]: mnemonic LE for le(reg1) plain1
      │   │   └─ Name: LE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1010, C9]: mnemonic GREQ for greq(reg1) plain1
      │   │   └─ Name: GREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1011, C9]: mnemonic LEEQ for leeq(reg1) plain1
      │   │   └─ Name: LEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1013, C9]: mnemonic JMP for jmp(value) plain1
      │   │   └─ Name: JMP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1014, C9]: mnemonic JZ for jz(value) plain1
      │   │   └─ Name: JZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1015, C9]: mnemonic JNZ for jnz(value) plain1
      │   │   └─ Name: JNZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1016, C9]: mnemonic JEQ for jeq(value) plain1
      │   │   └─ Name: JEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1017, C9]: mnemonic JNEQ for jneq(value) plain1
      │   │   └─ Name: JNEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1018, C9]: mnemonic JGR for jgr(value) plain1
      │   │   └─ Name: JGR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1019, C9]: mnemonic JLE for jle(value) plain1
      │   │   └─ Name: JLE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1020, C9]: mnemonic JGREQ for jgreq(value) plain1
      │   │   └─ Name: JGREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1021, C9]: mnemonic JLEEQ for jleeq(value) plain1
      │   │   └─ Name: JLEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1023, C9]: mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: CMP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1028, C9]: mnemonic CALL for call(value) plain1
      │   │   └─ Name: CALL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1029, C9]: mnemonic ENTER for enter(value) plain1
      │   │   └─ Name: ENTER
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1030, C9]: mnemonic LEAVE for leave(value) plain1
      │   │   └─ Name: LEAVE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1031, C9]: mnemonic MCALL for m_call(objectPtr, offsetValue) plain2
      │   │   └─ Name: MCALL
      │   │ 
      │   └─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L1032, C9]: mnemonic ICALL for i_call(objectPtr, iid, offsetValue) plain3
      │       └─ Name: ICALL
      │     
      ├─ Kind: Default
      └─ Name: myArch
    


