Definition syntax tree at 02.03.2025 21:26:28

Parsing C:\RemoteTasks.Workspace\Sessions\VisualizeArchModel_83e29ab9-a663-44ac-a854-b2f8ff4c6cb3\workdir\In\myArch.target.pdsl

 DefSyntaxTree at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [32];\n        storage AR_S [32];\n        storage ALR_S [32];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [32];\n        storage BP_S [32];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [8];\n        storage OUT_S [8];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n    instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1) plain1;\n        mnemonic NEQ for neq(reg1) plain1;\n        mnemonic GR for gr(reg1) plain1;\n        mnemonic LE for le(reg1) plain1;\n        mnemonic GREQ for greq(reg1) plain1;\n        mnemonic LEEQ for leeq(reg1) plain1;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(value) plain1;\n        mnemonic JNEQ for jneq(value) plain1;\n        mnemonic JGR for jgr(value) plain1;\n        mnemonic JLE for jle(value) plain1;\n        mnemonic JGREQ for jgreq(value) plain1;\n        mnemonic JLEEQ for jleeq(value) plain1;\n\n        mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n}
  └─ ArchitectureAspectSyntaxNode at [L0, C0]: architecture myArch { \n \n    registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [32];\n        storage AR_S [32];\n        storage ALR_S [32];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [32];\n        storage BP_S [32];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [8];\n        storage OUT_S [8];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];\n\n\n    memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n \n    instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n    instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1) plain1;\n        mnemonic NEQ for neq(reg1) plain1;\n        mnemonic GR for gr(reg1) plain1;\n        mnemonic LE for le(reg1) plain1;\n        mnemonic GREQ for greq(reg1) plain1;\n        mnemonic LEEQ for leeq(reg1) plain1;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(value) plain1;\n        mnemonic JNEQ for jneq(value) plain1;\n        mnemonic JGR for jgr(value) plain1;\n        mnemonic JLE for jle(value) plain1;\n        mnemonic JGREQ for jgreq(value) plain1;\n        mnemonic JLEEQ for jleeq(value) plain1;\n\n        mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;\n}
      ├─ ArchRegistersSyntaxNode at [L3, C5]: registers:\n        /*--------------------General-Purpose Registers--------------------*/\n        storage R0_S[64];\n        storage R1_S[64];\n        storage R2_S[64];\n        storage R3_S[64];\n        storage R4_S[64];\n        storage R5_S[64];\n        storage R6_S[64];\n        storage R7_S[64];\n\n        /*-----64 bit-----*/\n        view R0 = R0_S;\n        view R1 = R1_S;\n        view R2 = R2_S;\n        view R3 = R3_S;\n        view R4 = R4_S;\n        view R5 = R5_S;\n        view R6 = R6_S;\n        view R7 = R7_S;        \n\n        /*-----32 bit-----*/\n        view ER0 = R0_S[0..31];\n        view ER1 = R1_S[0..31];\n        view ER2 = R2_S[0..31];\n        view ER3 = R3_S[0..31];\n        view ER4 = R4_S[0..31];\n        view ER5 = R5_S[0..31];\n        view ER6 = R6_S[0..31];\n        view ER7 = R7_S[0..31];  \n\n        /*-----8 bit (H)-----*/\n        view R0H = R0_S[8..15];\n        view R1H = R1_S[8..15];\n        view R2H = R2_S[8..15];\n        view R3H = R3_S[8..15];\n        view R4H = R4_S[8..15];\n        view R5H = R5_S[8..15];\n        view R6H = R6_S[8..15];\n        view R7H = R7_S[8..15];\n\n        /*-----8 bit (L)-----*/\n        view R0L = R0_S[0..7];\n        view R1L = R1_S[0..7];\n        view R2L = R2_S[0..7];\n        view R3L = R3_S[0..7];\n        view R4L = R4_S[0..7];\n        view R5L = R5_S[0..7];\n        view R6L = R6_S[0..7];\n        view R7L = R7_S[0..7];\n\n        /*------------------INSTRUCTION AND ADDRESS POINTERS-------------------------*/\n        storage IP_S [32];\n        storage AR_S [32];\n        storage ALR_S [32];\n        view IP = IP_S;\n        view AR = AR_S;\n        view ALR = ALR_S;\n\n        /*------------------STACK AND BASE POINTERS-------------------------*/\n        storage SP_S [32];\n        storage BP_S [32];\n        storage BR1_S [64];\n        storage BR2_S [64];\n        storage RT_S [64];\n        view SP = SP_S;\n        view BP = BP_S;\n        view BR1 = BR1_S;\n        view BR2 = BR2_S;\n        view RT = RT_S;\n\n        /*------------------IO REGISTERS-------------------------*/\n        storage IN_S [8];\n        storage OUT_S [8];\n        view IN = IN_S;\n        view OUT = OUT_S;        \n\n        /*------------------FLAGS REGISTER-------------------------*/\n        storage FLAGS_S [4];\n        view N = FLAGS_S[0];\n        view Z = FLAGS_S[1];\n        view V = FLAGS_S[2];\n        view C = FLAGS_S[3];
      │   ├─ ArchRegsStorageItemSyntaxNode at [L5, C9]: storage R0_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R0_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L6, C9]: storage R1_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L7, C9]: storage R2_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L8, C9]: storage R3_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R3_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L9, C9]: storage R4_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R4_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L10, C9]: storage R5_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R5_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L11, C9]: storage R6_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R6_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L12, C9]: storage R7_S[64]
      │   │   ├─ Size: 64
      │   │   └─ Name: R7_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L15, C9]: view R0 = R0_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L15, C19]: R0_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L16, C9]: view R1 = R1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L16, C19]: R1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L17, C9]: view R2 = R2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L17, C19]: R2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L18, C9]: view R3 = R3_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L18, C19]: R3_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L19, C9]: view R4 = R4_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L19, C19]: R4_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L20, C9]: view R5 = R5_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L20, C19]: R5_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L21, C9]: view R6 = R6_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L21, C19]: R6_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L22, C9]: view R7 = R7_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L22, C19]: R7_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L25, C9]: view ER0 = R0_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L25, C20]: R0_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: ER0
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L26, C9]: view ER1 = R1_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L26, C20]: R1_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: ER1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L27, C9]: view ER2 = R2_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L27, C20]: R2_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: ER2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L28, C9]: view ER3 = R3_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L28, C20]: R3_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: ER3
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L29, C9]: view ER4 = R4_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L29, C20]: R4_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: ER4
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L30, C9]: view ER5 = R5_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L30, C20]: R5_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: ER5
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L31, C9]: view ER6 = R6_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L31, C20]: R6_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: ER6
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L32, C9]: view ER7 = R7_S[0..31]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L32, C20]: R7_S[0..31]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 32
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: ER7
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L35, C9]: view R0H = R0_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L35, C20]: R0_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L36, C9]: view R1H = R1_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L36, C20]: R1_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L37, C9]: view R2H = R2_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L37, C20]: R2_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L38, C9]: view R3H = R3_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L38, C20]: R3_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L39, C9]: view R4H = R4_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L39, C20]: R4_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L40, C9]: view R5H = R5_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L40, C20]: R5_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L41, C9]: view R6H = R6_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L41, C20]: R6_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L42, C9]: view R7H = R7_S[8..15]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L42, C20]: R7_S[8..15]
      │   │   │   ├─ FromIndex: 8
      │   │   │   ├─ ToIndex: 16
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7H
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L45, C9]: view R0L = R0_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L45, C20]: R0_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R0_S
      │   │   │ 
      │   │   └─ Name: R0L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L46, C9]: view R1L = R1_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L46, C20]: R1_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R1_S
      │   │   │ 
      │   │   └─ Name: R1L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L47, C9]: view R2L = R2_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L47, C20]: R2_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R2_S
      │   │   │ 
      │   │   └─ Name: R2L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L48, C9]: view R3L = R3_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L48, C20]: R3_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R3_S
      │   │   │ 
      │   │   └─ Name: R3L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L49, C9]: view R4L = R4_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L49, C20]: R4_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R4_S
      │   │   │ 
      │   │   └─ Name: R4L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L50, C9]: view R5L = R5_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L50, C20]: R5_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R5_S
      │   │   │ 
      │   │   └─ Name: R5L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L51, C9]: view R6L = R6_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L51, C20]: R6_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R6_S
      │   │   │ 
      │   │   └─ Name: R6L
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L52, C9]: view R7L = R7_S[0..7]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L52, C20]: R7_S[0..7]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 8
      │   │   │   └─ Name: R7_S
      │   │   │ 
      │   │   └─ Name: R7L
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L55, C9]: storage IP_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: IP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L56, C9]: storage AR_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: AR_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L57, C9]: storage ALR_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: ALR_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L58, C9]: view IP = IP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L58, C19]: IP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IP_S
      │   │   │ 
      │   │   └─ Name: IP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L59, C9]: view AR = AR_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L59, C19]: AR_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: AR_S
      │   │   │ 
      │   │   └─ Name: AR
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L60, C9]: view ALR = ALR_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L60, C20]: ALR_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: ALR_S
      │   │   │ 
      │   │   └─ Name: ALR
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L63, C9]: storage SP_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: SP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L64, C9]: storage BP_S [32]
      │   │   ├─ Size: 32
      │   │   └─ Name: BP_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L65, C9]: storage BR1_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR1_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L66, C9]: storage BR2_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: BR2_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L67, C9]: storage RT_S [64]
      │   │   ├─ Size: 64
      │   │   └─ Name: RT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L68, C9]: view SP = SP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L68, C19]: SP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: SP_S
      │   │   │ 
      │   │   └─ Name: SP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L69, C9]: view BP = BP_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L69, C19]: BP_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BP_S
      │   │   │ 
      │   │   └─ Name: BP
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L70, C9]: view BR1 = BR1_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L70, C20]: BR1_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR1_S
      │   │   │ 
      │   │   └─ Name: BR1
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L71, C9]: view BR2 = BR2_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L71, C20]: BR2_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: BR2_S
      │   │   │ 
      │   │   └─ Name: BR2
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L72, C9]: view RT = RT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L72, C19]: RT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: RT_S
      │   │   │ 
      │   │   └─ Name: RT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L75, C9]: storage IN_S [8]
      │   │   ├─ Size: 8
      │   │   └─ Name: IN_S
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L76, C9]: storage OUT_S [8]
      │   │   ├─ Size: 8
      │   │   └─ Name: OUT_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L77, C9]: view IN = IN_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L77, C19]: IN_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: IN_S
      │   │   │ 
      │   │   └─ Name: IN
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L78, C9]: view OUT = OUT_S
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L78, C20]: OUT_S
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 2147483647
      │   │   │   └─ Name: OUT_S
      │   │   │ 
      │   │   └─ Name: OUT
      │   │ 
      │   ├─ ArchRegsStorageItemSyntaxNode at [L81, C9]: storage FLAGS_S [4]
      │   │   ├─ Size: 4
      │   │   └─ Name: FLAGS_S
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L82, C9]: view N = FLAGS_S[0]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L82, C18]: FLAGS_S[0]
      │   │   │   ├─ FromIndex: 0
      │   │   │   ├─ ToIndex: 1
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: N
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L83, C9]: view Z = FLAGS_S[1]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L83, C18]: FLAGS_S[1]
      │   │   │   ├─ FromIndex: 1
      │   │   │   ├─ ToIndex: 2
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: Z
      │   │ 
      │   ├─ ArchRegsViewItemSyntaxNode at [L84, C9]: view V = FLAGS_S[2]
      │   │   ├─ IsHidden: False
      │   │   ├─ ArchRegsViewWindowSyntaxNode at [L84, C18]: FLAGS_S[2]
      │   │   │   ├─ FromIndex: 2
      │   │   │   ├─ ToIndex: 3
      │   │   │   └─ Name: FLAGS_S
      │   │   │ 
      │   │   └─ Name: V
      │   │ 
      │   └─ ArchRegsViewItemSyntaxNode at [L85, C9]: view C = FLAGS_S[3]
      │       ├─ IsHidden: False
      │       ├─ ArchRegsViewWindowSyntaxNode at [L85, C18]: FLAGS_S[3]
      │       │   ├─ FromIndex: 3
      │       │   ├─ ToIndex: 4
      │       │   └─ Name: FLAGS_S
      │       │ 
      │       └─ Name: C
      │     
      ├─ ArchMemorySyntaxNode at [L88, C5]: memory:\n        range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }\n\n        range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L89, C9]: range codeM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: codeM
      │   │ 
      │   ├─ ArchMemoryRangeItemSyntaxNode at [L95, C9]: range constantsM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │   │   ├─ AddressFrom: 0
      │   │   ├─ AddressTo: 4294967295
      │   │   ├─ CellSize: 8
      │   │   ├─ Endianess: Little
      │   │   ├─ Granularity: 0
      │   │   └─ Name: constantsM
      │   │ 
      │   └─ ArchMemoryRangeItemSyntaxNode at [L101, C9]: range dataM [0x00000000 .. 0xffffffff] {\n            cell = 8;\n            endianess = little-endian;\n            granularity = 0;\n        }
      │       ├─ AddressFrom: 0
      │       ├─ AddressTo: 4294967295
      │       ├─ CellSize: 8
      │       ├─ Endianess: Little
      │       ├─ Granularity: 0
      │       └─ Name: dataM
      │     
      ├─ ArchInstructionsSyntaxNode at [L107, C5]: instructions: \n        encode imm32 field = immediate[32];\n        encode off32 field = immediate[32] offset;\n\n        encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    };\n\n        encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        };\n \n    instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};\n\n    // 0000 0001 YYXX XXXX XXXX XX00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n    instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    };\n\n    instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    };\n\n    instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    };\n\n    instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    };\n\n    instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    };\n\n    //to < from\n    //size - destination size\n    instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    //to > from\n    //size - destination size\n    instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n\n    instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    };\n\n    instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    };\n\n    instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    };\n\n    instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    };\n\n    instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    };\n\n    instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    };\n\n    instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    };\n\n    instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    };\n\n    instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    };\n\n    instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    };\n    instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    };\n\n    instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    };\n\n    instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	};
      │   ├─ ArchFieldEncodingSyntaxNode at [L108, C9]: encode imm32 field = immediate[32]
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L108, C30]: immediate[32]
      │   │   │   ├─ Length: 32
      │   │   │   ├─ Modifier: None
      │   │   │   └─ Kind: Default
      │   │   │ 
      │   │   └─ Name: imm32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L109, C9]: encode off32 field = immediate[32] offset
      │   │   ├─ ArchFieldEncImmediateDescrSyntaxNode at [L109, C30]: immediate[32] offset
      │   │   │   ├─ Length: 32
      │   │   │   ├─ Modifier: None
      │   │   │   └─ Kind: Offset
      │   │   │ 
      │   │   └─ Name: off32
      │   │ 
      │   ├─ ArchFieldEncodingSyntaxNode at [L111, C9]: encode reg field = register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    }
      │   │   ├─ ArchFieldEncRegisterDescrSyntaxNode at [L111, C28]: register {\n            R0 = 000000,\n            R1 = 000001,\n            R2 = 000010,\n            R3 = 000011,\n            R4 = 000100,\n            R5 = 000101,\n            R6 = 000110,\n            R7 = 000111,\n            IP = 001000,\n            SP = 001001,\n            BP = 001010,\n            IN = 001011,\n            OUT = 001100,\n            AR = 001101,\n            RT = 001110,\n            BR1 = 001111,\n            BR2 = 010000,\n            ALR = 010001\n	    }
      │   │   │   └─ Modifier: None
      │   │   │ 
      │   │   └─ Name: reg
      │   │ 
      │   ├─ ArchFieldsGroupEncodingSyntaxNode at [L132, C9]: encode size sequence = alternatives {\n            sz8 = {00}, //8 бит\n            sz16 = {01}, //16 бит\n            sz32 = {10}, //32 бит\n            sz64 = {11} //64 бита\n        }
      │   │   └─ Name: size
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L139, C5]: instruction nop = {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L139, C23]: {0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L139, C24]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L139, C105]: {\n	}
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L139, C105]: {\n	}
      │   │   │ 
      │   │   └─ Name: nop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L143, C5]: instruction add = {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L143, C23]: {0000 0001, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L143, C24]: 0000 0001
      │   │   │   │   └─ BitsStr: 0000 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L143, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L143, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L143, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L143, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L143, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L143, C130]: {\n        when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L144, C9]: when sz8 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L144, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L144, C23]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L145, C13]: let res = reg1 + reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L145, C23]: reg1 + reg2
      │   │   │       │   │   │       ├─ Operator: Sum
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L145, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L145, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L146, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L146, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L147, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L147, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L147, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L147, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L147, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L147, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L148, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L148, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L148, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L148, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L148, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L148, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L148, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L148, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L148, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L149, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L149, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L149, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L149, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L149, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L149, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L149, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L149, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L149, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L150, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L150, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L150, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L150, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L150, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L150, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L150, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L150, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L150, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L150, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L150, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L150, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L150, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L150, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L150, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L150, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L150, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L150, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L151, C16]: when sz16 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L151, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L151, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L152, C13]: let res = reg1 + reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L152, C23]: reg1 + reg2
      │   │   │       │       │   │       ├─ Operator: Sum
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L152, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L152, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L153, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L153, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L154, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L154, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L154, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L154, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L154, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L154, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L155, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L155, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L155, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L155, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L155, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L155, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L155, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L155, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L155, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L156, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L156, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L156, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L156, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L156, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L156, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L156, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L156, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L156, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L157, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L157, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L157, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L157, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L157, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L157, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L157, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L157, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L157, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L157, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L157, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L157, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L157, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L157, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L157, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L157, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L157, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L157, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L158, C16]: when sz32 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L158, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L158, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L159, C13]: let res = reg1 + reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L159, C23]: reg1 + reg2
      │   │   │       │           │   │       ├─ Operator: Sum
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L159, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L159, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L160, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L160, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L161, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L161, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L161, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L161, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L161, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L161, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L162, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L162, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L162, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L162, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L162, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L162, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L162, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L162, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L162, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L163, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L163, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L163, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L163, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L163, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L163, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L163, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L163, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L163, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L164, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L164, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L164, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L164, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L164, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L164, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L164, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L164, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L164, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L164, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L164, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L164, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L164, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L164, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L164, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L164, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L164, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L164, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L165, C16]: when sz64 then {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L165, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L165, C31]: {\n            let res = reg1 + reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L166, C13]: let res = reg1 + reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L166, C23]: reg1 + reg2
      │   │   │       │               │   │       ├─ Operator: Sum
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L166, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L166, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L167, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L167, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L168, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L168, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L168, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L168, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L168, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L168, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L169, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L169, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L169, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L169, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L169, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L169, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L169, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L169, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L169, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L170, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L170, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L170, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L170, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L170, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L170, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L170, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L170, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L170, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L171, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L171, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L171, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L171, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L171, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L171, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L171, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L171, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L171, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L171, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L171, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L171, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L171, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L171, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L171, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L171, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L171, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L171, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L174, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L174, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L174, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L174, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L174, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L174, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L175, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L175, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L175, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L175, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ElseBranchOrNull: <NULL>
      │   │   │       │ 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L178, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L178, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L178, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L178, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L178, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L178, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: add
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L181, C5]: instruction load-imm32 = {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value} {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L181, C30]: {0000 0010, 10, reg as to, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C31]: 0000 0010
      │   │   │   │   └─ BitsStr: 0000 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C42]: 10
      │   │   │   │   └─ BitsStr: 10
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L181, C46]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C57]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L181, C65]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L181, C79]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L181, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L181, C95]: {\n        to = value;\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L182, C9]: to = value;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L182, C9]: to = value
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L182, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L182, C14]: value
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L184, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L184, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L184, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L184, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L184, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L184, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-imm32
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L187, C5]: instruction load = {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L187, C24]: {0000 0011, sequence size, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C25]: 0000 0011
      │   │   │   │   └─ BitsStr: 0000 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L187, C36]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L187, C51]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L187, C62]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L187, C74]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L187, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L187, C128]: {\n        when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L188, C9]: when sz8 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L188, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L188, C23]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L189, C13]: let res = dataM:8[ptr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L189, C23]: dataM:8[ptr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L189, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L189, C31]: ptr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L190, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L190, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L190, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L190, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L190, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L190, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L191, C16]: when sz16 then {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L191, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L191, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L192, C13]: let res = dataM:8[ptr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L192, C23]: dataM:8[ptr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L192, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L192, C31]: ptr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L193, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L193, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L193, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L193, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L193, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L193, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L194, C16]: when sz32 then {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L194, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L194, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L195, C13]: let res = dataM:8[ptr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L195, C23]: dataM:8[ptr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L195, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L195, C31]: ptr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L196, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L196, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L196, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L196, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L196, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L196, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L197, C16]: when sz64 then {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L197, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L197, C31]: {\n            let res = dataM:8[ptr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L198, C13]: let res = dataM:8[ptr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L198, C23]: dataM:8[ptr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L198, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L198, C31]: ptr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L199, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L199, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L199, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L199, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L199, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L199, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L201, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L201, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L201, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L201, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L201, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L201, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L204, C5]: instruction store = {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L204, C25]: {0000 0100, sequence size, reg as from, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L204, C26]: 0000 0100
      │   │   │   │   └─ BitsStr: 0000 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L204, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L204, C52]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L204, C65]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L204, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L204, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L204, C131]: {\n        when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L205, C9]: when sz8 then {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L205, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L205, C23]: {\n            dataM:8[ptr] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L206, C13]: dataM:8[ptr] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L206, C13]: dataM:8[ptr] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L206, C13]: dataM:8[ptr]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L206, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnPlaceExprSyntaxNode at [L206, C21]: ptr
      │   │   │       │   │           │ 
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L206, C28]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L206, C28]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L206, C35]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L207, C16]: when sz16 then {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L207, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L207, C31]: {\n            dataM:8[ptr] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L208, C13]: dataM:8[ptr] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L208, C13]: dataM:8[ptr] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L208, C13]: dataM:8[ptr]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L208, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnPlaceExprSyntaxNode at [L208, C21]: ptr
      │   │   │       │       │           │ 
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L208, C28]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L208, C28]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L208, C35]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L209, C16]: when sz32 then {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L209, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L209, C31]: {\n            dataM:8[ptr] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L210, C13]: dataM:8[ptr] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L210, C13]: dataM:8[ptr] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L210, C13]: dataM:8[ptr]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L210, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnPlaceExprSyntaxNode at [L210, C21]: ptr
      │   │   │       │           │           │ 
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L210, C28]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L210, C28]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L210, C35]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L211, C16]: when sz64 then {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L211, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L211, C31]: {\n            dataM:8[ptr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L212, C13]: dataM:8[ptr] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L212, C13]: dataM:8[ptr] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L212, C13]: dataM:8[ptr]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L212, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnPlaceExprSyntaxNode at [L212, C21]: ptr
      │   │   │       │               │           │ 
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L212, C28]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L212, C28]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L212, C35]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L214, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L214, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L214, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L214, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L214, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L214, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L217, C5]: instruction out = {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L217, C23]: {0000 0101, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C24]: 0000 0101
      │   │   │   │   └─ BitsStr: 0000 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L217, C39]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C52]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L217, C60]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L217, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L217, C114]: {\n        OUT = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L218, C9]: OUT = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L218, C9]: OUT = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L218, C9]: OUT
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L218, C15]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L219, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L219, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L219, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L219, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L219, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L219, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: out
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L222, C5]: instruction in = {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L222, C22]: {0000 0110, 00, 000000, reg as to, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C23]: 0000 0110
      │   │   │   │   └─ BitsStr: 0000 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L222, C46]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L222, C57]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L222, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L222, C111]: {\n        to = IN;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L223, C9]: to = IN;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L223, C9]: to = IN
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L223, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L223, C14]: IN
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L224, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L224, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L224, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L224, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L224, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L224, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: in
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L227, C5]: instruction load-off = {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L227, C28]: {0000 0111, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L227, C29]: 0000 0111
      │   │   │   │   └─ BitsStr: 0000 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L227, C40]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L227, C55]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L227, C66]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L227, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L227, C92]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L227, C114]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L227, C114]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L228, C9]: let addr = 0;
      │   │   │       │   ├─ Name: addr
      │   │   │       │   └─ ArchInsnLiteralExprSyntaxNode at [L228, C20]: 0
      │   │   │       │       ├─ Kind: Dec
      │   │   │       │       └─ ValueString: 0
      │   │   │       │     
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L229, C9]: if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │   ├─ ArchInsnBinaryExprSyntaxNode at [L229, C12]: (offsetValue >> 31) & 1 == 1
      │   │   │       │   │   ├─ Operator: Equal
      │   │   │       │   │   ├─ ArchInsnBinaryExprSyntaxNode at [L229, C12]: (offsetValue >> 31) & 1
      │   │   │       │   │   │   ├─ Operator: BitsAnd
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L229, C12]: (offsetValue >> 31)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L229, C13]: offsetValue >> 31
      │   │   │       │   │   │   │       ├─ Operator: BitsShRight
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L229, C13]: offsetValue
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L229, C28]: 31
      │   │   │       │   │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │   │           └─ ValueString: 31
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L229, C34]: 1
      │   │   │       │   │   │       ├─ Kind: Dec
      │   │   │       │   │   │       └─ ValueString: 1
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnLiteralExprSyntaxNode at [L229, C39]: 1
      │   │   │       │   │       ├─ Kind: Dec
      │   │   │       │   │       └─ ValueString: 1
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L229, C46]: { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L230, C13]: let temp = offsetValue;
      │   │   │       │   │   │   ├─ Name: temp
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L230, C24]: offsetValue
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L231, C13]: addr = ptr + temp;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L231, C13]: addr = ptr + temp
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L231, C13]: addr
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L231, C20]: ptr + temp
      │   │   │       │   │               ├─ Operator: Sum
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L231, C20]: ptr
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L231, C26]: temp
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L232, C16]: { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L233, C13]: addr = ptr + offsetValue;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L233, C13]: addr = ptr + offsetValue
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L233, C13]: addr
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L233, C20]: ptr + offsetValue
      │   │   │       │                   ├─ Operator: Sum
      │   │   │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L233, C20]: ptr
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L233, C26]: offsetValue
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L235, C9]: addr = addr & 0x00000000ffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L235, C9]: addr = addr & 0x00000000ffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L235, C9]: addr
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L235, C16]: addr & 0x00000000ffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L235, C16]: addr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L235, C23]: 0x00000000ffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │             
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L236, C9]: when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L236, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L236, C23]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L237, C13]: let res = dataM:8[addr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L237, C23]: dataM:8[addr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L237, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L237, C31]: addr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L238, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L238, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L238, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L238, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L238, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L238, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L239, C16]: when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L239, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L239, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L240, C13]: let res = dataM:8[addr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L240, C23]: dataM:8[addr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L240, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L240, C31]: addr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L241, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L241, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L241, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L241, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L241, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L241, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L242, C16]: when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L242, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L242, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L243, C13]: let res = dataM:8[addr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L243, C23]: dataM:8[addr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L243, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L243, C31]: addr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L244, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L244, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L244, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L244, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L244, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L244, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L245, C16]: when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L245, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L245, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L246, C13]: let res = dataM:8[addr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L246, C23]: dataM:8[addr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L246, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L246, C31]: addr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L247, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L247, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L247, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L247, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L247, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L247, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L249, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L249, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L249, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L249, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L249, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L249, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L252, C5]: instruction store-off = {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L252, C29]: {0000 1000, sequence size, reg as from, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L252, C30]: 0000 1000
      │   │   │   │   └─ BitsStr: 0000 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L252, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L252, C56]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L252, C69]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L252, C81]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L252, C95]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L252, C117]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L252, C117]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L253, C9]: let addr = 0;
      │   │   │       │   ├─ Name: addr
      │   │   │       │   └─ ArchInsnLiteralExprSyntaxNode at [L253, C20]: 0
      │   │   │       │       ├─ Kind: Dec
      │   │   │       │       └─ ValueString: 0
      │   │   │       │     
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L254, C9]: if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │   ├─ ArchInsnBinaryExprSyntaxNode at [L254, C12]: (offsetValue >> 31) & 1 == 1
      │   │   │       │   │   ├─ Operator: Equal
      │   │   │       │   │   ├─ ArchInsnBinaryExprSyntaxNode at [L254, C12]: (offsetValue >> 31) & 1
      │   │   │       │   │   │   ├─ Operator: BitsAnd
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L254, C12]: (offsetValue >> 31)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L254, C13]: offsetValue >> 31
      │   │   │       │   │   │   │       ├─ Operator: BitsShRight
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L254, C13]: offsetValue
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L254, C28]: 31
      │   │   │       │   │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │   │           └─ ValueString: 31
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L254, C34]: 1
      │   │   │       │   │   │       ├─ Kind: Dec
      │   │   │       │   │   │       └─ ValueString: 1
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnLiteralExprSyntaxNode at [L254, C39]: 1
      │   │   │       │   │       ├─ Kind: Dec
      │   │   │       │   │       └─ ValueString: 1
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L254, C46]: { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L255, C13]: let temp = offsetValue;
      │   │   │       │   │   │   ├─ Name: temp
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L255, C24]: offsetValue
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L256, C13]: addr = ptr + temp;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L256, C13]: addr = ptr + temp
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L256, C13]: addr
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L256, C20]: ptr + temp
      │   │   │       │   │               ├─ Operator: Sum
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L256, C20]: ptr
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L256, C26]: temp
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L257, C16]: { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L258, C13]: addr = ptr + offsetValue;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L258, C13]: addr = ptr + offsetValue
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L258, C13]: addr
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L258, C20]: ptr + offsetValue
      │   │   │       │                   ├─ Operator: Sum
      │   │   │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L258, C20]: ptr
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L258, C26]: offsetValue
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L260, C9]: addr = addr & 0x00000000ffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L260, C9]: addr = addr & 0x00000000ffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L260, C9]: addr
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L260, C16]: addr & 0x00000000ffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L260, C16]: addr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L260, C23]: 0x00000000ffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │             
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L261, C9]: when sz8 then {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        } else when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L261, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L261, C23]: {\n            dataM:8[addr] = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L262, C13]: dataM:8[addr] = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L262, C13]: dataM:8[addr] = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnIndexerExprSyntaxNode at [L262, C13]: dataM:8[addr]
      │   │   │       │   │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L262, C13]: dataM:8
      │   │   │       │   │           │   └─ ArchInsnPlaceExprSyntaxNode at [L262, C21]: addr
      │   │   │       │   │           │ 
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L262, C29]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L262, C29]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L262, C36]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L263, C16]: when sz16 then {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        } else when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L263, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L263, C31]: {\n            dataM:8[addr] = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L264, C13]: dataM:8[addr] = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L264, C13]: dataM:8[addr] = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnIndexerExprSyntaxNode at [L264, C13]: dataM:8[addr]
      │   │   │       │       │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L264, C13]: dataM:8
      │   │   │       │       │           │   └─ ArchInsnPlaceExprSyntaxNode at [L264, C21]: addr
      │   │   │       │       │           │ 
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L264, C29]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L264, C29]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L264, C36]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L265, C16]: when sz32 then {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L265, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L265, C31]: {\n            dataM:8[addr] = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L266, C13]: dataM:8[addr] = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L266, C13]: dataM:8[addr] = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnIndexerExprSyntaxNode at [L266, C13]: dataM:8[addr]
      │   │   │       │           │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L266, C13]: dataM:8
      │   │   │       │           │           │   └─ ArchInsnPlaceExprSyntaxNode at [L266, C21]: addr
      │   │   │       │           │           │ 
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L266, C29]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L266, C29]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L266, C36]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L267, C16]: when sz64 then {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L267, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L267, C31]: {\n            dataM:8[addr] = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L268, C13]: dataM:8[addr] = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L268, C13]: dataM:8[addr] = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnIndexerExprSyntaxNode at [L268, C13]: dataM:8[addr]
      │   │   │       │               │           │   ├─ ArchInsnPlaceExprSyntaxNode at [L268, C13]: dataM:8
      │   │   │       │               │           │   └─ ArchInsnPlaceExprSyntaxNode at [L268, C21]: addr
      │   │   │       │               │           │ 
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L268, C29]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L268, C29]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L268, C36]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L270, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L270, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L270, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L270, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L270, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L270, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: store-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L273, C5]: instruction push = {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L273, C24]: {0000 1001, 00, reg as from, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L273, C25]: 0000 1001
      │   │   │   │   └─ BitsStr: 0000 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L273, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L273, C40]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L273, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L273, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L273, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L273, C115]: {\n        SP = SP - 8;\n        dataM:8[SP] = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L274, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L274, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L274, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L274, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L274, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L274, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L275, C9]: dataM:8[SP] = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L275, C9]: dataM:8[SP] = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L275, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L275, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L275, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L275, C23]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L276, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L276, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L276, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L276, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L276, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L276, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: push
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L279, C5]: instruction pop = {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L279, C23]: {0000 1010, 00, reg as to, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L279, C24]: 0000 1010
      │   │   │   │   └─ BitsStr: 0000 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L279, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L279, C39]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L279, C50]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L279, C58]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L279, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L279, C112]: {\n        to = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L280, C9]: to = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L280, C9]: to = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L280, C9]: to
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L280, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L280, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L280, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L281, C9]: SP = SP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L281, C9]: SP = SP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L281, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L281, C14]: SP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L281, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L281, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L282, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L282, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L282, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L282, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L282, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L282, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: pop
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L285, C5]: instruction mov = {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L285, C23]: {0000 1011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L285, C24]: 0000 1011
      │   │   │   │   └─ BitsStr: 0000 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L285, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L285, C39]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L285, C50]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L285, C63]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L285, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L285, C117]: {\n        to = from;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L286, C9]: to = from;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L286, C9]: to = from
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L286, C9]: to
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L286, C14]: from
      │   │   │       │     
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L287, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L287, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L287, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L287, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L287, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L287, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L292, C5]: instruction mov-trunc = {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L292, C29]: {0000 1100, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L292, C30]: 0000 1100
      │   │   │   │   └─ BitsStr: 0000 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L292, C41]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L292, C56]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L292, C67]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L292, C80]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L292, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L292, C134]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L293, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L293, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L293, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L294, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L294, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L294, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L294, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L294, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L294, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L295, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L295, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L295, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L296, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L296, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L296, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L296, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L296, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L296, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L297, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L297, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L297, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L298, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L298, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L298, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L298, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L298, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L298, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L299, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L299, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L299, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L300, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L300, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L300, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L300, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L300, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L300, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L302, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L302, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L302, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L302, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L302, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L302, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-trunc
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L307, C5]: instruction mov-zx = {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L307, C26]: {0000 1101, sequence size, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L307, C27]: 0000 1101
      │   │   │   │   └─ BitsStr: 0000 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L307, C38]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L307, C53]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L307, C64]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L307, C77]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L307, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L307, C131]: {\n        when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L308, C9]: when sz8 then {\n            to = from & 0x00000000000000ff;\n        } else when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L308, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L308, C23]: {\n            to = from & 0x00000000000000ff;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L309, C13]: to = from & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L309, C13]: to = from & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L309, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L309, C18]: from & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L309, C18]: from
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L309, C25]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L310, C16]: when sz16 then {\n            to = from & 0x000000000000ffff;\n        } else when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L310, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L310, C31]: {\n            to = from & 0x000000000000ffff;\n        }
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L311, C13]: to = from & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L311, C13]: to = from & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L311, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L311, C18]: from & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L311, C18]: from
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L311, C25]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L312, C16]: when sz32 then {\n            to = from & 0x00000000ffffffff;\n        } else when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L312, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L312, C31]: {\n            to = from & 0x00000000ffffffff;\n        }
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L313, C13]: to = from & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L313, C13]: to = from & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L313, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L313, C18]: from & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L313, C18]: from
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L313, C25]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L314, C16]: when sz64 then {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L314, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L314, C31]: {\n            to = from & 0xffffffffffffffff;\n        }
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L315, C13]: to = from & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L315, C13]: to = from & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L315, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L315, C18]: from & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L315, C18]: from
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L315, C25]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L317, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L317, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L317, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L317, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L317, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L317, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mov-zx
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L320, C5]: instruction convert-b-w = {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L320, C31]: {0000 1110, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L320, C32]: 0000 1110
      │   │   │   │   └─ BitsStr: 0000 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L320, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L320, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L320, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L320, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L320, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L320, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L321, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L321, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L321, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L321, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L321, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L321, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L321, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L322, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L322, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L322, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L322, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L323, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L323, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L323, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L323, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L323, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L323, C35]: {\n            let ext_mask = 0x000000000000ff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L324, C13]: let ext_mask = 0x000000000000ff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L324, C28]: 0x000000000000ff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x000000000000ff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L325, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L325, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L325, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L325, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L325, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L325, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L326, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L327, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L327, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L327, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L327, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L329, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L329, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L329, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L329, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L329, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L329, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-w
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L332, C5]: instruction convert-b-d = {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L332, C31]: {0000 1111, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L332, C32]: 0000 1111
      │   │   │   │   └─ BitsStr: 0000 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L332, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L332, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L332, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L332, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L332, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L332, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L333, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L333, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L333, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L333, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L333, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L333, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L333, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L334, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L334, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L334, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L334, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L335, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L335, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L335, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L335, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L335, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L335, C35]: {\n            let ext_mask = 0x00000000ffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L336, C13]: let ext_mask = 0x00000000ffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L336, C28]: 0x00000000ffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L337, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L337, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L337, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L337, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L337, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L337, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L338, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L339, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L339, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L339, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L339, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L341, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L341, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L341, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L341, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L341, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L341, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L344, C5]: instruction convert-b-q = {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L344, C31]: {0001 0000, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L344, C32]: 0001 0000
      │   │   │   │   └─ BitsStr: 0001 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L344, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L344, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L344, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L344, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L344, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L344, C125]: {\n        let sign_bit = (from >> 7) & 1;\n        let from_masked = from & 0xff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L345, C9]: let sign_bit = (from >> 7) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L345, C24]: (from >> 7) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L345, C24]: (from >> 7)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L345, C25]: from >> 7
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L345, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L345, C33]: 7
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 7
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L345, C38]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L346, C9]: let from_masked = from & 0xff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L346, C27]: from & 0xff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L346, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L346, C34]: 0xff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L347, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L347, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L347, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L347, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L347, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L347, C35]: {\n            let ext_mask = 0xffffffffffffff00;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L348, C13]: let ext_mask = 0xffffffffffffff00;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L348, C28]: 0xffffffffffffff00
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffffff00
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L349, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L349, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L349, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L349, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L349, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L349, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L350, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L351, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L351, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L351, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L351, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L353, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L353, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L353, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L353, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L353, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L353, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-b-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L356, C5]: instruction convert-w-d = {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L356, C31]: {0001 0001, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L356, C32]: 0001 0001
      │   │   │   │   └─ BitsStr: 0001 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L356, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L356, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L356, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L356, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L356, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L356, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L357, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L357, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L357, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L357, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L357, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L357, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L357, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L358, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L358, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L358, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L358, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L359, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L359, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L359, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L359, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L359, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L359, C35]: {\n            let ext_mask = 0x00000000ffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L360, C13]: let ext_mask = 0x00000000ffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L360, C28]: 0x00000000ffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0x00000000ffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L361, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L361, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L361, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L361, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L361, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L361, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L362, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L363, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L363, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L363, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L363, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L365, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L365, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L365, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L365, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L365, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L365, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-d
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L368, C5]: instruction convert-w-q = {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L368, C31]: {0001 0010, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L368, C32]: 0001 0010
      │   │   │   │   └─ BitsStr: 0001 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L368, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L368, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L368, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L368, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L368, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L368, C125]: {\n        let sign_bit = (from >> 15) & 1;\n        let from_masked = from & 0xffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L369, C9]: let sign_bit = (from >> 15) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L369, C24]: (from >> 15) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L369, C24]: (from >> 15)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L369, C25]: from >> 15
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L369, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L369, C33]: 15
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 15
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L369, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L370, C9]: let from_masked = from & 0xffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L370, C27]: from & 0xffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L370, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L370, C34]: 0xffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L371, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L371, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L371, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L371, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L371, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L371, C35]: {\n            let ext_mask = 0xffffffffffff0000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L372, C13]: let ext_mask = 0xffffffffffff0000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L372, C28]: 0xffffffffffff0000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffffffff0000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L373, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L373, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L373, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L373, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L373, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L373, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L374, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L375, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L375, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L375, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L375, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L377, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L377, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L377, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L377, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L377, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L377, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-w-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L381, C5]: instruction convert-d-q = {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L381, C31]: {0001 0011, 00, reg as to, reg as from, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L381, C32]: 0001 0011
      │   │   │   │   └─ BitsStr: 0001 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L381, C43]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L381, C47]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L381, C58]: reg as from
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: from
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L381, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L381, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L381, C125]: {\n        let sign_bit = (from >> 31) & 1;\n        let from_masked = from & 0xffffffff;\n        if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L382, C9]: let sign_bit = (from >> 31) & 1;
      │   │   │       │   ├─ Name: sign_bit
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L382, C24]: (from >> 31) & 1
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnBracesExprSyntaxNode at [L382, C24]: (from >> 31)
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L382, C25]: from >> 31
      │   │   │       │       │       ├─ Operator: BitsShRight
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L382, C25]: from
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L382, C33]: 31
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 31
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L382, C39]: 1
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 1
      │   │   │       │         
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L383, C9]: let from_masked = from & 0xffffffff;
      │   │   │       │   ├─ Name: from_masked
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L383, C27]: from & 0xffffffff
      │   │   │       │       ├─ Operator: BitsAnd
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L383, C27]: from
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L383, C34]: 0xffffffff
      │   │   │       │           ├─ Kind: Hex
      │   │   │       │           └─ ValueString: 0xffffffff
      │   │   │       │         
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L384, C9]: if (sign_bit == 0x1) then {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        } else {\n            to = from_masked;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L384, C12]: (sign_bit == 0x1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L384, C13]: sign_bit == 0x1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L384, C13]: sign_bit
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L384, C25]: 0x1
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L384, C35]: {\n            let ext_mask = 0xffffffff00000000;\n            to = ext_mask | from_masked;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L385, C13]: let ext_mask = 0xffffffff00000000;
      │   │   │       │   │   │   ├─ Name: ext_mask
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L385, C28]: 0xffffffff00000000
      │   │   │       │   │   │       ├─ Kind: Hex
      │   │   │       │   │   │       └─ ValueString: 0xffffffff00000000
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L386, C13]: to = ext_mask | from_masked;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L386, C13]: to = ext_mask | from_masked
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L386, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L386, C18]: ext_mask | from_masked
      │   │   │       │   │               ├─ Operator: BitsOr
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L386, C18]: ext_mask
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L386, C29]: from_masked
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L387, C16]: {\n            to = from_masked;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L388, C13]: to = from_masked;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L388, C13]: to = from_masked
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L388, C13]: to
      │   │   │       │               └─ ArchInsnPlaceExprSyntaxNode at [L388, C18]: from_masked
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L390, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L390, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L390, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L390, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L390, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L390, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: convert-d-q
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L393, C5]: instruction sub = {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L393, C23]: {0001 0100, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L393, C24]: 0001 0100
      │   │   │   │   └─ BitsStr: 0001 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L393, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L393, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L393, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L393, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L393, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L393, C130]: {\n        when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L394, C9]: when sz8 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L394, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L394, C23]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000000000ff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 7) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L395, C13]: let res = reg1 - reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L395, C23]: reg1 - reg2
      │   │   │       │   │   │       ├─ Operator: Sub
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L395, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L395, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L396, C13]: let tempReg1 = reg1;
      │   │   │       │   │   │   ├─ Name: tempReg1
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L396, C28]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L397, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L397, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L397, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L397, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L397, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L397, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L398, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L398, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L398, C13]: C
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L398, C17]: (reg1 < tempReg1) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L398, C17]: (reg1 < tempReg1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L398, C18]: reg1 < tempReg1
      │   │   │       │   │   │           │       ├─ Operator: Less
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L398, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L398, C25]: tempReg1
      │   │   │       │   │   │           │     
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L398, C37]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L399, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L399, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L399, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L399, C17]: (reg1 >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L399, C17]: (reg1 >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L399, C18]: reg1 >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L399, C18]: reg1
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L399, C26]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L399, C31]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L400, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L400, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L400, C13]: V
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L400, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L400, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L400, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnBracesExprSyntaxNode at [L400, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │   │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L400, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │   │               │       │       ├─ Operator: BitsAnd
      │   │   │       │   │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L400, C19]: (tempReg1 ^ reg1)
      │   │   │       │   │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L400, C20]: tempReg1 ^ reg1
      │   │   │       │   │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L400, C20]: tempReg1
      │   │   │       │   │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L400, C31]: reg1
      │   │   │       │   │               │       │       │     
      │   │   │       │   │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L400, C39]: (reg2 ^ reg1)
      │   │   │       │   │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L400, C40]: reg2 ^ reg1
      │   │   │       │   │               │       │               ├─ Operator: BitsXor
      │   │   │       │   │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L400, C40]: reg2
      │   │   │       │   │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L400, C47]: reg1
      │   │   │       │   │               │       │             
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L400, C57]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L400, C62]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L401, C16]: when sz16 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L401, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L401, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x000000000000ffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 15) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L402, C13]: let res = reg1 - reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L402, C23]: reg1 - reg2
      │   │   │       │       │   │       ├─ Operator: Sub
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L402, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L402, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L403, C13]: let tempReg1 = reg1;
      │   │   │       │       │   │   ├─ Name: tempReg1
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L403, C28]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L404, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L404, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L404, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L404, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L404, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L404, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L405, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L405, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L405, C13]: C
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L405, C17]: (reg1 < tempReg1) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L405, C17]: (reg1 < tempReg1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L405, C18]: reg1 < tempReg1
      │   │   │       │       │   │           │       ├─ Operator: Less
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L405, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L405, C25]: tempReg1
      │   │   │       │       │   │           │     
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L405, C37]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L406, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L406, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L406, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L406, C17]: (reg1 >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L406, C17]: (reg1 >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L406, C18]: reg1 >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L406, C18]: reg1
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L406, C26]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L406, C32]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L407, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L407, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L407, C13]: V
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L407, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L407, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L407, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnBracesExprSyntaxNode at [L407, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │       │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L407, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │       │               │       │       ├─ Operator: BitsAnd
      │   │   │       │       │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L407, C19]: (tempReg1 ^ reg1)
      │   │   │       │       │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L407, C20]: tempReg1 ^ reg1
      │   │   │       │       │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L407, C20]: tempReg1
      │   │   │       │       │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L407, C31]: reg1
      │   │   │       │       │               │       │       │     
      │   │   │       │       │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L407, C39]: (reg2 ^ reg1)
      │   │   │       │       │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L407, C40]: reg2 ^ reg1
      │   │   │       │       │               │       │               ├─ Operator: BitsXor
      │   │   │       │       │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L407, C40]: reg2
      │   │   │       │       │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L407, C47]: reg1
      │   │   │       │       │               │       │             
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L407, C57]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L407, C63]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L408, C16]: when sz32 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L408, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L408, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0x00000000ffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 31) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L409, C13]: let res = reg1 - reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L409, C23]: reg1 - reg2
      │   │   │       │           │   │       ├─ Operator: Sub
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L409, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L409, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L410, C13]: let tempReg1 = reg1;
      │   │   │       │           │   │   ├─ Name: tempReg1
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L410, C28]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L411, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L411, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L411, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L411, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L411, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L411, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L412, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L412, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L412, C13]: C
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L412, C17]: (reg1 < tempReg1) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L412, C17]: (reg1 < tempReg1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L412, C18]: reg1 < tempReg1
      │   │   │       │           │   │           │       ├─ Operator: Less
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L412, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L412, C25]: tempReg1
      │   │   │       │           │   │           │     
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L412, C37]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L413, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L413, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L413, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L413, C17]: (reg1 >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L413, C17]: (reg1 >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L413, C18]: reg1 >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L413, C18]: reg1
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L413, C26]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L413, C32]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L414, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L414, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L414, C13]: V
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L414, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L414, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L414, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnBracesExprSyntaxNode at [L414, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │           │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L414, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │           │               │       │       ├─ Operator: BitsAnd
      │   │   │       │           │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L414, C19]: (tempReg1 ^ reg1)
      │   │   │       │           │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L414, C20]: tempReg1 ^ reg1
      │   │   │       │           │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L414, C20]: tempReg1
      │   │   │       │           │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L414, C31]: reg1
      │   │   │       │           │               │       │       │     
      │   │   │       │           │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L414, C39]: (reg2 ^ reg1)
      │   │   │       │           │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L414, C40]: reg2 ^ reg1
      │   │   │       │           │               │       │               ├─ Operator: BitsXor
      │   │   │       │           │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L414, C40]: reg2
      │   │   │       │           │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L414, C47]: reg1
      │   │   │       │           │               │       │             
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L414, C57]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L414, C63]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L415, C16]: when sz64 then {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L415, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L415, C31]: {\n            let res = reg1 - reg2;\n            let tempReg1 = reg1;\n            reg1 = res & 0xffffffffffffffff;\n            C = (reg1 < tempReg1) & 1;\n            N = (reg1 >> 63) & 1;\n            V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L416, C13]: let res = reg1 - reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L416, C23]: reg1 - reg2
      │   │   │       │               │   │       ├─ Operator: Sub
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L416, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L416, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L417, C13]: let tempReg1 = reg1;
      │   │   │       │               │   │   ├─ Name: tempReg1
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L417, C28]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L418, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L418, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L418, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L418, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L418, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L418, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L419, C13]: C = (reg1 < tempReg1) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L419, C13]: C = (reg1 < tempReg1) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L419, C13]: C
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L419, C17]: (reg1 < tempReg1) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L419, C17]: (reg1 < tempReg1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L419, C18]: reg1 < tempReg1
      │   │   │       │               │   │           │       ├─ Operator: Less
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L419, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L419, C25]: tempReg1
      │   │   │       │               │   │           │     
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L419, C37]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L420, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L420, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L420, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L420, C17]: (reg1 >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L420, C17]: (reg1 >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L420, C18]: reg1 >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L420, C18]: reg1
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L420, C26]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L420, C32]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L421, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L421, C13]: V = (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L421, C13]: V
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L421, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L421, C17]: (((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L421, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1)) >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnBracesExprSyntaxNode at [L421, C18]: ((tempReg1 ^ reg1) & (reg2 ^ reg1))
      │   │   │       │               │               │       │   └─ ArchInsnBinaryExprSyntaxNode at [L421, C19]: (tempReg1 ^ reg1) & (reg2 ^ reg1)
      │   │   │       │               │               │       │       ├─ Operator: BitsAnd
      │   │   │       │               │               │       │       ├─ ArchInsnBracesExprSyntaxNode at [L421, C19]: (tempReg1 ^ reg1)
      │   │   │       │               │               │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L421, C20]: tempReg1 ^ reg1
      │   │   │       │               │               │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │               │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L421, C20]: tempReg1
      │   │   │       │               │               │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L421, C31]: reg1
      │   │   │       │               │               │       │       │     
      │   │   │       │               │               │       │       └─ ArchInsnBracesExprSyntaxNode at [L421, C39]: (reg2 ^ reg1)
      │   │   │       │               │               │       │           └─ ArchInsnBinaryExprSyntaxNode at [L421, C40]: reg2 ^ reg1
      │   │   │       │               │               │       │               ├─ Operator: BitsXor
      │   │   │       │               │               │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L421, C40]: reg2
      │   │   │       │               │               │       │               └─ ArchInsnPlaceExprSyntaxNode at [L421, C47]: reg1
      │   │   │       │               │               │       │             
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L421, C57]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L421, C63]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L424, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L424, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L424, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L424, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L424, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L424, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L425, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L425, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L425, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L425, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L426, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L427, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L427, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L427, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L427, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L430, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L430, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L430, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L430, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L430, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L430, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: sub
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L433, C5]: instruction mul = {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L433, C23]: {0001 0101, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L433, C24]: 0001 0101
      │   │   │   │   └─ BitsStr: 0001 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L433, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L433, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L433, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L433, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L433, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L433, C130]: {\n        when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L434, C9]: when sz8 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L434, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L434, C23]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L435, C13]: let res = reg1 * reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L435, C23]: reg1 * reg2
      │   │   │       │   │   │       ├─ Operator: Mul
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L435, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L435, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L436, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L436, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L436, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L436, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L436, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L436, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L437, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L437, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L437, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L437, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L437, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L437, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L437, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L437, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L437, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L438, C16]: when sz16 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L438, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L438, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L439, C13]: let res = reg1 * reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L439, C23]: reg1 * reg2
      │   │   │       │       │   │       ├─ Operator: Mul
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L439, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L439, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L440, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L440, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L440, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L440, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L440, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L440, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L441, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L441, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L441, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L441, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L441, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L441, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L441, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L441, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L441, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L442, C16]: when sz32 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L442, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L442, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L443, C13]: let res = reg1 * reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L443, C23]: reg1 * reg2
      │   │   │       │           │   │       ├─ Operator: Mul
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L443, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L443, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L444, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L444, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L444, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L444, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L444, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L444, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L445, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L445, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L445, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L445, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L445, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L445, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L445, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L445, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L445, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L446, C16]: when sz64 then {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L446, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L446, C31]: {\n            let res = reg1 * reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L447, C13]: let res = reg1 * reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L447, C23]: reg1 * reg2
      │   │   │       │               │   │       ├─ Operator: Mul
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L447, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L447, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L448, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L448, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L448, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L448, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L448, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L448, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L449, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L449, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L449, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L449, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L449, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L449, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L449, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L449, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L449, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L452, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L452, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L452, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L452, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L452, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L452, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L453, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L453, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L453, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L453, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L454, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L455, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L455, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L455, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L455, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L458, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L458, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L458, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L458, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L458, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L458, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mul
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L461, C5]: instruction div = {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L461, C23]: {0001 0110, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L461, C24]: 0001 0110
      │   │   │   │   └─ BitsStr: 0001 0110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L461, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L461, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L461, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L461, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L461, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L461, C130]: {\n        when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L462, C9]: when sz8 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L462, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L462, C23]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L463, C13]: let res = reg1 / reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L463, C23]: reg1 / reg2
      │   │   │       │   │   │       ├─ Operator: Div
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L463, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L463, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L464, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L464, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L464, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L464, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L464, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L464, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L465, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L465, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L465, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L465, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L465, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L465, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L465, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L465, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L465, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L466, C16]: when sz16 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L466, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L466, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L467, C13]: let res = reg1 / reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L467, C23]: reg1 / reg2
      │   │   │       │       │   │       ├─ Operator: Div
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L467, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L467, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L468, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L468, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L468, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L468, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L468, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L468, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L469, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L469, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L469, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L469, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L469, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L469, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L469, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L469, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L469, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L470, C16]: when sz32 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L470, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L470, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L471, C13]: let res = reg1 / reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L471, C23]: reg1 / reg2
      │   │   │       │           │   │       ├─ Operator: Div
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L471, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L471, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L472, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L472, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L472, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L472, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L472, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L472, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L473, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L473, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L473, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L473, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L473, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L473, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L473, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L473, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L473, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L474, C16]: when sz64 then {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L474, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L474, C31]: {\n            let res = reg1 / reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L475, C13]: let res = reg1 / reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L475, C23]: reg1 / reg2
      │   │   │       │               │   │       ├─ Operator: Div
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L475, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L475, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L476, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L476, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L476, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L476, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L476, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L476, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L477, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L477, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L477, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L477, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L477, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L477, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L477, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L477, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L477, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L480, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L480, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L480, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L480, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L480, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L480, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L481, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L481, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L481, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L481, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L482, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L483, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L483, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L483, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L483, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L486, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L486, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L486, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L486, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L486, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L486, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: div
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L489, C5]: instruction mod = {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L489, C23]: {0001 0111, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L489, C24]: 0001 0111
      │   │   │   │   └─ BitsStr: 0001 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L489, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L489, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L489, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L489, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L489, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L489, C130]: {\n        when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L490, C9]: when sz8 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L490, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L490, C23]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L491, C13]: let res = reg1 % reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L491, C23]: reg1 % reg2
      │   │   │       │   │   │       ├─ Operator: Mod
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L491, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L491, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L492, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L492, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L492, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L492, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L492, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L492, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L493, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L493, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L493, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L493, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L493, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L493, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L493, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L493, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L493, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L494, C16]: when sz16 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L494, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L494, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L495, C13]: let res = reg1 % reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L495, C23]: reg1 % reg2
      │   │   │       │       │   │       ├─ Operator: Mod
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L495, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L495, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L496, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L496, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L496, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L496, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L496, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L496, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L497, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L497, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L497, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L497, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L497, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L497, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L497, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L497, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L497, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L498, C16]: when sz32 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L498, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L498, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L499, C13]: let res = reg1 % reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L499, C23]: reg1 % reg2
      │   │   │       │           │   │       ├─ Operator: Mod
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L499, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L499, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L500, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L500, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L500, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L500, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L500, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L500, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L501, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L501, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L501, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L501, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L501, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L501, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L501, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L501, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L501, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L502, C16]: when sz64 then {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L502, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L502, C31]: {\n            let res = reg1 % reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L503, C13]: let res = reg1 % reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L503, C23]: reg1 % reg2
      │   │   │       │               │   │       ├─ Operator: Mod
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L503, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L503, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L504, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L504, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L504, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L504, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L504, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L504, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L505, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L505, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L505, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L505, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L505, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L505, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L505, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L505, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L505, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L508, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L508, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L508, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L508, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L508, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L508, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L509, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L509, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L509, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L509, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L510, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L511, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L511, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L511, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L511, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L514, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L514, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L514, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L514, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L514, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L514, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: mod
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L517, C5]: instruction neg = {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L517, C23]: {0001 1000, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L517, C24]: 0001 1000
      │   │   │   │   └─ BitsStr: 0001 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L517, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L517, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L517, C63]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L517, C71]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L517, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L517, C125]: {\n        when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L518, C9]: when sz8 then {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L518, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L518, C23]: {\n            let res = reg1;\n            if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L519, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L519, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L520, C13]: if (reg1 == 0x80) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L520, C16]: (reg1 == 0x80)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L520, C17]: reg1 == 0x80
      │   │   │       │   │   │   │       ├─ Operator: Equal
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L520, C17]: reg1
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L520, C25]: 0x80
      │   │   │       │   │   │   │           ├─ Kind: Hex
      │   │   │       │   │   │   │           └─ ValueString: 0x80
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L520, C36]: {\n                V = 1;\n            }
      │   │   │       │   │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L521, C17]: V = 1;
      │   │   │       │   │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L521, C17]: V = 1
      │   │   │       │   │   │   │           ├─ Operator: Assign
      │   │   │       │   │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L521, C17]: V
      │   │   │       │   │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L521, C21]: 1
      │   │   │       │   │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │   │               └─ ValueString: 1
      │   │   │       │   │   │   │             
      │   │   │       │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L522, C20]: {\n                V = 0;\n            }
      │   │   │       │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L523, C17]: V = 0;
      │   │   │       │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L523, C17]: V = 0
      │   │   │       │   │   │               ├─ Operator: Assign
      │   │   │       │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L523, C17]: V
      │   │   │       │   │   │               └─ ArchInsnLiteralExprSyntaxNode at [L523, C21]: 0
      │   │   │       │   │   │                   ├─ Kind: Dec
      │   │   │       │   │   │                   └─ ValueString: 0
      │   │   │       │   │   │                 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L525, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L525, C13]: reg1 = ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L525, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L525, C20]: ((~res) + 1) & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L525, C20]: ((~res) + 1)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L525, C21]: (~res) + 1
      │   │   │       │   │   │           │       ├─ Operator: Sum
      │   │   │       │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L525, C21]: (~res)
      │   │   │       │   │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L525, C22]: ~res
      │   │   │       │   │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L525, C23]: res
      │   │   │       │   │   │           │       │       └─ IsPrefix: True
      │   │   │       │   │   │           │       │     
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L525, C30]: 1
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 1
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L525, C35]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L526, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L526, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L526, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L526, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L526, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L526, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L526, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L526, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L526, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L527, C16]: when sz16 then {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L527, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L527, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L528, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L528, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L529, C13]: if (reg1 == 0x8000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │       │   │   ├─ ArchInsnBracesExprSyntaxNode at [L529, C16]: (reg1 == 0x8000)
      │   │   │       │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L529, C17]: reg1 == 0x8000
      │   │   │       │       │   │   │       ├─ Operator: Equal
      │   │   │       │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L529, C17]: reg1
      │   │   │       │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L529, C25]: 0x8000
      │   │   │       │       │   │   │           ├─ Kind: Hex
      │   │   │       │       │   │   │           └─ ValueString: 0x8000
      │   │   │       │       │   │   │         
      │   │   │       │       │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L529, C38]: {\n                V = 1;\n            }
      │   │   │       │       │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L530, C17]: V = 1;
      │   │   │       │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L530, C17]: V = 1
      │   │   │       │       │   │   │           ├─ Operator: Assign
      │   │   │       │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L530, C17]: V
      │   │   │       │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L530, C21]: 1
      │   │   │       │       │   │   │               ├─ Kind: Dec
      │   │   │       │       │   │   │               └─ ValueString: 1
      │   │   │       │       │   │   │             
      │   │   │       │       │   │   └─ ArchInsnBlockStmtSyntaxNode at [L531, C20]: {\n                V = 0;\n            }
      │   │   │       │       │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L532, C17]: V = 0;
      │   │   │       │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L532, C17]: V = 0
      │   │   │       │       │   │               ├─ Operator: Assign
      │   │   │       │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L532, C17]: V
      │   │   │       │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L532, C21]: 0
      │   │   │       │       │   │                   ├─ Kind: Dec
      │   │   │       │       │   │                   └─ ValueString: 0
      │   │   │       │       │   │                 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L534, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L534, C13]: reg1 = ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L534, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L534, C20]: ((~res) + 1) & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L534, C20]: ((~res) + 1)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L534, C21]: (~res) + 1
      │   │   │       │       │   │           │       ├─ Operator: Sum
      │   │   │       │       │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L534, C21]: (~res)
      │   │   │       │       │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L534, C22]: ~res
      │   │   │       │       │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │       │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L534, C23]: res
      │   │   │       │       │   │           │       │       └─ IsPrefix: True
      │   │   │       │       │   │           │       │     
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L534, C30]: 1
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 1
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L534, C35]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L535, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L535, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L535, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L535, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L535, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L535, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L535, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L535, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L535, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L536, C16]: when sz32 then {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L536, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L536, C31]: {\n            let res = reg1;\n            if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L537, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L537, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L538, C13]: if (reg1 == 0x80000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │           │   │   ├─ ArchInsnBracesExprSyntaxNode at [L538, C16]: (reg1 == 0x80000000)
      │   │   │       │           │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L538, C17]: reg1 == 0x80000000
      │   │   │       │           │   │   │       ├─ Operator: Equal
      │   │   │       │           │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L538, C17]: reg1
      │   │   │       │           │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L538, C25]: 0x80000000
      │   │   │       │           │   │   │           ├─ Kind: Hex
      │   │   │       │           │   │   │           └─ ValueString: 0x80000000
      │   │   │       │           │   │   │         
      │   │   │       │           │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L538, C42]: {\n                V = 1;\n            }
      │   │   │       │           │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L539, C17]: V = 1;
      │   │   │       │           │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L539, C17]: V = 1
      │   │   │       │           │   │   │           ├─ Operator: Assign
      │   │   │       │           │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L539, C17]: V
      │   │   │       │           │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L539, C21]: 1
      │   │   │       │           │   │   │               ├─ Kind: Dec
      │   │   │       │           │   │   │               └─ ValueString: 1
      │   │   │       │           │   │   │             
      │   │   │       │           │   │   └─ ArchInsnBlockStmtSyntaxNode at [L540, C20]: {\n                V = 0;\n            }
      │   │   │       │           │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L541, C17]: V = 0;
      │   │   │       │           │   │           └─ ArchInsnBinaryExprSyntaxNode at [L541, C17]: V = 0
      │   │   │       │           │   │               ├─ Operator: Assign
      │   │   │       │           │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L541, C17]: V
      │   │   │       │           │   │               └─ ArchInsnLiteralExprSyntaxNode at [L541, C21]: 0
      │   │   │       │           │   │                   ├─ Kind: Dec
      │   │   │       │           │   │                   └─ ValueString: 0
      │   │   │       │           │   │                 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L543, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L543, C13]: reg1 = ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L543, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L543, C20]: ((~res) + 1) & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L543, C20]: ((~res) + 1)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L543, C21]: (~res) + 1
      │   │   │       │           │   │           │       ├─ Operator: Sum
      │   │   │       │           │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L543, C21]: (~res)
      │   │   │       │           │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L543, C22]: ~res
      │   │   │       │           │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │           │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L543, C23]: res
      │   │   │       │           │   │           │       │       └─ IsPrefix: True
      │   │   │       │           │   │           │       │     
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L543, C30]: 1
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 1
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L543, C35]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L544, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L544, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L544, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L544, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L544, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L544, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L544, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L544, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L544, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L545, C16]: when sz64 then {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L545, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L545, C31]: {\n            let res = reg1;\n            if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }\n            reg1 = ((~res) + 1) & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L546, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L546, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   ├─ ArchInsnIfConditionStmtSyntaxNode at [L547, C13]: if (reg1 == 0x8000000000000000) then {\n                V = 1;\n            } else {\n                V = 0;\n            }
      │   │   │       │               │   │   ├─ ArchInsnBracesExprSyntaxNode at [L547, C16]: (reg1 == 0x8000000000000000)
      │   │   │       │               │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L547, C17]: reg1 == 0x8000000000000000
      │   │   │       │               │   │   │       ├─ Operator: Equal
      │   │   │       │               │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L547, C17]: reg1
      │   │   │       │               │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L547, C25]: 0x8000000000000000
      │   │   │       │               │   │   │           ├─ Kind: Hex
      │   │   │       │               │   │   │           └─ ValueString: 0x8000000000000000
      │   │   │       │               │   │   │         
      │   │   │       │               │   │   ├─ ArchInsnBlockStmtSyntaxNode at [L547, C50]: {\n                V = 1;\n            }
      │   │   │       │               │   │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L548, C17]: V = 1;
      │   │   │       │               │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L548, C17]: V = 1
      │   │   │       │               │   │   │           ├─ Operator: Assign
      │   │   │       │               │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L548, C17]: V
      │   │   │       │               │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L548, C21]: 1
      │   │   │       │               │   │   │               ├─ Kind: Dec
      │   │   │       │               │   │   │               └─ ValueString: 1
      │   │   │       │               │   │   │             
      │   │   │       │               │   │   └─ ArchInsnBlockStmtSyntaxNode at [L549, C20]: {\n                V = 0;\n            }
      │   │   │       │               │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L550, C17]: V = 0;
      │   │   │       │               │   │           └─ ArchInsnBinaryExprSyntaxNode at [L550, C17]: V = 0
      │   │   │       │               │   │               ├─ Operator: Assign
      │   │   │       │               │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L550, C17]: V
      │   │   │       │               │   │               └─ ArchInsnLiteralExprSyntaxNode at [L550, C21]: 0
      │   │   │       │               │   │                   ├─ Kind: Dec
      │   │   │       │               │   │                   └─ ValueString: 0
      │   │   │       │               │   │                 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L552, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L552, C13]: reg1 = ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L552, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L552, C20]: ((~res) + 1) & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L552, C20]: ((~res) + 1)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L552, C21]: (~res) + 1
      │   │   │       │               │   │           │       ├─ Operator: Sum
      │   │   │       │               │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L552, C21]: (~res)
      │   │   │       │               │   │           │       │   └─ ArchInsnUnaryExprSyntaxNode at [L552, C22]: ~res
      │   │   │       │               │   │           │       │       ├─ Operator: BitsInv
      │   │   │       │               │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L552, C23]: res
      │   │   │       │               │   │           │       │       └─ IsPrefix: True
      │   │   │       │               │   │           │       │     
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L552, C30]: 1
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 1
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L552, C35]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L553, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L553, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L553, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L553, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L553, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L553, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L553, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L553, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L553, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L556, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n            C = 0;\n        } else {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L556, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L556, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L556, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L556, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L556, C31]: {\n            Z = 1;\n            C = 0;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L557, C13]: Z = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L557, C13]: Z = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L557, C13]: Z
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L557, C17]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L558, C13]: C = 0;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L558, C13]: C = 0
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L558, C13]: C
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L558, C17]: 0
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 0
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L559, C16]: {\n            Z = 0;\n            C = 1;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L560, C13]: Z = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L560, C13]: Z = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L560, C13]: Z
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L560, C17]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L561, C13]: C = 1;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L561, C13]: C = 1
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L561, C13]: C
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L561, C17]: 1
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 1
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L564, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L564, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L564, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L564, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L564, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L564, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neg
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L567, C5]: instruction not-i = {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L567, C25]: {0001 1001, sequence size, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L567, C26]: 0001 1001
      │   │   │   │   └─ BitsStr: 0001 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L567, C37]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L567, C52]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L567, C65]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L567, C73]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L567, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L567, C127]: {\n        when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L568, C9]: when sz8 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L568, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L568, C23]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L569, C13]: let res = reg1;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L569, C23]: reg1
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L570, C13]: reg1 = (~res) & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L570, C13]: reg1 = (~res) & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L570, C13]: reg1
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L570, C20]: (~res) & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L570, C20]: (~res)
      │   │   │       │   │               │   └─ ArchInsnUnaryExprSyntaxNode at [L570, C21]: ~res
      │   │   │       │   │               │       ├─ Operator: BitsInv
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L570, C22]: res
      │   │   │       │   │               │       └─ IsPrefix: True
      │   │   │       │   │               │     
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L570, C29]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L571, C16]: when sz16 then {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L571, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L571, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L572, C13]: let res = reg1;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnPlaceExprSyntaxNode at [L572, C23]: reg1
      │   │   │       │       │   │ 
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L573, C13]: reg1 = (~res) & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L573, C13]: reg1 = (~res) & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L573, C13]: reg1
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L573, C20]: (~res) & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L573, C20]: (~res)
      │   │   │       │       │               │   └─ ArchInsnUnaryExprSyntaxNode at [L573, C21]: ~res
      │   │   │       │       │               │       ├─ Operator: BitsInv
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L573, C22]: res
      │   │   │       │       │               │       └─ IsPrefix: True
      │   │   │       │       │               │     
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L573, C29]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L574, C16]: when sz32 then {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L574, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L574, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L575, C13]: let res = reg1;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnPlaceExprSyntaxNode at [L575, C23]: reg1
      │   │   │       │           │   │ 
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L576, C13]: reg1 = (~res) & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L576, C13]: reg1 = (~res) & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L576, C13]: reg1
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L576, C20]: (~res) & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L576, C20]: (~res)
      │   │   │       │           │               │   └─ ArchInsnUnaryExprSyntaxNode at [L576, C21]: ~res
      │   │   │       │           │               │       ├─ Operator: BitsInv
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L576, C22]: res
      │   │   │       │           │               │       └─ IsPrefix: True
      │   │   │       │           │               │     
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L576, C29]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L577, C16]: when sz64 then {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L577, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L577, C31]: {\n            let res = reg1;\n            reg1 = (~res) & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L578, C13]: let res = reg1;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnPlaceExprSyntaxNode at [L578, C23]: reg1
      │   │   │       │               │   │ 
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L579, C13]: reg1 = (~res) & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L579, C13]: reg1 = (~res) & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L579, C13]: reg1
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L579, C20]: (~res) & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L579, C20]: (~res)
      │   │   │       │               │               │   └─ ArchInsnUnaryExprSyntaxNode at [L579, C21]: ~res
      │   │   │       │               │               │       ├─ Operator: BitsInv
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L579, C22]: res
      │   │   │       │               │               │       └─ IsPrefix: True
      │   │   │       │               │               │     
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L579, C29]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L582, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L582, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L582, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L582, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L582, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L582, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: not-i
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L585, C5]: instruction AND = {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L585, C23]: {0001 1010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L585, C24]: 0001 1010
      │   │   │   │   └─ BitsStr: 0001 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L585, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L585, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L585, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L585, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L585, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L585, C130]: {\n        when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L586, C9]: when sz8 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L586, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L586, C23]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L587, C13]: let res = reg1 & reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L587, C23]: reg1 & reg2
      │   │   │       │   │   │       ├─ Operator: BitsAnd
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L587, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L587, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L588, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L588, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L588, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L588, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L588, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L588, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L589, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L589, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L589, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L589, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L589, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L589, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L589, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L589, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L589, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L590, C16]: when sz16 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L590, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L590, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L591, C13]: let res = reg1 & reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L591, C23]: reg1 & reg2
      │   │   │       │       │   │       ├─ Operator: BitsAnd
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L591, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L591, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L592, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L592, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L592, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L592, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L592, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L592, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L593, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L593, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L593, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L593, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L593, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L593, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L593, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L593, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L593, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L594, C16]: when sz32 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L594, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L594, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L595, C13]: let res = reg1 & reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L595, C23]: reg1 & reg2
      │   │   │       │           │   │       ├─ Operator: BitsAnd
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L595, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L595, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L596, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L596, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L596, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L596, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L596, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L596, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L597, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L597, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L597, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L597, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L597, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L597, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L597, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L597, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L597, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L598, C16]: when sz64 then {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L598, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L598, C31]: {\n            let res = reg1 & reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L599, C13]: let res = reg1 & reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L599, C23]: reg1 & reg2
      │   │   │       │               │   │       ├─ Operator: BitsAnd
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L599, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L599, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L600, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L600, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L600, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L600, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L600, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L600, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L601, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L601, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L601, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L601, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L601, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L601, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L601, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L601, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L601, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L604, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L604, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L604, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L604, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L604, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L604, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L605, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L605, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L605, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L605, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L606, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L607, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L607, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L607, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L607, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L610, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L610, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L610, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L610, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L610, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L610, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L613, C5]: instruction OR = {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L613, C22]: {0001 1011, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L613, C23]: 0001 1011
      │   │   │   │   └─ BitsStr: 0001 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L613, C34]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L613, C49]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L613, C62]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L613, C75]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L613, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L613, C129]: {\n        when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }\n\n        if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L614, C9]: when sz8 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        } else when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L614, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L614, C23]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000000000ff;\n            N = (reg1 >> 7) & 1;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L615, C13]: let res = reg1 | reg2;
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L615, C23]: reg1 | reg2
      │   │   │       │   │   │       ├─ Operator: BitsOr
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L615, C23]: reg1
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L615, C30]: reg2
      │   │   │       │   │   │     
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L616, C13]: reg1 = res & 0x00000000000000ff;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L616, C13]: reg1 = res & 0x00000000000000ff
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L616, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L616, C20]: res & 0x00000000000000ff
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L616, C20]: res
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L616, C26]: 0x00000000000000ff
      │   │   │       │   │   │               ├─ Kind: Hex
      │   │   │       │   │   │               └─ ValueString: 0x00000000000000ff
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L617, C13]: N = (reg1 >> 7) & 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L617, C13]: N = (reg1 >> 7) & 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L617, C13]: N
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L617, C17]: (reg1 >> 7) & 1
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnBracesExprSyntaxNode at [L617, C17]: (reg1 >> 7)
      │   │   │       │   │               │   └─ ArchInsnBinaryExprSyntaxNode at [L617, C18]: reg1 >> 7
      │   │   │       │   │               │       ├─ Operator: BitsShRight
      │   │   │       │   │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L617, C18]: reg1
      │   │   │       │   │               │       └─ ArchInsnLiteralExprSyntaxNode at [L617, C26]: 7
      │   │   │       │   │               │           ├─ Kind: Dec
      │   │   │       │   │               │           └─ ValueString: 7
      │   │   │       │   │               │         
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L617, C31]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L618, C16]: when sz16 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        } else when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L618, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L618, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x000000000000ffff;\n            N = (reg1 >> 15) & 1;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L619, C13]: let res = reg1 | reg2;
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L619, C23]: reg1 | reg2
      │   │   │       │       │   │       ├─ Operator: BitsOr
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L619, C23]: reg1
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L619, C30]: reg2
      │   │   │       │       │   │     
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L620, C13]: reg1 = res & 0x000000000000ffff;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L620, C13]: reg1 = res & 0x000000000000ffff
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L620, C13]: reg1
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L620, C20]: res & 0x000000000000ffff
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L620, C20]: res
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L620, C26]: 0x000000000000ffff
      │   │   │       │       │   │               ├─ Kind: Hex
      │   │   │       │       │   │               └─ ValueString: 0x000000000000ffff
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L621, C13]: N = (reg1 >> 15) & 1;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L621, C13]: N = (reg1 >> 15) & 1
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L621, C13]: N
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L621, C17]: (reg1 >> 15) & 1
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnBracesExprSyntaxNode at [L621, C17]: (reg1 >> 15)
      │   │   │       │       │               │   └─ ArchInsnBinaryExprSyntaxNode at [L621, C18]: reg1 >> 15
      │   │   │       │       │               │       ├─ Operator: BitsShRight
      │   │   │       │       │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L621, C18]: reg1
      │   │   │       │       │               │       └─ ArchInsnLiteralExprSyntaxNode at [L621, C26]: 15
      │   │   │       │       │               │           ├─ Kind: Dec
      │   │   │       │       │               │           └─ ValueString: 15
      │   │   │       │       │               │         
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L621, C32]: 1
      │   │   │       │       │                   ├─ Kind: Dec
      │   │   │       │       │                   └─ ValueString: 1
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L622, C16]: when sz32 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        } else when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L622, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L622, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0x00000000ffffffff;\n            N = (reg1 >> 31) & 1;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L623, C13]: let res = reg1 | reg2;
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L623, C23]: reg1 | reg2
      │   │   │       │           │   │       ├─ Operator: BitsOr
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L623, C23]: reg1
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L623, C30]: reg2
      │   │   │       │           │   │     
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L624, C13]: reg1 = res & 0x00000000ffffffff;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L624, C13]: reg1 = res & 0x00000000ffffffff
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L624, C13]: reg1
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L624, C20]: res & 0x00000000ffffffff
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L624, C20]: res
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L624, C26]: 0x00000000ffffffff
      │   │   │       │           │   │               ├─ Kind: Hex
      │   │   │       │           │   │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L625, C13]: N = (reg1 >> 31) & 1;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L625, C13]: N = (reg1 >> 31) & 1
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L625, C13]: N
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L625, C17]: (reg1 >> 31) & 1
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnBracesExprSyntaxNode at [L625, C17]: (reg1 >> 31)
      │   │   │       │           │               │   └─ ArchInsnBinaryExprSyntaxNode at [L625, C18]: reg1 >> 31
      │   │   │       │           │               │       ├─ Operator: BitsShRight
      │   │   │       │           │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L625, C18]: reg1
      │   │   │       │           │               │       └─ ArchInsnLiteralExprSyntaxNode at [L625, C26]: 31
      │   │   │       │           │               │           ├─ Kind: Dec
      │   │   │       │           │               │           └─ ValueString: 31
      │   │   │       │           │               │         
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L625, C32]: 1
      │   │   │       │           │                   ├─ Kind: Dec
      │   │   │       │           │                   └─ ValueString: 1
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L626, C16]: when sz64 then {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L626, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L626, C31]: {\n            let res = reg1 | reg2;\n            reg1 = res & 0xffffffffffffffff;\n            N = (reg1 >> 63) & 1;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L627, C13]: let res = reg1 | reg2;
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L627, C23]: reg1 | reg2
      │   │   │       │               │   │       ├─ Operator: BitsOr
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L627, C23]: reg1
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L627, C30]: reg2
      │   │   │       │               │   │     
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L628, C13]: reg1 = res & 0xffffffffffffffff;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L628, C13]: reg1 = res & 0xffffffffffffffff
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L628, C13]: reg1
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L628, C20]: res & 0xffffffffffffffff
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L628, C20]: res
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L628, C26]: 0xffffffffffffffff
      │   │   │       │               │   │               ├─ Kind: Hex
      │   │   │       │               │   │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L629, C13]: N = (reg1 >> 63) & 1;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L629, C13]: N = (reg1 >> 63) & 1
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L629, C13]: N
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L629, C17]: (reg1 >> 63) & 1
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnBracesExprSyntaxNode at [L629, C17]: (reg1 >> 63)
      │   │   │       │               │               │   └─ ArchInsnBinaryExprSyntaxNode at [L629, C18]: reg1 >> 63
      │   │   │       │               │               │       ├─ Operator: BitsShRight
      │   │   │       │               │               │       ├─ ArchInsnPlaceExprSyntaxNode at [L629, C18]: reg1
      │   │   │       │               │               │       └─ ArchInsnLiteralExprSyntaxNode at [L629, C26]: 63
      │   │   │       │               │               │           ├─ Kind: Dec
      │   │   │       │               │               │           └─ ValueString: 63
      │   │   │       │               │               │         
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L629, C32]: 1
      │   │   │       │               │                   ├─ Kind: Dec
      │   │   │       │               │                   └─ ValueString: 1
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L632, C9]: if (reg1 == 0x0) then {\n            Z = 1;\n        } else {\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L632, C12]: (reg1 == 0x0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L632, C13]: reg1 == 0x0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L632, C13]: reg1
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L632, C21]: 0x0
      │   │   │       │   │           ├─ Kind: Hex
      │   │   │       │   │           └─ ValueString: 0x0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L632, C31]: {\n            Z = 1;\n        }
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L633, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L633, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L633, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L633, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L634, C16]: {\n            Z = 0;\n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L635, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L635, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L635, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L635, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L638, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L638, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L638, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L638, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L638, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L638, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L641, C5]: instruction jz = {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L641, C22]: {0001 1100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C23]: 0001 1100
      │   │   │   │   └─ BitsStr: 0001 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C38]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C46]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L641, C54]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L641, C68]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L641, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L641, C84]: {\n        if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L642, C9]: if (Z == 0x1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L642, C12]: (Z == 0x1)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L642, C13]: Z == 0x1
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L642, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L642, C18]: 0x1
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x1
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L642, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L643, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L643, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L643, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L643, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L644, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L645, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L645, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L645, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L645, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L645, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L645, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L649, C5]: instruction jnz = {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L649, C23]: {0001 1101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C24]: 0001 1101
      │   │   │   │   └─ BitsStr: 0001 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L649, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L649, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L649, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L649, C85]: {\n        if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L650, C9]: if (Z == 0x0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L650, C12]: (Z == 0x0)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L650, C13]: Z == 0x0
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L650, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L650, C18]: 0x0
      │   │   │           │           ├─ Kind: Hex
      │   │   │           │           └─ ValueString: 0x0
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L650, C28]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L651, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L651, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L651, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L651, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L652, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L653, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L653, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L653, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L653, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L653, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L653, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jnz
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L657, C5]: instruction jeq = {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L657, C23]: {0001 1110, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C24]: 0001 1110
      │   │   │   │   └─ BitsStr: 0001 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L657, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L657, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L657, C85]: {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L657, C85]: {\n        if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L658, C9]: if (Z == 1) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L658, C12]: (Z == 1)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L658, C13]: Z == 1
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L658, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L658, C18]: 1
      │   │   │           │           ├─ Kind: Dec
      │   │   │           │           └─ ValueString: 1
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L658, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L659, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L659, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L659, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L659, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L660, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L661, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L661, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L661, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L661, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L661, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L661, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L665, C5]: instruction jneq = {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L665, C24]: {0001 1111, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C25]: 0001 1111
      │   │   │   │   └─ BitsStr: 0001 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C40]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C48]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L665, C56]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L665, C70]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L665, C86]: {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L665, C86]: {\n        if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L666, C9]: if (Z == 0) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L666, C12]: (Z == 0)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L666, C13]: Z == 0
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L666, C13]: Z
      │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L666, C18]: 0
      │   │   │           │           ├─ Kind: Dec
      │   │   │           │           └─ ValueString: 0
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L666, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L667, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L667, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L667, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L667, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L668, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L669, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L669, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L669, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L669, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L669, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L669, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jneq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L673, C5]: instruction jgr = {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L673, C23]: {0010 0000, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C24]: 0010 0000
      │   │   │   │   └─ BitsStr: 0010 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L673, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L673, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L673, C85]: {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L673, C85]: {\n        if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L674, C9]: if ((N == V) && !Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L674, C12]: ((N == V) && !Z)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L674, C13]: (N == V) && !Z
      │   │   │           │       ├─ Operator: BoolAnd
      │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L674, C13]: (N == V)
      │   │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L674, C14]: N == V
      │   │   │           │       │       ├─ Operator: Equal
      │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L674, C14]: N
      │   │   │           │       │       └─ ArchInsnPlaceExprSyntaxNode at [L674, C19]: V
      │   │   │           │       │     
      │   │   │           │       └─ ArchInsnUnaryExprSyntaxNode at [L674, C25]: !Z
      │   │   │           │           ├─ Operator: BoolInv
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L674, C26]: Z
      │   │   │           │           └─ IsPrefix: True
      │   │   │           │         
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L674, C34]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L675, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L675, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L675, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L675, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L676, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L677, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L677, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L677, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L677, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L677, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L677, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L681, C5]: instruction jle = {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L681, C23]: {0010 0001, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C24]: 0010 0001
      │   │   │   │   └─ BitsStr: 0010 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L681, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L681, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L681, C85]: {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L681, C85]: {\n        if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L682, C9]: if (N != V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L682, C12]: (N != V)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L682, C13]: N != V
      │   │   │           │       ├─ Operator: NotEqual
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L682, C13]: N
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L682, C18]: V
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L682, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L683, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L683, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L683, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L683, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L684, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L685, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L685, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L685, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L685, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L685, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L685, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jle
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L689, C5]: instruction jgreq = {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L689, C25]: {0010 0010, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C26]: 0010 0010
      │   │   │   │   └─ BitsStr: 0010 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L689, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L689, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L689, C87]: {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L689, C87]: {\n        if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L690, C9]: if (N == V) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L690, C12]: (N == V)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L690, C13]: N == V
      │   │   │           │       ├─ Operator: Equal
      │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L690, C13]: N
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L690, C18]: V
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L690, C26]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L691, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L691, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L691, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L691, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L692, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L693, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L693, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L693, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L693, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L693, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L693, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jgreq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L697, C5]: instruction jleeq = {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L697, C25]: {0010 0011, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L697, C26]: 0010 0011
      │   │   │   │   └─ BitsStr: 0010 0011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L697, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L697, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L697, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L697, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L697, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L697, C87]: {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L697, C87]: {\n        if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }\n    }
      │   │   │       └─ ArchInsnIfConditionStmtSyntaxNode at [L698, C9]: if ((N != V) || Z) then {\n            IP = value;\n        } else {\n            IP = IP + 8;\n        }
      │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L698, C12]: ((N != V) || Z)
      │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L698, C13]: (N != V) || Z
      │   │   │           │       ├─ Operator: BoolOr
      │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L698, C13]: (N != V)
      │   │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L698, C14]: N != V
      │   │   │           │       │       ├─ Operator: NotEqual
      │   │   │           │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L698, C14]: N
      │   │   │           │       │       └─ ArchInsnPlaceExprSyntaxNode at [L698, C19]: V
      │   │   │           │       │     
      │   │   │           │       └─ ArchInsnPlaceExprSyntaxNode at [L698, C25]: Z
      │   │   │           │     
      │   │   │           ├─ ArchInsnBlockStmtSyntaxNode at [L698, C33]: {\n            IP = value;\n        }
      │   │   │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L699, C13]: IP = value;
      │   │   │           │       └─ ArchInsnBinaryExprSyntaxNode at [L699, C13]: IP = value
      │   │   │           │           ├─ Operator: Assign
      │   │   │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L699, C13]: IP
      │   │   │           │           └─ ArchInsnPlaceExprSyntaxNode at [L699, C18]: value
      │   │   │           │         
      │   │   │           └─ ArchInsnBlockStmtSyntaxNode at [L700, C16]: {\n            IP = IP + 8;\n        }
      │   │   │               └─ ArchInsnExpressionStmtSyntaxNode at [L701, C13]: IP = IP + 8;
      │   │   │                   └─ ArchInsnBinaryExprSyntaxNode at [L701, C13]: IP = IP + 8
      │   │   │                       ├─ Operator: Assign
      │   │   │                       ├─ ArchInsnPlaceExprSyntaxNode at [L701, C13]: IP
      │   │   │                       └─ ArchInsnBinaryExprSyntaxNode at [L701, C18]: IP + 8
      │   │   │                           ├─ Operator: Sum
      │   │   │                           ├─ ArchInsnPlaceExprSyntaxNode at [L701, C18]: IP
      │   │   │                           └─ ArchInsnLiteralExprSyntaxNode at [L701, C23]: 8
      │   │   │                               ├─ Kind: Dec
      │   │   │                               └─ ValueString: 8
      │   │   │                             
      │   │   └─ Name: jleeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L705, C5]: instruction jmp = {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        IP = value;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L705, C23]: {0010 0100, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L705, C24]: 0010 0100
      │   │   │   │   └─ BitsStr: 0010 0100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L705, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L705, C39]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L705, C47]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L705, C55]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L705, C69]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L705, C85]: {\n        IP = value;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L705, C85]: {\n        IP = value;\n    }
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L706, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L706, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L706, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L706, C14]: value
      │   │   │             
      │   │   └─ Name: jmp
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L709, C5]: instruction call = {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L709, C24]: {0010 0101, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L709, C25]: 0010 0101
      │   │   │   │   └─ BitsStr: 0010 0101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L709, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L709, C40]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L709, C48]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L709, C56]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L709, C70]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L709, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L709, C86]: {\n        SP = SP - 8;\n        dataM:8[SP] = IP + 8;\n        IP = value;        \n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L710, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L710, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L710, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L710, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L710, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L710, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L711, C9]: dataM:8[SP] = IP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L711, C9]: dataM:8[SP] = IP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L711, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L711, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L711, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L711, C23]: IP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L711, C23]: IP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L711, C28]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L712, C9]: IP = value;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L712, C9]: IP = value
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L712, C9]: IP
      │   │   │               └─ ArchInsnPlaceExprSyntaxNode at [L712, C14]: value
      │   │   │             
      │   │   └─ Name: call
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L715, C5]: instruction ret = {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L715, C23]: {0010 0110, 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L715, C24]: 0010 0110
      │   │   │   │   └─ BitsStr: 0010 0110
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L715, C35]: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L715, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L715, C106]: {\n        IP = dataM:8[SP];  \n        SP = SP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L716, C9]: IP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L716, C9]: IP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L716, C9]: IP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L716, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L716, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L716, C22]: SP
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L717, C9]: SP = SP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L717, C9]: SP = SP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L717, C9]: SP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L717, C14]: SP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L717, C14]: SP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L717, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: ret
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L720, C5]: instruction enter = {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L720, C25]: {0010 0111, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L720, C26]: 0010 0111
      │   │   │   │   └─ BitsStr: 0010 0111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L720, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L720, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L720, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L720, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L720, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L720, C87]: {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L720, C87]: {\n        SP = SP - 8;\n        dataM:8[SP] = BP;\n        BP = SP;\n        SP = SP - (8 * value);\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L721, C9]: SP = SP - 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L721, C9]: SP = SP - 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L721, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L721, C14]: SP - 8
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L721, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L721, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L722, C9]: dataM:8[SP] = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L722, C9]: dataM:8[SP] = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnIndexerExprSyntaxNode at [L722, C9]: dataM:8[SP]
      │   │   │       │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L722, C9]: dataM:8
      │   │   │       │       │   └─ ArchInsnPlaceExprSyntaxNode at [L722, C17]: SP
      │   │   │       │       │ 
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L722, C23]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L723, C9]: BP = SP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L723, C9]: BP = SP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L723, C9]: BP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L723, C14]: SP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L724, C9]: SP = SP - (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L724, C9]: SP = SP - (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L724, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L724, C14]: SP - (8 * value)
      │   │   │       │           ├─ Operator: Sub
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L724, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L724, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L724, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L724, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L724, C24]: value
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L725, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L725, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L725, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L725, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L725, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L725, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: enter
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L728, C5]: instruction leave = {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value} {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L728, C25]: {0010 1000, 00, 000000, 000000, 00 0000 0000, imm32 as value}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L728, C26]: 0010 1000
      │   │   │   │   └─ BitsStr: 0010 1000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L728, C37]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L728, C41]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L728, C49]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L728, C57]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L728, C71]: imm32 as value
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: value
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L728, C87]: {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L728, C87]: {\n        SP = SP + (8 * value);\n        SP = BP;\n        BP = dataM:8[SP];\n        SP = SP + 8;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L729, C9]: SP = SP + (8 * value);
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L729, C9]: SP = SP + (8 * value)
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L729, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L729, C14]: SP + (8 * value)
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L729, C14]: SP
      │   │   │       │           └─ ArchInsnBracesExprSyntaxNode at [L729, C19]: (8 * value)
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L729, C20]: 8 * value
      │   │   │       │                   ├─ Operator: Mul
      │   │   │       │                   ├─ ArchInsnLiteralExprSyntaxNode at [L729, C20]: 8
      │   │   │       │                   │   ├─ Kind: Dec
      │   │   │       │                   │   └─ ValueString: 8
      │   │   │       │                   │ 
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L729, C24]: value
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L730, C9]: SP = BP;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L730, C9]: SP = BP
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L730, C9]: SP
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L730, C14]: BP
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L731, C9]: BP = dataM:8[SP];
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L731, C9]: BP = dataM:8[SP]
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L731, C9]: BP
      │   │   │       │       └─ ArchInsnIndexerExprSyntaxNode at [L731, C14]: dataM:8[SP]
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L731, C14]: dataM:8
      │   │   │       │           └─ ArchInsnPlaceExprSyntaxNode at [L731, C22]: SP
      │   │   │       │         
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L732, C9]: SP = SP + 8;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L732, C9]: SP = SP + 8
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L732, C9]: SP
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L732, C14]: SP + 8
      │   │   │       │           ├─ Operator: Sum
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L732, C14]: SP
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L732, C19]: 8
      │   │   │       │               ├─ Kind: Dec
      │   │   │       │               └─ ValueString: 8
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L733, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L733, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L733, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L733, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L733, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L733, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leave
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L736, C5]: instruction load-const = {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L736, C30]: {0010 1001, 11, reg as to, reg as ptr, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L736, C31]: 0010 1001
      │   │   │   │   └─ BitsStr: 0010 1001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L736, C42]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L736, C46]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L736, C57]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L736, C69]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L736, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L736, C123]: {\n        let res = constantsM:8[ptr];\n        to = res & 0xffffffffffffffff;\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L737, C9]: let res = constantsM:8[ptr];
      │   │   │       │   ├─ Name: res
      │   │   │       │   └─ ArchInsnIndexerExprSyntaxNode at [L737, C19]: constantsM:8[ptr]
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L737, C19]: constantsM:8
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L737, C32]: ptr
      │   │   │       │     
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L738, C9]: to = res & 0xffffffffffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L738, C9]: to = res & 0xffffffffffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L738, C9]: to
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L738, C14]: res & 0xffffffffffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L738, C14]: res
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L738, C20]: 0xffffffffffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0xffffffffffffffff
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L739, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L739, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L739, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L739, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L739, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L739, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-const
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L742, C5]: instruction eq = {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L742, C22]: {0010 1010, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L742, C23]: 0010 1010
      │   │   │   │   └─ BitsStr: 0010 1010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L742, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L742, C38]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L742, C51]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L742, C59]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L742, C113]: {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L742, C113]: {\n        if (Z == 1) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L743, C9]: if (Z == 1) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L743, C12]: (Z == 1)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L743, C13]: Z == 1
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L743, C13]: Z
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L743, C18]: 1
      │   │   │       │   │           ├─ Kind: Dec
      │   │   │       │   │           └─ ValueString: 1
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L743, C26]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L744, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L744, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L744, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L744, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L745, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L745, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L745, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L745, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L746, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L747, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L747, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L747, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L747, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L748, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L748, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L748, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L748, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L750, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L750, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L750, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L750, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L750, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L750, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: eq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L753, C5]: instruction neq = {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L753, C23]: {0010 1011, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L753, C24]: 0010 1011
      │   │   │   │   └─ BitsStr: 0010 1011
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L753, C35]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L753, C39]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L753, C52]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L753, C60]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L753, C114]: {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L753, C114]: {\n        if (Z == 0) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L754, C9]: if (Z == 0) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L754, C12]: (Z == 0)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L754, C13]: Z == 0
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L754, C13]: Z
      │   │   │       │   │       └─ ArchInsnLiteralExprSyntaxNode at [L754, C18]: 0
      │   │   │       │   │           ├─ Kind: Dec
      │   │   │       │   │           └─ ValueString: 0
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L754, C26]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L755, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L755, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L755, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L755, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L756, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L756, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L756, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L756, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L757, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L758, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L758, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L758, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L758, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L759, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L759, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L759, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L759, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L761, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L761, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L761, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L761, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L761, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L761, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: neq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L764, C5]: instruction gr = {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L764, C22]: {0010 1100, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L764, C23]: 0010 1100
      │   │   │   │   └─ BitsStr: 0010 1100
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L764, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L764, C38]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L764, C51]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L764, C59]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L764, C113]: {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L764, C113]: {\n        if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L765, C9]: if ((N == V) && !Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L765, C12]: ((N == V) && !Z)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L765, C13]: (N == V) && !Z
      │   │   │       │   │       ├─ Operator: BoolAnd
      │   │   │       │   │       ├─ ArchInsnBracesExprSyntaxNode at [L765, C13]: (N == V)
      │   │   │       │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L765, C14]: N == V
      │   │   │       │   │       │       ├─ Operator: Equal
      │   │   │       │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L765, C14]: N
      │   │   │       │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L765, C19]: V
      │   │   │       │   │       │     
      │   │   │       │   │       └─ ArchInsnUnaryExprSyntaxNode at [L765, C25]: !Z
      │   │   │       │   │           ├─ Operator: BoolInv
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L765, C26]: Z
      │   │   │       │   │           └─ IsPrefix: True
      │   │   │       │   │         
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L765, C34]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L766, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L766, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L766, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L766, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L767, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L767, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L767, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L767, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L768, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L769, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L769, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L769, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L769, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L770, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L770, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L770, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L770, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L772, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L772, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L772, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L772, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L772, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L772, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: gr
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L775, C5]: instruction le = {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L775, C22]: {0010 1101, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L775, C23]: 0010 1101
      │   │   │   │   └─ BitsStr: 0010 1101
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L775, C34]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L775, C38]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L775, C51]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L775, C59]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L775, C113]: {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L775, C113]: {       \n        if (N != V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L776, C9]: if (N != V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L776, C12]: (N != V)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L776, C13]: N != V
      │   │   │       │   │       ├─ Operator: NotEqual
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L776, C13]: N
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L776, C18]: V
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L776, C26]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L777, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L777, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L777, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L777, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L778, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L778, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L778, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L778, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L779, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L780, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L780, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L780, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L780, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L781, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L781, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L781, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L781, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L783, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L783, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L783, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L783, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L783, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L783, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: le
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L786, C5]: instruction greq = {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L786, C24]: {0010 1110, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L786, C25]: 0010 1110
      │   │   │   │   └─ BitsStr: 0010 1110
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L786, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L786, C40]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L786, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L786, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L786, C115]: {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L786, C115]: {\n        if (N == V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L787, C9]: if (N == V) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L787, C12]: (N == V)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L787, C13]: N == V
      │   │   │       │   │       ├─ Operator: Equal
      │   │   │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L787, C13]: N
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L787, C18]: V
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L787, C26]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L788, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L788, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L788, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L788, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L789, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L789, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L789, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L789, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L790, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L791, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L791, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L791, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L791, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L792, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L792, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L792, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L792, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L794, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L794, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L794, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L794, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L794, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L794, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: greq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L797, C5]: instruction leeq = {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L797, C24]: {0010 1111, 00, reg as reg1, 000000, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L797, C25]: 0010 1111
      │   │   │   │   └─ BitsStr: 0010 1111
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L797, C36]: 00
      │   │   │   │   └─ BitsStr: 00
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L797, C40]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L797, C53]: 000000
      │   │   │   │   └─ BitsStr: 000000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L797, C61]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L797, C115]: {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L797, C115]: {\n        if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L798, C9]: if ((N != V) || Z) then {\n            reg1 = 1;\n            Z = 1;\n        } else {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │   ├─ ArchInsnBracesExprSyntaxNode at [L798, C12]: ((N != V) || Z)
      │   │   │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L798, C13]: (N != V) || Z
      │   │   │       │   │       ├─ Operator: BoolOr
      │   │   │       │   │       ├─ ArchInsnBracesExprSyntaxNode at [L798, C13]: (N != V)
      │   │   │       │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L798, C14]: N != V
      │   │   │       │   │       │       ├─ Operator: NotEqual
      │   │   │       │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L798, C14]: N
      │   │   │       │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L798, C19]: V
      │   │   │       │   │       │     
      │   │   │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L798, C25]: Z
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L798, C33]: {\n            reg1 = 1;\n            Z = 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L799, C13]: reg1 = 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L799, C13]: reg1 = 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L799, C13]: reg1
      │   │   │       │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L799, C20]: 1
      │   │   │       │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │           └─ ValueString: 1
      │   │   │       │   │   │         
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L800, C13]: Z = 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L800, C13]: Z = 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L800, C13]: Z
      │   │   │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L800, C17]: 1
      │   │   │       │   │               ├─ Kind: Dec
      │   │   │       │   │               └─ ValueString: 1
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L801, C16]: {\n            reg1 = 0;\n            Z = 0;\n        }
      │   │   │       │       ├─ ArchInsnExpressionStmtSyntaxNode at [L802, C13]: reg1 = 0;
      │   │   │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L802, C13]: reg1 = 0
      │   │   │       │       │       ├─ Operator: Assign
      │   │   │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L802, C13]: reg1
      │   │   │       │       │       └─ ArchInsnLiteralExprSyntaxNode at [L802, C20]: 0
      │   │   │       │       │           ├─ Kind: Dec
      │   │   │       │       │           └─ ValueString: 0
      │   │   │       │       │         
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L803, C13]: Z = 0;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L803, C13]: Z = 0
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L803, C13]: Z
      │   │   │       │               └─ ArchInsnLiteralExprSyntaxNode at [L803, C17]: 0
      │   │   │       │                   ├─ Kind: Dec
      │   │   │       │                   └─ ValueString: 0
      │   │   │       │                 
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L805, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L805, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L805, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L805, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L805, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L805, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: leeq
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L808, C5]: instruction memcpy-const = {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size} {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L808, C32]: {0011 0000, 11, reg as toPtr, reg as fromPtr, 00 0000 0000, imm32 as size}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L808, C33]: 0011 0000
      │   │   │   │   └─ BitsStr: 0011 0000
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L808, C44]: 11
      │   │   │   │   └─ BitsStr: 11
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L808, C48]: reg as toPtr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: toPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L808, C62]: reg as fromPtr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: fromPtr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L808, C78]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L808, C92]: imm32 as size
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: imm32
      │   │   │       └─ FieldName: size
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L808, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L808, C107]: {\n        let i = size;\n        let dest = toPtr;\n        let src = fromPtr;\n\n        while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L809, C9]: let i = size;
      │   │   │       │   ├─ Name: i
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L809, C17]: size
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L810, C9]: let dest = toPtr;
      │   │   │       │   ├─ Name: dest
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L810, C20]: toPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L811, C9]: let src = fromPtr;
      │   │   │       │   ├─ Name: src
      │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L811, C19]: fromPtr
      │   │   │       │ 
      │   │   │       ├─ ArchInsnWhileLoopStmtSyntaxNode at [L813, C9]: while i > 0 do {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L813, C24]: {\n            dataM:8[dest] = constantsM:8[src];\n            dest = dest + 8;\n            src = src + 8;\n            i = i - 1;\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L814, C13]: dataM:8[dest] = constantsM:8[src];
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L814, C13]: dataM:8[dest] = constantsM:8[src]
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnIndexerExprSyntaxNode at [L814, C13]: dataM:8[dest]
      │   │   │       │   │   │       │   ├─ ArchInsnPlaceExprSyntaxNode at [L814, C13]: dataM:8
      │   │   │       │   │   │       │   └─ ArchInsnPlaceExprSyntaxNode at [L814, C21]: dest
      │   │   │       │   │   │       │ 
      │   │   │       │   │   │       └─ ArchInsnIndexerExprSyntaxNode at [L814, C29]: constantsM:8[src]
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L814, C29]: constantsM:8
      │   │   │       │   │   │           └─ ArchInsnPlaceExprSyntaxNode at [L814, C42]: src
      │   │   │       │   │   │         
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L815, C13]: dest = dest + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L815, C13]: dest = dest + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L815, C13]: dest
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L815, C20]: dest + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L815, C20]: dest
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L815, C27]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L816, C13]: src = src + 8;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L816, C13]: src = src + 8
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L816, C13]: src
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L816, C19]: src + 8
      │   │   │       │   │   │           ├─ Operator: Sum
      │   │   │       │   │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L816, C19]: src
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L816, C25]: 8
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 8
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L817, C13]: i = i - 1;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L817, C13]: i = i - 1
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L817, C13]: i
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L817, C17]: i - 1
      │   │   │       │   │               ├─ Operator: Sub
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L817, C17]: i
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L817, C21]: 1
      │   │   │       │   │                   ├─ Kind: Dec
      │   │   │       │   │                   └─ ValueString: 1
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L813, C15]: i > 0
      │   │   │       │       ├─ Operator: Greater
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L813, C15]: i
      │   │   │       │       └─ ArchInsnLiteralExprSyntaxNode at [L813, C19]: 0
      │   │   │       │           ├─ Kind: Dec
      │   │   │       │           └─ ValueString: 0
      │   │   │       │         
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L820, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L820, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L820, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L820, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L820, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L820, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: memcpy-const
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L822, C5]: instruction load-c-off = {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue} {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L822, C30]: {0011 0001, sequence size, reg as to, reg as ptr, 00 0000 0000, off32 as offsetValue}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L822, C31]: 0011 0001
      │   │   │   │   └─ BitsStr: 0011 0001
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L822, C42]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L822, C57]: reg as to
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: to
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L822, C68]: reg as ptr
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: ptr
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L822, C80]: 00 0000 0000
      │   │   │   │   └─ BitsStr: 00 0000 0000
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L822, C94]: off32 as offsetValue
      │   │   │       ├─ ModifierKind: None
      │   │   │       ├─ FieldEncName: off32
      │   │   │       └─ FieldName: offsetValue
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L822, C116]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L822, C116]: {\n        let addr = 0; \n        if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }\n        addr = addr & 0x00000000ffffffff;\n        when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L823, C9]: let addr = 0;
      │   │   │       │   ├─ Name: addr
      │   │   │       │   └─ ArchInsnLiteralExprSyntaxNode at [L823, C20]: 0
      │   │   │       │       ├─ Kind: Dec
      │   │   │       │       └─ ValueString: 0
      │   │   │       │     
      │   │   │       ├─ ArchInsnIfConditionStmtSyntaxNode at [L824, C9]: if (offsetValue >> 31) & 1 == 1 then { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        } else { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │   ├─ ArchInsnBinaryExprSyntaxNode at [L824, C12]: (offsetValue >> 31) & 1 == 1
      │   │   │       │   │   ├─ Operator: Equal
      │   │   │       │   │   ├─ ArchInsnBinaryExprSyntaxNode at [L824, C12]: (offsetValue >> 31) & 1
      │   │   │       │   │   │   ├─ Operator: BitsAnd
      │   │   │       │   │   │   ├─ ArchInsnBracesExprSyntaxNode at [L824, C12]: (offsetValue >> 31)
      │   │   │       │   │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L824, C13]: offsetValue >> 31
      │   │   │       │   │   │   │       ├─ Operator: BitsShRight
      │   │   │       │   │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L824, C13]: offsetValue
      │   │   │       │   │   │   │       └─ ArchInsnLiteralExprSyntaxNode at [L824, C28]: 31
      │   │   │       │   │   │   │           ├─ Kind: Dec
      │   │   │       │   │   │   │           └─ ValueString: 31
      │   │   │       │   │   │   │         
      │   │   │       │   │   │   └─ ArchInsnLiteralExprSyntaxNode at [L824, C34]: 1
      │   │   │       │   │   │       ├─ Kind: Dec
      │   │   │       │   │   │       └─ ValueString: 1
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnLiteralExprSyntaxNode at [L824, C39]: 1
      │   │   │       │   │       ├─ Kind: Dec
      │   │   │       │   │       └─ ValueString: 1
      │   │   │       │   │     
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L824, C46]: { \n            let temp = offsetValue; \n            addr = ptr + temp;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L825, C13]: let temp = offsetValue;
      │   │   │       │   │   │   ├─ Name: temp
      │   │   │       │   │   │   └─ ArchInsnPlaceExprSyntaxNode at [L825, C24]: offsetValue
      │   │   │       │   │   │ 
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L826, C13]: addr = ptr + temp;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L826, C13]: addr = ptr + temp
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L826, C13]: addr
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L826, C20]: ptr + temp
      │   │   │       │   │               ├─ Operator: Sum
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L826, C20]: ptr
      │   │   │       │   │               └─ ArchInsnPlaceExprSyntaxNode at [L826, C26]: temp
      │   │   │       │   │             
      │   │   │       │   └─ ArchInsnBlockStmtSyntaxNode at [L827, C16]: { \n            addr = ptr + offsetValue; \n        }
      │   │   │       │       └─ ArchInsnExpressionStmtSyntaxNode at [L828, C13]: addr = ptr + offsetValue;
      │   │   │       │           └─ ArchInsnBinaryExprSyntaxNode at [L828, C13]: addr = ptr + offsetValue
      │   │   │       │               ├─ Operator: Assign
      │   │   │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L828, C13]: addr
      │   │   │       │               └─ ArchInsnBinaryExprSyntaxNode at [L828, C20]: ptr + offsetValue
      │   │   │       │                   ├─ Operator: Sum
      │   │   │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L828, C20]: ptr
      │   │   │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L828, C26]: offsetValue
      │   │   │       │                 
      │   │   │       ├─ ArchInsnExpressionStmtSyntaxNode at [L830, C9]: addr = addr & 0x00000000ffffffff;
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L830, C9]: addr = addr & 0x00000000ffffffff
      │   │   │       │       ├─ Operator: Assign
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L830, C9]: addr
      │   │   │       │       └─ ArchInsnBinaryExprSyntaxNode at [L830, C16]: addr & 0x00000000ffffffff
      │   │   │       │           ├─ Operator: BitsAnd
      │   │   │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L830, C16]: addr
      │   │   │       │           └─ ArchInsnLiteralExprSyntaxNode at [L830, C23]: 0x00000000ffffffff
      │   │   │       │               ├─ Kind: Hex
      │   │   │       │               └─ ValueString: 0x00000000ffffffff
      │   │   │       │             
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L831, C9]: when sz8 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        } else when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L831, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L831, C23]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000000000ff;\n        }
      │   │   │       │   │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L832, C13]: let res = dataM:8[addr];
      │   │   │       │   │   │   ├─ Name: res
      │   │   │       │   │   │   └─ ArchInsnIndexerExprSyntaxNode at [L832, C23]: dataM:8[addr]
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L832, C23]: dataM:8
      │   │   │       │   │   │       └─ ArchInsnPlaceExprSyntaxNode at [L832, C31]: addr
      │   │   │       │   │   │     
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L833, C13]: to = res & 0x00000000000000ff;
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L833, C13]: to = res & 0x00000000000000ff
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L833, C13]: to
      │   │   │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L833, C18]: res & 0x00000000000000ff
      │   │   │       │   │               ├─ Operator: BitsAnd
      │   │   │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L833, C18]: res
      │   │   │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L833, C24]: 0x00000000000000ff
      │   │   │       │   │                   ├─ Kind: Hex
      │   │   │       │   │                   └─ ValueString: 0x00000000000000ff
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L834, C16]: when sz16 then {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        } else when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L834, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L834, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x000000000000ffff;\n        }
      │   │   │       │       │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L835, C13]: let res = dataM:8[addr];
      │   │   │       │       │   │   ├─ Name: res
      │   │   │       │       │   │   └─ ArchInsnIndexerExprSyntaxNode at [L835, C23]: dataM:8[addr]
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L835, C23]: dataM:8
      │   │   │       │       │   │       └─ ArchInsnPlaceExprSyntaxNode at [L835, C31]: addr
      │   │   │       │       │   │     
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L836, C13]: to = res & 0x000000000000ffff;
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L836, C13]: to = res & 0x000000000000ffff
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L836, C13]: to
      │   │   │       │       │           └─ ArchInsnBinaryExprSyntaxNode at [L836, C18]: res & 0x000000000000ffff
      │   │   │       │       │               ├─ Operator: BitsAnd
      │   │   │       │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L836, C18]: res
      │   │   │       │       │               └─ ArchInsnLiteralExprSyntaxNode at [L836, C24]: 0x000000000000ffff
      │   │   │       │       │                   ├─ Kind: Hex
      │   │   │       │       │                   └─ ValueString: 0x000000000000ffff
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L837, C16]: when sz32 then {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        } else when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L837, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L837, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0x00000000ffffffff;\n        }
      │   │   │       │           │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L838, C13]: let res = dataM:8[addr];
      │   │   │       │           │   │   ├─ Name: res
      │   │   │       │           │   │   └─ ArchInsnIndexerExprSyntaxNode at [L838, C23]: dataM:8[addr]
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L838, C23]: dataM:8
      │   │   │       │           │   │       └─ ArchInsnPlaceExprSyntaxNode at [L838, C31]: addr
      │   │   │       │           │   │     
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L839, C13]: to = res & 0x00000000ffffffff;
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L839, C13]: to = res & 0x00000000ffffffff
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L839, C13]: to
      │   │   │       │           │           └─ ArchInsnBinaryExprSyntaxNode at [L839, C18]: res & 0x00000000ffffffff
      │   │   │       │           │               ├─ Operator: BitsAnd
      │   │   │       │           │               ├─ ArchInsnPlaceExprSyntaxNode at [L839, C18]: res
      │   │   │       │           │               └─ ArchInsnLiteralExprSyntaxNode at [L839, C24]: 0x00000000ffffffff
      │   │   │       │           │                   ├─ Kind: Hex
      │   │   │       │           │                   └─ ValueString: 0x00000000ffffffff
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L840, C16]: when sz64 then {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L840, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L840, C31]: {\n            let res = dataM:8[addr];\n            to = res & 0xffffffffffffffff;\n        }
      │   │   │       │               │   ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L841, C13]: let res = dataM:8[addr];
      │   │   │       │               │   │   ├─ Name: res
      │   │   │       │               │   │   └─ ArchInsnIndexerExprSyntaxNode at [L841, C23]: dataM:8[addr]
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L841, C23]: dataM:8
      │   │   │       │               │   │       └─ ArchInsnPlaceExprSyntaxNode at [L841, C31]: addr
      │   │   │       │               │   │     
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L842, C13]: to = res & 0xffffffffffffffff;
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L842, C13]: to = res & 0xffffffffffffffff
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L842, C13]: to
      │   │   │       │               │           └─ ArchInsnBinaryExprSyntaxNode at [L842, C18]: res & 0xffffffffffffffff
      │   │   │       │               │               ├─ Operator: BitsAnd
      │   │   │       │               │               ├─ ArchInsnPlaceExprSyntaxNode at [L842, C18]: res
      │   │   │       │               │               └─ ArchInsnLiteralExprSyntaxNode at [L842, C24]: 0xffffffffffffffff
      │   │   │       │               │                   ├─ Kind: Hex
      │   │   │       │               │                   └─ ValueString: 0xffffffffffffffff
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L844, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L844, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L844, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L844, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L844, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L844, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: load-c-off
      │   │ 
      │   ├─ ArchInstructionEncodingSyntaxNode at [L847, C5]: instruction cmp = {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    }
      │   │   ├─ ArchIstructionFieldsSequenceSyntaxNode at [L847, C23]: {0011 0010, sequence size, reg as reg1, reg as reg2, 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │   │   │   ├─ ArchInsnFieldsFixedBitsSyntaxNode at [L847, C24]: 0011 0010
      │   │   │   │   └─ BitsStr: 0011 0010
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedSequenceRefSyntaxNode at [L847, C35]: sequence size
      │   │   │   │   ├─ SequenceEncName: size
      │   │   │   │   ├─ CaseName: <NULL>
      │   │   │   │   └─ SequenceAlias: <NULL>
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L847, C50]: reg as reg1
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg1
      │   │   │   │ 
      │   │   │   ├─ ArchInsnFieldsEncodedFieldRefSyntaxNode at [L847, C63]: reg as reg2
      │   │   │   │   ├─ ModifierKind: None
      │   │   │   │   ├─ FieldEncName: reg
      │   │   │   │   └─ FieldName: reg2
      │   │   │   │ 
      │   │   │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L847, C76]: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │       └─ BitsStr: 00 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │   │   │     
      │   │   ├─ ArchInstructionFunctionSyntaxNode at [L847, C130]: {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    }
      │   │   │   └─ ArchInsnBlockStmtSyntaxNode at [L847, C130]: {\n        let result = reg1 - reg2;\n\n        when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }\n\n        IP = IP + 8;\n    }
      │   │   │       ├─ ArchInsnVariableDeclarationStmtSyntaxNode at [L848, C9]: let result = reg1 - reg2;
      │   │   │       │   ├─ Name: result
      │   │   │       │   └─ ArchInsnBinaryExprSyntaxNode at [L848, C22]: reg1 - reg2
      │   │   │       │       ├─ Operator: Sub
      │   │   │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L848, C22]: reg1
      │   │   │       │       └─ ArchInsnPlaceExprSyntaxNode at [L848, C29]: reg2
      │   │   │       │     
      │   │   │       ├─ ArchInsnWhenConditionStmtSyntaxNode at [L850, C9]: when sz8 then {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        } else when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │   ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L850, C14]: sz8
      │   │   │       │   ├─ ArchInsnBlockStmtSyntaxNode at [L850, C23]: {\n            Z = (result == 0);\n            N = (result & (1 << 7)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L851, C13]: Z = (result == 0);
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L851, C13]: Z = (result == 0)
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L851, C13]: Z
      │   │   │       │   │   │       └─ ArchInsnBracesExprSyntaxNode at [L851, C17]: (result == 0)
      │   │   │       │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L851, C18]: result == 0
      │   │   │       │   │   │               ├─ Operator: Equal
      │   │   │       │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L851, C18]: result
      │   │   │       │   │   │               └─ ArchInsnLiteralExprSyntaxNode at [L851, C28]: 0
      │   │   │       │   │   │                   ├─ Kind: Dec
      │   │   │       │   │   │                   └─ ValueString: 0
      │   │   │       │   │   │                 
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L852, C13]: N = (result & (1 << 7)) != 0;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L852, C13]: N = (result & (1 << 7)) != 0
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L852, C13]: N
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L852, C17]: (result & (1 << 7)) != 0
      │   │   │       │   │   │           ├─ Operator: NotEqual
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L852, C17]: (result & (1 << 7))
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L852, C18]: result & (1 << 7)
      │   │   │       │   │   │           │       ├─ Operator: BitsAnd
      │   │   │       │   │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L852, C18]: result
      │   │   │       │   │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L852, C27]: (1 << 7)
      │   │   │       │   │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L852, C28]: 1 << 7
      │   │   │       │   │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │   │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L852, C28]: 1
      │   │   │       │   │   │           │               │   ├─ Kind: Dec
      │   │   │       │   │   │           │               │   └─ ValueString: 1
      │   │   │       │   │   │           │               │ 
      │   │   │       │   │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L852, C33]: 7
      │   │   │       │   │   │           │                   ├─ Kind: Dec
      │   │   │       │   │   │           │                   └─ ValueString: 7
      │   │   │       │   │   │           │                 
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L852, C40]: 0
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 0
      │   │   │       │   │   │             
      │   │   │       │   │   ├─ ArchInsnExpressionStmtSyntaxNode at [L853, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1;
      │   │   │       │   │   │   └─ ArchInsnBinaryExprSyntaxNode at [L853, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1
      │   │   │       │   │   │       ├─ Operator: Assign
      │   │   │       │   │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L853, C13]: V
      │   │   │       │   │   │       └─ ArchInsnBinaryExprSyntaxNode at [L853, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 7) & 1
      │   │   │       │   │   │           ├─ Operator: BitsAnd
      │   │   │       │   │   │           ├─ ArchInsnBracesExprSyntaxNode at [L853, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 7)
      │   │   │       │   │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L853, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 7
      │   │   │       │   │   │           │       ├─ Operator: BitsShRight
      │   │   │       │   │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L853, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │   │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L853, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │   │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │   │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L853, C19]: (reg1 ^ reg2)
      │   │   │       │   │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L853, C20]: reg1 ^ reg2
      │   │   │       │   │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │   │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L853, C20]: reg1
      │   │   │       │   │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L853, C27]: reg2
      │   │   │       │   │   │           │       │       │     
      │   │   │       │   │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L853, C35]: (reg1 ^ result)
      │   │   │       │   │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L853, C36]: reg1 ^ result
      │   │   │       │   │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │   │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L853, C36]: reg1
      │   │   │       │   │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L853, C43]: result
      │   │   │       │   │   │           │       │             
      │   │   │       │   │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L853, C55]: 7
      │   │   │       │   │   │           │           ├─ Kind: Dec
      │   │   │       │   │   │           │           └─ ValueString: 7
      │   │   │       │   │   │           │         
      │   │   │       │   │   │           └─ ArchInsnLiteralExprSyntaxNode at [L853, C60]: 1
      │   │   │       │   │   │               ├─ Kind: Dec
      │   │   │       │   │   │               └─ ValueString: 1
      │   │   │       │   │   │             
      │   │   │       │   │   └─ ArchInsnExpressionStmtSyntaxNode at [L854, C13]: C = (reg1 < reg2);
      │   │   │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L854, C13]: C = (reg1 < reg2)
      │   │   │       │   │           ├─ Operator: Assign
      │   │   │       │   │           ├─ ArchInsnPlaceExprSyntaxNode at [L854, C13]: C
      │   │   │       │   │           └─ ArchInsnBracesExprSyntaxNode at [L854, C17]: (reg1 < reg2)
      │   │   │       │   │               └─ ArchInsnBinaryExprSyntaxNode at [L854, C18]: reg1 < reg2
      │   │   │       │   │                   ├─ Operator: Less
      │   │   │       │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L854, C18]: reg1
      │   │   │       │   │                   └─ ArchInsnPlaceExprSyntaxNode at [L854, C25]: reg2
      │   │   │       │   │                 
      │   │   │       │   └─ ArchInsnWhenConditionStmtSyntaxNode at [L855, C16]: when sz16 then {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        } else when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │       ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L855, C21]: sz16
      │   │   │       │       ├─ ArchInsnBlockStmtSyntaxNode at [L855, C31]: {\n            Z = (result == 0);\n            N = (result & (1 << 15)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L856, C13]: Z = (result == 0);
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L856, C13]: Z = (result == 0)
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L856, C13]: Z
      │   │   │       │       │   │       └─ ArchInsnBracesExprSyntaxNode at [L856, C17]: (result == 0)
      │   │   │       │       │   │           └─ ArchInsnBinaryExprSyntaxNode at [L856, C18]: result == 0
      │   │   │       │       │   │               ├─ Operator: Equal
      │   │   │       │       │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L856, C18]: result
      │   │   │       │       │   │               └─ ArchInsnLiteralExprSyntaxNode at [L856, C28]: 0
      │   │   │       │       │   │                   ├─ Kind: Dec
      │   │   │       │       │   │                   └─ ValueString: 0
      │   │   │       │       │   │                 
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L857, C13]: N = (result & (1 << 15)) != 0;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L857, C13]: N = (result & (1 << 15)) != 0
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L857, C13]: N
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L857, C17]: (result & (1 << 15)) != 0
      │   │   │       │       │   │           ├─ Operator: NotEqual
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L857, C17]: (result & (1 << 15))
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L857, C18]: result & (1 << 15)
      │   │   │       │       │   │           │       ├─ Operator: BitsAnd
      │   │   │       │       │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L857, C18]: result
      │   │   │       │       │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L857, C27]: (1 << 15)
      │   │   │       │       │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L857, C28]: 1 << 15
      │   │   │       │       │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │       │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L857, C28]: 1
      │   │   │       │       │   │           │               │   ├─ Kind: Dec
      │   │   │       │       │   │           │               │   └─ ValueString: 1
      │   │   │       │       │   │           │               │ 
      │   │   │       │       │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L857, C33]: 15
      │   │   │       │       │   │           │                   ├─ Kind: Dec
      │   │   │       │       │   │           │                   └─ ValueString: 15
      │   │   │       │       │   │           │                 
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L857, C41]: 0
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 0
      │   │   │       │       │   │             
      │   │   │       │       │   ├─ ArchInsnExpressionStmtSyntaxNode at [L858, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1;
      │   │   │       │       │   │   └─ ArchInsnBinaryExprSyntaxNode at [L858, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1
      │   │   │       │       │   │       ├─ Operator: Assign
      │   │   │       │       │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L858, C13]: V
      │   │   │       │       │   │       └─ ArchInsnBinaryExprSyntaxNode at [L858, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 15) & 1
      │   │   │       │       │   │           ├─ Operator: BitsAnd
      │   │   │       │       │   │           ├─ ArchInsnBracesExprSyntaxNode at [L858, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 15)
      │   │   │       │       │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L858, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 15
      │   │   │       │       │   │           │       ├─ Operator: BitsShRight
      │   │   │       │       │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L858, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │       │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L858, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │       │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │       │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L858, C19]: (reg1 ^ reg2)
      │   │   │       │       │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L858, C20]: reg1 ^ reg2
      │   │   │       │       │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │       │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L858, C20]: reg1
      │   │   │       │       │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L858, C27]: reg2
      │   │   │       │       │   │           │       │       │     
      │   │   │       │       │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L858, C35]: (reg1 ^ result)
      │   │   │       │       │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L858, C36]: reg1 ^ result
      │   │   │       │       │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │       │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L858, C36]: reg1
      │   │   │       │       │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L858, C43]: result
      │   │   │       │       │   │           │       │             
      │   │   │       │       │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L858, C55]: 15
      │   │   │       │       │   │           │           ├─ Kind: Dec
      │   │   │       │       │   │           │           └─ ValueString: 15
      │   │   │       │       │   │           │         
      │   │   │       │       │   │           └─ ArchInsnLiteralExprSyntaxNode at [L858, C61]: 1
      │   │   │       │       │   │               ├─ Kind: Dec
      │   │   │       │       │   │               └─ ValueString: 1
      │   │   │       │       │   │             
      │   │   │       │       │   └─ ArchInsnExpressionStmtSyntaxNode at [L859, C13]: C = (reg1 < reg2);
      │   │   │       │       │       └─ ArchInsnBinaryExprSyntaxNode at [L859, C13]: C = (reg1 < reg2)
      │   │   │       │       │           ├─ Operator: Assign
      │   │   │       │       │           ├─ ArchInsnPlaceExprSyntaxNode at [L859, C13]: C
      │   │   │       │       │           └─ ArchInsnBracesExprSyntaxNode at [L859, C17]: (reg1 < reg2)
      │   │   │       │       │               └─ ArchInsnBinaryExprSyntaxNode at [L859, C18]: reg1 < reg2
      │   │   │       │       │                   ├─ Operator: Less
      │   │   │       │       │                   ├─ ArchInsnPlaceExprSyntaxNode at [L859, C18]: reg1
      │   │   │       │       │                   └─ ArchInsnPlaceExprSyntaxNode at [L859, C25]: reg2
      │   │   │       │       │                 
      │   │   │       │       └─ ArchInsnWhenConditionStmtSyntaxNode at [L860, C16]: when sz32 then {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        } else when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │           ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L860, C21]: sz32
      │   │   │       │           ├─ ArchInsnBlockStmtSyntaxNode at [L860, C31]: {\n            Z = (result == 0);\n            N = (result & (1 << 31)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L861, C13]: Z = (result == 0);
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L861, C13]: Z = (result == 0)
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L861, C13]: Z
      │   │   │       │           │   │       └─ ArchInsnBracesExprSyntaxNode at [L861, C17]: (result == 0)
      │   │   │       │           │   │           └─ ArchInsnBinaryExprSyntaxNode at [L861, C18]: result == 0
      │   │   │       │           │   │               ├─ Operator: Equal
      │   │   │       │           │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L861, C18]: result
      │   │   │       │           │   │               └─ ArchInsnLiteralExprSyntaxNode at [L861, C28]: 0
      │   │   │       │           │   │                   ├─ Kind: Dec
      │   │   │       │           │   │                   └─ ValueString: 0
      │   │   │       │           │   │                 
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L862, C13]: N = (result & (1 << 31)) != 0;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L862, C13]: N = (result & (1 << 31)) != 0
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L862, C13]: N
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L862, C17]: (result & (1 << 31)) != 0
      │   │   │       │           │   │           ├─ Operator: NotEqual
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L862, C17]: (result & (1 << 31))
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L862, C18]: result & (1 << 31)
      │   │   │       │           │   │           │       ├─ Operator: BitsAnd
      │   │   │       │           │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L862, C18]: result
      │   │   │       │           │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L862, C27]: (1 << 31)
      │   │   │       │           │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L862, C28]: 1 << 31
      │   │   │       │           │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │           │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L862, C28]: 1
      │   │   │       │           │   │           │               │   ├─ Kind: Dec
      │   │   │       │           │   │           │               │   └─ ValueString: 1
      │   │   │       │           │   │           │               │ 
      │   │   │       │           │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L862, C33]: 31
      │   │   │       │           │   │           │                   ├─ Kind: Dec
      │   │   │       │           │   │           │                   └─ ValueString: 31
      │   │   │       │           │   │           │                 
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L862, C41]: 0
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 0
      │   │   │       │           │   │             
      │   │   │       │           │   ├─ ArchInsnExpressionStmtSyntaxNode at [L863, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1;
      │   │   │       │           │   │   └─ ArchInsnBinaryExprSyntaxNode at [L863, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1
      │   │   │       │           │   │       ├─ Operator: Assign
      │   │   │       │           │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L863, C13]: V
      │   │   │       │           │   │       └─ ArchInsnBinaryExprSyntaxNode at [L863, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 31) & 1
      │   │   │       │           │   │           ├─ Operator: BitsAnd
      │   │   │       │           │   │           ├─ ArchInsnBracesExprSyntaxNode at [L863, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 31)
      │   │   │       │           │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L863, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 31
      │   │   │       │           │   │           │       ├─ Operator: BitsShRight
      │   │   │       │           │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L863, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │           │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L863, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │           │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │           │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L863, C19]: (reg1 ^ reg2)
      │   │   │       │           │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L863, C20]: reg1 ^ reg2
      │   │   │       │           │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │           │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L863, C20]: reg1
      │   │   │       │           │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L863, C27]: reg2
      │   │   │       │           │   │           │       │       │     
      │   │   │       │           │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L863, C35]: (reg1 ^ result)
      │   │   │       │           │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L863, C36]: reg1 ^ result
      │   │   │       │           │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │           │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L863, C36]: reg1
      │   │   │       │           │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L863, C43]: result
      │   │   │       │           │   │           │       │             
      │   │   │       │           │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L863, C55]: 31
      │   │   │       │           │   │           │           ├─ Kind: Dec
      │   │   │       │           │   │           │           └─ ValueString: 31
      │   │   │       │           │   │           │         
      │   │   │       │           │   │           └─ ArchInsnLiteralExprSyntaxNode at [L863, C61]: 1
      │   │   │       │           │   │               ├─ Kind: Dec
      │   │   │       │           │   │               └─ ValueString: 1
      │   │   │       │           │   │             
      │   │   │       │           │   └─ ArchInsnExpressionStmtSyntaxNode at [L864, C13]: C = (reg1 < reg2);
      │   │   │       │           │       └─ ArchInsnBinaryExprSyntaxNode at [L864, C13]: C = (reg1 < reg2)
      │   │   │       │           │           ├─ Operator: Assign
      │   │   │       │           │           ├─ ArchInsnPlaceExprSyntaxNode at [L864, C13]: C
      │   │   │       │           │           └─ ArchInsnBracesExprSyntaxNode at [L864, C17]: (reg1 < reg2)
      │   │   │       │           │               └─ ArchInsnBinaryExprSyntaxNode at [L864, C18]: reg1 < reg2
      │   │   │       │           │                   ├─ Operator: Less
      │   │   │       │           │                   ├─ ArchInsnPlaceExprSyntaxNode at [L864, C18]: reg1
      │   │   │       │           │                   └─ ArchInsnPlaceExprSyntaxNode at [L864, C25]: reg2
      │   │   │       │           │                 
      │   │   │       │           └─ ArchInsnWhenConditionStmtSyntaxNode at [L865, C16]: when sz64 then {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │               ├─ ArchMnemonicFormatConstraintSymbolExprSyntaxNode at [L865, C21]: sz64
      │   │   │       │               ├─ ArchInsnBlockStmtSyntaxNode at [L865, C31]: {\n            Z = (result == 0);\n            N = (result & (1 << 63)) != 0;\n            V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;\n            C = (reg1 < reg2);\n        }
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L866, C13]: Z = (result == 0);
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L866, C13]: Z = (result == 0)
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L866, C13]: Z
      │   │   │       │               │   │       └─ ArchInsnBracesExprSyntaxNode at [L866, C17]: (result == 0)
      │   │   │       │               │   │           └─ ArchInsnBinaryExprSyntaxNode at [L866, C18]: result == 0
      │   │   │       │               │   │               ├─ Operator: Equal
      │   │   │       │               │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L866, C18]: result
      │   │   │       │               │   │               └─ ArchInsnLiteralExprSyntaxNode at [L866, C28]: 0
      │   │   │       │               │   │                   ├─ Kind: Dec
      │   │   │       │               │   │                   └─ ValueString: 0
      │   │   │       │               │   │                 
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L867, C13]: N = (result & (1 << 63)) != 0;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L867, C13]: N = (result & (1 << 63)) != 0
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L867, C13]: N
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L867, C17]: (result & (1 << 63)) != 0
      │   │   │       │               │   │           ├─ Operator: NotEqual
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L867, C17]: (result & (1 << 63))
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L867, C18]: result & (1 << 63)
      │   │   │       │               │   │           │       ├─ Operator: BitsAnd
      │   │   │       │               │   │           │       ├─ ArchInsnPlaceExprSyntaxNode at [L867, C18]: result
      │   │   │       │               │   │           │       └─ ArchInsnBracesExprSyntaxNode at [L867, C27]: (1 << 63)
      │   │   │       │               │   │           │           └─ ArchInsnBinaryExprSyntaxNode at [L867, C28]: 1 << 63
      │   │   │       │               │   │           │               ├─ Operator: BitsShLeft
      │   │   │       │               │   │           │               ├─ ArchInsnLiteralExprSyntaxNode at [L867, C28]: 1
      │   │   │       │               │   │           │               │   ├─ Kind: Dec
      │   │   │       │               │   │           │               │   └─ ValueString: 1
      │   │   │       │               │   │           │               │ 
      │   │   │       │               │   │           │               └─ ArchInsnLiteralExprSyntaxNode at [L867, C33]: 63
      │   │   │       │               │   │           │                   ├─ Kind: Dec
      │   │   │       │               │   │           │                   └─ ValueString: 63
      │   │   │       │               │   │           │                 
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L867, C41]: 0
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 0
      │   │   │       │               │   │             
      │   │   │       │               │   ├─ ArchInsnExpressionStmtSyntaxNode at [L868, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1;
      │   │   │       │               │   │   └─ ArchInsnBinaryExprSyntaxNode at [L868, C13]: V = (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1
      │   │   │       │               │   │       ├─ Operator: Assign
      │   │   │       │               │   │       ├─ ArchInsnPlaceExprSyntaxNode at [L868, C13]: V
      │   │   │       │               │   │       └─ ArchInsnBinaryExprSyntaxNode at [L868, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 63) & 1
      │   │   │       │               │   │           ├─ Operator: BitsAnd
      │   │   │       │               │   │           ├─ ArchInsnBracesExprSyntaxNode at [L868, C17]: (((reg1 ^ reg2) & (reg1 ^ result)) >> 63)
      │   │   │       │               │   │           │   └─ ArchInsnBinaryExprSyntaxNode at [L868, C18]: ((reg1 ^ reg2) & (reg1 ^ result)) >> 63
      │   │   │       │               │   │           │       ├─ Operator: BitsShRight
      │   │   │       │               │   │           │       ├─ ArchInsnBracesExprSyntaxNode at [L868, C18]: ((reg1 ^ reg2) & (reg1 ^ result))
      │   │   │       │               │   │           │       │   └─ ArchInsnBinaryExprSyntaxNode at [L868, C19]: (reg1 ^ reg2) & (reg1 ^ result)
      │   │   │       │               │   │           │       │       ├─ Operator: BitsAnd
      │   │   │       │               │   │           │       │       ├─ ArchInsnBracesExprSyntaxNode at [L868, C19]: (reg1 ^ reg2)
      │   │   │       │               │   │           │       │       │   └─ ArchInsnBinaryExprSyntaxNode at [L868, C20]: reg1 ^ reg2
      │   │   │       │               │   │           │       │       │       ├─ Operator: BitsXor
      │   │   │       │               │   │           │       │       │       ├─ ArchInsnPlaceExprSyntaxNode at [L868, C20]: reg1
      │   │   │       │               │   │           │       │       │       └─ ArchInsnPlaceExprSyntaxNode at [L868, C27]: reg2
      │   │   │       │               │   │           │       │       │     
      │   │   │       │               │   │           │       │       └─ ArchInsnBracesExprSyntaxNode at [L868, C35]: (reg1 ^ result)
      │   │   │       │               │   │           │       │           └─ ArchInsnBinaryExprSyntaxNode at [L868, C36]: reg1 ^ result
      │   │   │       │               │   │           │       │               ├─ Operator: BitsXor
      │   │   │       │               │   │           │       │               ├─ ArchInsnPlaceExprSyntaxNode at [L868, C36]: reg1
      │   │   │       │               │   │           │       │               └─ ArchInsnPlaceExprSyntaxNode at [L868, C43]: result
      │   │   │       │               │   │           │       │             
      │   │   │       │               │   │           │       └─ ArchInsnLiteralExprSyntaxNode at [L868, C55]: 63
      │   │   │       │               │   │           │           ├─ Kind: Dec
      │   │   │       │               │   │           │           └─ ValueString: 63
      │   │   │       │               │   │           │         
      │   │   │       │               │   │           └─ ArchInsnLiteralExprSyntaxNode at [L868, C61]: 1
      │   │   │       │               │   │               ├─ Kind: Dec
      │   │   │       │               │   │               └─ ValueString: 1
      │   │   │       │               │   │             
      │   │   │       │               │   └─ ArchInsnExpressionStmtSyntaxNode at [L869, C13]: C = (reg1 < reg2);
      │   │   │       │               │       └─ ArchInsnBinaryExprSyntaxNode at [L869, C13]: C = (reg1 < reg2)
      │   │   │       │               │           ├─ Operator: Assign
      │   │   │       │               │           ├─ ArchInsnPlaceExprSyntaxNode at [L869, C13]: C
      │   │   │       │               │           └─ ArchInsnBracesExprSyntaxNode at [L869, C17]: (reg1 < reg2)
      │   │   │       │               │               └─ ArchInsnBinaryExprSyntaxNode at [L869, C18]: reg1 < reg2
      │   │   │       │               │                   ├─ Operator: Less
      │   │   │       │               │                   ├─ ArchInsnPlaceExprSyntaxNode at [L869, C18]: reg1
      │   │   │       │               │                   └─ ArchInsnPlaceExprSyntaxNode at [L869, C25]: reg2
      │   │   │       │               │                 
      │   │   │       │               └─ ElseBranchOrNull: <NULL>
      │   │   │       │             
      │   │   │       └─ ArchInsnExpressionStmtSyntaxNode at [L872, C9]: IP = IP + 8;
      │   │   │           └─ ArchInsnBinaryExprSyntaxNode at [L872, C9]: IP = IP + 8
      │   │   │               ├─ Operator: Assign
      │   │   │               ├─ ArchInsnPlaceExprSyntaxNode at [L872, C9]: IP
      │   │   │               └─ ArchInsnBinaryExprSyntaxNode at [L872, C14]: IP + 8
      │   │   │                   ├─ Operator: Sum
      │   │   │                   ├─ ArchInsnPlaceExprSyntaxNode at [L872, C14]: IP
      │   │   │                   └─ ArchInsnLiteralExprSyntaxNode at [L872, C19]: 8
      │   │   │                       ├─ Kind: Dec
      │   │   │                       └─ ValueString: 8
      │   │   │                     
      │   │   └─ Name: cmp
      │   │ 
      │   └─ ArchInstructionEncodingSyntaxNode at [L875, C5]: instruction hlt = {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000} {\n	}
      │       ├─ ArchIstructionFieldsSequenceSyntaxNode at [L875, C23]: {1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000}
      │       │   └─ ArchInsnFieldsFixedBitsSyntaxNode at [L875, C24]: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │       │       └─ BitsStr: 1111 1111 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
      │       │     
      │       ├─ ArchInstructionFunctionSyntaxNode at [L875, C105]: {\n	}
      │       │   └─ ArchInsnBlockStmtSyntaxNode at [L875, C105]: {\n	}
      │       │ 
      │       └─ Name: hlt
      │     
      ├─ ArchMnemonicsSyntaxNode at [L878, C5]: mnemonics:\n        format plain1 is "{1}";\n        format plain2 is "{1}, {2}";\n        format plain3 is "{1}, {2}, {3}";\n   \n        mnemonic HLT for hlt();\n        mnemonic NOP for nop();\n        mnemonic RET for ret();\n\n        mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64; \n        mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64;\n        mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64;\n\n        mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64;     \n        mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64; \n        mnemonic LDI32 for load-imm32(to, value) plain2;  \n        mnemonic LDC64 for load-const(to, ptr) plain2;  \n\n        mnemonic PUSH for push(from) plain1;     \n        mnemonic POP for pop(to) plain1; \n\n        mnemonic MOV for mov(to, from) plain2; \n        mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64;    \n        mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64;  \n\n        mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3;\n\n        mnemonic CBW for convert-b-w(to, from) plain2; \n        mnemonic CBD for convert-b-d(to, from) plain2; \n        mnemonic CBQ for convert-b-q(to, from) plain2; \n        mnemonic CWD for convert-w-d(to, from) plain2;\n        mnemonic CWQ for convert-w-q(to, from) plain2; \n        mnemonic CDQ for convert-d-q(to, from) plain2;  \n\n        mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64;   \n        mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64;  \n        mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64;  \n        mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic EQ for eq(reg1) plain1;\n        mnemonic NEQ for neq(reg1) plain1;\n        mnemonic GR for gr(reg1) plain1;\n        mnemonic LE for le(reg1) plain1;\n        mnemonic GREQ for greq(reg1) plain1;\n        mnemonic LEEQ for leeq(reg1) plain1;\n\n        mnemonic JMP for jmp(value) plain1;\n        mnemonic JZ for jz(value) plain1;\n        mnemonic JNZ for jnz(value) plain1;\n        mnemonic JEQ for jeq(value) plain1;\n        mnemonic JNEQ for jneq(value) plain1;\n        mnemonic JGR for jgr(value) plain1;\n        mnemonic JLE for jle(value) plain1;\n        mnemonic JGREQ for jgreq(value) plain1;\n        mnemonic JLEEQ for jleeq(value) plain1;\n\n        mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64; \n\n        mnemonic CALL for call(value) plain1;\n        mnemonic ENTER for enter(value) plain1;\n        mnemonic LEAVE for leave(value) plain1;
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L879, C9]: format plain1 is "{1}"
      │   │   ├─ SingleFormatString: "{1}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain1
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L880, C9]: format plain2 is "{1}, {2}"
      │   │   ├─ SingleFormatString: "{1}, {2}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain2
      │   │ 
      │   ├─ ArchMnemonicAspectFormatDefSyntaxNode at [L881, C9]: format plain3 is "{1}, {2}, {3}"
      │   │   ├─ SingleFormatString: "{1}, {2}, {3}"
      │   │   ├─ MultiFormatStrings: <NULL>
      │   │   ├─ IsSingleFormat: True
      │   │   └─ Name: plain3
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L883, C9]: mnemonic HLT for hlt()
      │   │   └─ Name: HLT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L884, C9]: mnemonic NOP for nop()
      │   │   └─ Name: NOP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L885, C9]: mnemonic RET for ret()
      │   │   └─ Name: RET
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L887, C9]: mnemonic ADD for add(reg1, reg2) "b {1}, {2}" when sz8,\n                     for add(reg1, reg2) "w {1}, {2}" when sz16,\n                     for add(reg1, reg2) "d {1}, {2}" when sz32,\n                     for add(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: ADD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L891, C9]: mnemonic SUB for sub(reg1, reg2) "b {1}, {2}" when sz8,\n                     for sub(reg1, reg2) "w {1}, {2}" when sz16,\n                     for sub(reg1, reg2) "d {1}, {2}" when sz32,\n                     for sub(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: SUB
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L895, C9]: mnemonic MUL for mul(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mul(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mul(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mul(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MUL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L899, C9]: mnemonic DIV for div(reg1, reg2) "b {1}, {2}" when sz8,\n                     for div(reg1, reg2) "w {1}, {2}" when sz16,\n                     for div(reg1, reg2) "d {1}, {2}" when sz32,\n                     for div(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: DIV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L903, C9]: mnemonic MOD for mod(reg1, reg2) "b {1}, {2}" when sz8,\n                     for mod(reg1, reg2) "w {1}, {2}" when sz16,\n                     for mod(reg1, reg2) "d {1}, {2}" when sz32,\n                     for mod(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: MOD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L908, C9]: mnemonic ST for store(from, ptr) "b {1}, {2}" when sz8,\n                    for store(from, ptr) "w {1}, {2}" when sz16,\n                    for store(from, ptr) "d {1}, {2}" when sz32,\n                    for store(from, ptr) "q {1}, {2}" when sz64,\n                    for store-off(from, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for store-off(from, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for store-off(from, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for store-off(from, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: ST
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L916, C9]: mnemonic LD for load(to, ptr) "b {1}, {2}" when sz8,\n                    for load(to, ptr) "w {1}, {2}" when sz16,\n                    for load(to, ptr) "d {1}, {2}" when sz32,\n                    for load(to, ptr) "q {1}, {2}" when sz64,   \n                    for load-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                    for load-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                    for load-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                    for load-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: LD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L924, C9]: mnemonic LDC for load-c-off(to, ptr, offsetValue) "b {1}, [{2}, {3}]" when sz8,\n                     for load-c-off(to, ptr, offsetValue) "w {1}, [{2}, {3}]" when sz16,\n                     for load-c-off(to, ptr, offsetValue) "d {1}, [{2}, {3}]" when sz32,\n                     for load-c-off(to, ptr, offsetValue) "q {1}, [{2}, {3}]" when sz64
      │   │   └─ Name: LDC
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L928, C9]: mnemonic LDI32 for load-imm32(to, value) plain2
      │   │   └─ Name: LDI32
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L929, C9]: mnemonic LDC64 for load-const(to, ptr) plain2
      │   │   └─ Name: LDC64
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L931, C9]: mnemonic PUSH for push(from) plain1
      │   │   └─ Name: PUSH
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L932, C9]: mnemonic POP for pop(to) plain1
      │   │   └─ Name: POP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L934, C9]: mnemonic MOV for mov(to, from) plain2
      │   │   └─ Name: MOV
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L935, C9]: mnemonic MOVT for mov-trunc(to, from) "b {1}, {2}" when sz8,\n                      for mov-trunc(to, from) "w {1}, {2}" when sz16,\n                      for mov-trunc(to, from) "d {1}, {2}" when sz32,\n                      for mov-trunc(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L939, C9]: mnemonic MOVZX for mov-zx(to, from) "b {1}, {2}" when sz8,\n                       for mov-zx(to, from) "w {1}, {2}" when sz16,\n                       for mov-zx(to, from) "d {1}, {2}" when sz32,\n                       for mov-zx(to, from) "q {1}, {2}" when sz64
      │   │   └─ Name: MOVZX
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L944, C9]: mnemonic MEMCPYC for memcpy-const(toPtr, fromPtr, size) plain3
      │   │   └─ Name: MEMCPYC
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L946, C9]: mnemonic CBW for convert-b-w(to, from) plain2
      │   │   └─ Name: CBW
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L947, C9]: mnemonic CBD for convert-b-d(to, from) plain2
      │   │   └─ Name: CBD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L948, C9]: mnemonic CBQ for convert-b-q(to, from) plain2
      │   │   └─ Name: CBQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L949, C9]: mnemonic CWD for convert-w-d(to, from) plain2
      │   │   └─ Name: CWD
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L950, C9]: mnemonic CWQ for convert-w-q(to, from) plain2
      │   │   └─ Name: CWQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L951, C9]: mnemonic CDQ for convert-d-q(to, from) plain2
      │   │   └─ Name: CDQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L953, C9]: mnemonic NEG for neg(reg1) "b {1}" when sz8,\n                     for neg(reg1) "w {1}" when sz16,\n                     for neg(reg1) "d {1}" when sz32,\n                     for neg(reg1) "q {1}" when sz64
      │   │   └─ Name: NEG
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L957, C9]: mnemonic NOT for not-i(reg1) "b {1}" when sz8,\n                    for not-i(reg1) "w {1}" when sz16,\n                    for not-i(reg1) "d {1}" when sz32,\n                    for not-i(reg1) "q {1}" when sz64
      │   │   └─ Name: NOT
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L961, C9]: mnemonic AND for AND(reg1, reg2) "b {1}, {2}" when sz8,\n                     for AND(reg1, reg2) "w {1}, {2}" when sz16,\n                     for AND(reg1, reg2) "d {1}, {2}" when sz32,\n                     for AND(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: AND
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L965, C9]: mnemonic OR for OR(reg1, reg2) "b {1}, {2}" when sz8,\n                    for OR(reg1, reg2) "w {1}, {2}" when sz16,\n                    for OR(reg1, reg2) "d {1}, {2}" when sz32,\n                    for OR(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: OR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L970, C9]: mnemonic EQ for eq(reg1) plain1
      │   │   └─ Name: EQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L971, C9]: mnemonic NEQ for neq(reg1) plain1
      │   │   └─ Name: NEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L972, C9]: mnemonic GR for gr(reg1) plain1
      │   │   └─ Name: GR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L973, C9]: mnemonic LE for le(reg1) plain1
      │   │   └─ Name: LE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L974, C9]: mnemonic GREQ for greq(reg1) plain1
      │   │   └─ Name: GREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L975, C9]: mnemonic LEEQ for leeq(reg1) plain1
      │   │   └─ Name: LEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L977, C9]: mnemonic JMP for jmp(value) plain1
      │   │   └─ Name: JMP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L978, C9]: mnemonic JZ for jz(value) plain1
      │   │   └─ Name: JZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L979, C9]: mnemonic JNZ for jnz(value) plain1
      │   │   └─ Name: JNZ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L980, C9]: mnemonic JEQ for jeq(value) plain1
      │   │   └─ Name: JEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L981, C9]: mnemonic JNEQ for jneq(value) plain1
      │   │   └─ Name: JNEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L982, C9]: mnemonic JGR for jgr(value) plain1
      │   │   └─ Name: JGR
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L983, C9]: mnemonic JLE for jle(value) plain1
      │   │   └─ Name: JLE
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L984, C9]: mnemonic JGREQ for jgreq(value) plain1
      │   │   └─ Name: JGREQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L985, C9]: mnemonic JLEEQ for jleeq(value) plain1
      │   │   └─ Name: JLEEQ
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L987, C9]: mnemonic CMP for cmp(reg1, reg2) "b {1}, {2}" when sz8,\n                     for cmp(reg1, reg2) "w {1}, {2}" when sz16,\n                     for cmp(reg1, reg2) "d {1}, {2}" when sz32,\n                     for cmp(reg1, reg2) "q {1}, {2}" when sz64
      │   │   └─ Name: CMP
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L992, C9]: mnemonic CALL for call(value) plain1
      │   │   └─ Name: CALL
      │   │ 
      │   ├─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L993, C9]: mnemonic ENTER for enter(value) plain1
      │   │   └─ Name: ENTER
      │   │ 
      │   └─ ArchMnemonicAspectMnemonicDefSyntaxNode at [L994, C9]: mnemonic LEAVE for leave(value) plain1
      │       └─ Name: LEAVE
      │     
      ├─ Kind: Default
      └─ Name: myArch
    


